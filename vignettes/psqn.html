<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>psqn: Partially Separable Quasi-Newton</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">psqn: Partially Separable Quasi-Newton</h1>



<style>
img {
    border: none;
}
</style>
<p><span class="math display">\[\renewcommand\vec{\boldsymbol}   \def\bigO#1{\mathcal{O}(#1)}   \def\Cond#1#2{\left(#1\,\middle|\, #2\right)}   \def\mat#1{\boldsymbol{#1}}   \def\der{{\mathop{}\!\mathrm{d}}}   \def\argmax{\text{arg}\,\text{max}}  \def\Prob{\text{P}}  \def\diag{\text{diag}}   \def\argmin{\text{arg}\,\text{min}}   \def\Expe{\text{E}}\]</span></p>
<p>This package provides an optimization method for <em>partially separable</em> functions. Partially separable functions are of the following form:</p>
<p><span class="math display">\[f(\vec x) = \sum_{i = 1}^n f_i(\vec x_{\mathcal I_i})\]</span></p>
<p>where <span class="math inline">\(\vec x\in \mathbb R^l\)</span>,</p>
<p><span class="math display">\[\vec x_{\mathcal I_i} =    (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top)\vec x, \qquad    \mathcal I_i = (j_{i1}, \dots, \mathcal j_{im_i}) \subseteq    \{1, \dots, l\},\]</span> and <span class="math inline">\(\vec e_k\)</span> is the <span class="math inline">\(k\)</span>’th column of the <span class="math inline">\(l\)</span> dimensional identity matrix. Each function <span class="math inline">\(f_i\)</span> is called an <em>element function</em> and only depends on <span class="math inline">\(m_i \ll l\)</span> parameters. This allows for an efficient quasi-Newton method when all the <span class="math inline">\(m_i\)</span>’s are much smaller than the dimension of the parameter vector <span class="math inline">\(\vec x\)</span>, <span class="math inline">\(l\)</span>. The framework can be extended to allow for a linear combination of parameters but we do not cover such problems. This vignette closely follows <span class="citation">Nocedal and Wright (2006)</span> who cover the methods and alternatives in much greater detail.</p>
<p>We first focus on a more restricted form of the problem. See the section called <a href="#generic-example">Generic Example</a> for the more general interface provided by this package. Assume that each index set <span class="math inline">\(\mathcal I_i\)</span> is of the form:</p>
<p><span class="math display">\[\begin{align*}   \mathcal I_i &amp;= \{1,\dots, p\} \cup \mathcal J_i \\   \mathcal J_i \cap \mathcal J_j &amp;= \emptyset \qquad j\neq i \\   \mathcal J_i \cap \{1,\dots, p\} &amp;= \emptyset \qquad \forall i = 1,\dots, n   \end{align*}.\]</span></p>
<p>That is, each index set contains <span class="math inline">\(p\)</span> <em>global parameters</em> and <span class="math inline">\(q_i = \lvert\mathcal J_i\rvert\)</span> <em>private parameters</em> which are particular for each element function, <span class="math inline">\(f_i\)</span>. For implementation reason, we let:</p>
<p><span class="math display">\[\begin{align*}   \overleftarrow q_i &amp;=    \begin{cases} p &amp; i = 0 \\ p + \sum_{k = 1}^i q_k &amp; i &gt; 0 \end{cases} \\   \mathcal J_i &amp;=    \{1 + \overleftarrow q_{i - 1}, \dots , q_i + \overleftarrow q_{i - 1}\}   \end{align*}\]</span></p>
<p>such that the element functions’ private parameters lies in consecutive parts of <span class="math inline">\(\vec x\)</span>.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<p>We are going to consider a Taylor approximation for a generalized linear mixed model. In particular, we focus on a mixed logit regression where:</p>
<p><span class="math display">\[\begin{align*}   \vec U_i &amp;\sim N^{(r)}(\vec 0, \mat\Sigma) \\   \vec\eta_i &amp;= \mat X_i\vec\beta + \mat Z_i\vec U_i \\   Y_{ij} &amp;\sim \text{Bin}(\text{logit}^{-1}(\eta_{ij}), 1),    \qquad j = 1, \dots, t_i   \end{align*}\]</span></p>
<p>where <span class="math inline">\(N^{(r)}(\vec\mu,\mat\Sigma)\)</span> means a <span class="math inline">\(r\)</span>-dimensional a multivariate normal distribution with mean <span class="math inline">\(\vec\mu\)</span> and covariance matrix <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\text{Bin}(p, k)\)</span> means a binomial distribution probability <span class="math inline">\(p\)</span> and size <span class="math inline">\(k\)</span>. <span class="math inline">\(\vec U_i\)</span> is an unknown random effect with an unknown covariance <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\vec\beta\in\mathbb{R}^p\)</span> are unknown fixed effect coefficients. <span class="math inline">\(\mat X_i\)</span> and <span class="math inline">\(\mat Z_i\)</span> are known design matrices each with <span class="math inline">\(t_i\)</span> rows for each of the <span class="math inline">\(t_i\)</span> observed outcomes, the <span class="math inline">\(y_{ij}\)</span>s.</p>
<p>As part of a Taylor approximation, we find a mode of <span class="math inline">\(\vec x = (\vec\beta^\top, \widehat{\vec u}_1^\top, \dots, \widehat{\vec u}_n^\top)\)</span> of the log of the integrand given a covariance matrix estimate, <span class="math inline">\(\widehat{\mat \Sigma}\)</span>. That is, we are minimizing:</p>
<p><span class="math display">\[\begin{align*}   f(\vec x) &amp;= -\sum_{i = 1}^n \left(     \sum_{k = 1}^{t_i}(y_{ij}\eta_{ij} - \log(1 + \exp\eta_{ij}))     - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= -\sum_{i = 1}^n \left(     \vec y_i(\mat X_i\vec\beta + \mat Z_i\widehat{\vec u}_i)     - \sum_{k = 1}^{t_i}     \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\widehat{\vec u}_i))   - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= \sum_{i = 1}^nf_i((\vec\beta^\top, \widehat{\vec u}_i^\top)^\top) \\   f_i((\vec\beta^\top, \vec u^\top)^\top) &amp;=    -\vec y_i(\mat X_i\vec\beta + \mat Z_i\vec u)     + \sum_{k = 1}^{t_i}   \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\vec u))   + \frac 12 \vec u^\top\widehat{\mat \Sigma}^{-1} \vec u   \end{align*}\]</span></p>
<p>In this problem, <span class="math inline">\(\vec\beta\)</span> are the global parameters and the <span class="math inline">\(\widehat{\vec u}_i\)</span>’s are the private parameters. Thus, <span class="math inline">\(l = p + nr\)</span>. We will later return to this example with an implementation which uses this package.</p>
<div id="variational-approximations" class="section level3">
<h3>Variational Approximations</h3>
<p>The objective function for variational approximations for mixed models for clustered data is commonly also partially separable. We will briefly summarize the idea here. <span class="citation">Ormerod and Wand (2012)</span> and <span class="citation">Ormerod (2011)</span> are examples where one might benefit from using the methods in this package.</p>
<p>We let <span class="math inline">\(\tilde f_i\)</span> be the log marginal likelihood term from cluster <span class="math inline">\(i\)</span>. This is of the form:</p>
<p><span class="math display">\[
\tilde f_i(\vec\omega) = \log \int p_i(\vec y_i, \vec u;\vec\omega)\der \vec u 
\]</span></p>
<p>where <span class="math inline">\(\vec\omega\)</span> are unknown model parameters, <span class="math inline">\(p_i(\vec u;\vec\omega)\)</span> is the joint density of the observed data denoted by <span class="math inline">\(\vec y_i\)</span>, and <span class="math inline">\(\vec U_i\)</span> which is a cluster specific random effect. <span class="math inline">\(\exp \tilde f_i(\vec\omega)\)</span> is often intractable. An approximation of <span class="math inline">\(\tilde f_i\)</span> is to select some variational distribution denoted by <span class="math inline">\(v_i\)</span> parameterized by some set <span class="math inline">\(\Theta_i\)</span>. We then use the approximation:</p>
<p><span class="math display">\[
\begin{align*}
\tilde f_i(\vec\omega) &amp;= \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i \vec u;\vec\omega)/v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u_i \mid \vec y_i;\vec\omega)/v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u \\
  &amp;= 
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u
  + \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)}
  \right)\der\vec u \\
&amp;\geq
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u = f_i(\vec\omega,\vec\theta_i)
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span> and <span class="math inline">\(p_i(\vec u_i \mid \vec y_i;\vec\omega)\)</span> is the conditional density of the random effect given the observed data, <span class="math inline">\(\vec y_i\)</span>, and model parameters, <span class="math inline">\(\vec\omega\)</span>. <span class="math inline">\(f_i(\vec\omega,\vec\theta_i)\)</span> is a lower bound since the Kullback–Leibler divergence</p>
<p><span class="math display">\[
\int v_i(\vec u; \vec\theta_i)\log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)} 
  \right)\der\vec u
\]</span></p>
<p>is positive. The idea is to replace the minimization problem:</p>
<p><span class="math display">\[
\argmin_{\vec\omega} -\sum_{i = 1}^n \tilde f_i(\vec\omega)
\]</span></p>
<p>with a variational approximation:</p>
<p><span class="math display">\[
\argmin_{\vec\omega,\vec\theta_1,\dots,\vec\theta_n} 
  -\sum_{i = 1}^n f_i(\vec\omega,\vec\theta_i)
\]</span></p>
<p>This problem fits into the framework in the package where <span class="math inline">\(\vec\omega\)</span> are the global parameters and the <span class="math inline">\(\vec\theta_i\)</span>s are the private parameters.</p>
<p>Variational approximation have the property that if <span class="math inline">\(v_i(\vec u; \vec\theta_i) = p_i(\vec u \mid \vec y_i;\vec\omega)\)</span> then the Kullback–Leibler divergence is zero and the lower bound is equal to the log marginal likelihood. Thus, we need to use a family of variational distributions, <span class="math inline">\(v_i\)</span>, which yields a close approximation of the conditional density of the random effects, <span class="math inline">\(p_i(\vec u \mid \vec y_i;\vec\omega)\)</span>, for some <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span>. Moreover, the lower bound also needs to be easy to optimize. Variational approximations have an advantage that given estimates of <span class="math inline">\(\widehat{\vec\omega},\widehat{\vec\theta}_1,\dots,\widehat{\vec\theta}_n\)</span> then subsequent inference can be approximated using:</p>
<p><span class="math display">\[
\Expe\left(h(\vec U_i)\right) =
  \int h(\vec u) p_i(\vec u \mid \vec y_i;\vec\omega)\der\vec u 
  \approx 
  \int h(\vec u) v_i(\vec u; \widehat{\vec\theta}_i)\der\vec u.
\]</span></p>
<p>The latter integral may be much easier to work with for some functions <span class="math inline">\(h\)</span> and variational distribution, <span class="math inline">\(v_i\)</span>.</p>
</div>
</div>
<div id="quasi-newton-method-for-partially-separable-functions" class="section level2">
<h2>Quasi-Newton Method for Partially Separable Functions</h2>
<p>We are going to assume some prior knowledge of Newton’s method and the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm and we only provide a few details of these methods. However, will need a bit of notations from these methods to motivate the quasi-Newton method we have implemented.</p>
<p>Newton’s method to minimize a function is to start at some value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 1\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\nabla^2 f(\vec x_{k - 1})\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \vec p_k\)</span> or <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \gamma\vec p_k\)</span> for <span class="math inline">\(\gamma \in (0, 1]\)</span> set to satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>, and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>Computing the Hessian, <span class="math inline">\(\nabla^2 f(\vec x_{k - 1})\)</span>, at every iteration can be expensive. The BFGS algorithm offers an alternative where we use an approximation instead. Here we start with some Hessian approximation <span class="math inline">\(\mat B_0\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>find a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>, <span class="math inline">\(\vec s_k = \alpha\vec p_k = \vec x_k - \vec x_{k - 1}\)</span>, <span class="math inline">\(\vec d_k = \nabla f(\vec x_k) - \nabla f(\vec x_{k - 1})\)</span>,</li>
<li>perform a rank-two update <span class="math display">\[\mat B_k = \mat B_{k - 1} + \frac{\vec y_k\vec y_k^\top}{\vec y_k^\top\vec s_k} - \frac{\mat B_{k - 1}\vec s_k\vec s_k^\top\mat B_{k - 1}^\top}{\vec s_k^\top\mat B_{k - 1}\vec s_k},\]</span> and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This reduces the cost of computing the Hessian. Further, we can update <span class="math inline">\(\mat B_k^{-1}\)</span> to avoid solving <span class="math inline">\(\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1})\)</span>. The matrix <span class="math inline">\(\mat B_k^{-1}\)</span> will still be large and dense when <span class="math inline">\(l\)</span> is large.</p>
<div id="using-partial-separability" class="section level3">
<h3>Using Partial Separability</h3>
<p>As an alternative, we can exploit the structure of the problem we are solving. Let</p>
<p><span class="math display">\[\mat H_i = (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top).\]</span></p>
<p>The true Hessian in our case is sparse and given by</p>
<p><span class="math display">\[\nabla^2 f(\vec x) = \sum_{i = 1}^n    \mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\]</span></p>
<p>Notice that each <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> is only a <span class="math inline">\((p + q_i)\times (p + q_i)\)</span> matrix. We illustrate this below with <span class="math inline">\(n = 10\)</span> element functions. Each plot is <span class="math inline">\(\mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\)</span> where black entries are a non-zero.</p>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The whole Hessian is:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAD1BMVEUAAAAaGhoiIiJFRUX////5cEo+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgUlEQVR4nO3QQY6CABBFQRTvf2Z3jAHCUzPDINbbd+enhps2G/57wNEDFAGKAEWAIkARoAhQ9AM0XjU1rgBdBk1dAG0HKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQNHLQLcvC1AEKAIUAYoARYAiQBGgCFAEKAIUPQX0eLCFd0ZBQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYCil4Gyk1kBigBFgCJAEaAIUAQoAhQBigBFvw/00PzPJ4oBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhT9KdCihdjxCQFFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBF+wJ1hxMDFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6GtCihdjOuwBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJA0eGBttpjJ6AIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgKKPBpo33/1E+RNQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6FdAbpSAgQJsBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUPQW0HjV1LgCpNUARYAiQBGgCFAEKAIUAYrup18JmeoS7cYAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>We can use the partial separability to implement a BFGS method where we make <span class="math inline">\(n\)</span> BFGS approximations, one for each element function, <span class="math inline">\(f_i\)</span>. Let <span class="math inline">\(\mat B_{ki}\)</span> be the approximation of <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> at iteration <span class="math inline">\(k\)</span>. Then the method we have implemented starts with <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span> and</p>
<ol style="list-style-type: decimal">
<li>computes a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>finds a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>sets <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>,</li>
<li>performs BFGS updates for each <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span>, and</li>
<li>repeats with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This seems as if it is going to be much slower as we are solving a large linear system if <span class="math inline">\(l\)</span> is large. However, we can use the conjugate gradient method we describe in the next section. This will be fast if we can perform the following matrix-vector product fast:</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec z.\]</span></p>
<p>To elaborate on this, each <span class="math inline">\(\mat H_i^\top\mat B_{k - 1,i}\mat H_i\vec z\)</span> consists of matrix-vector product with a <span class="math inline">\(o_i \times o_i\)</span> symmetric matrix and a vector where <span class="math inline">\(o_i = (p + q_i)\)</span>. This can be done in <span class="math inline">\(2o_i(o_i + 1)\)</span> flops. Thus, the total cost is <span class="math inline">\(2\sum_{i = 1}^n o_i(o_i + 1)\)</span> flops. This is in contrast to the original <span class="math inline">\(2l(l + 1)\)</span> flops with the BFGS method.</p>
<p>As an example suppose that <span class="math inline">\(q_i = 5\)</span> for all <span class="math inline">\(n\)</span> element functions, <span class="math inline">\(n = 5000\)</span>, and <span class="math inline">\(p = 10\)</span>. Then <span class="math inline">\(o_i = 15\)</span> and the matrix-vector product above requires <span class="math inline">\(2\cdot 5000 \cdot 15(15 + 1) = 2400000\)</span> flops. In contrast <span class="math inline">\(l = 5000 \cdot 5 + 10 = 25010\)</span> and the matrix-vector product in the BFGS method requires <span class="math inline">\(2\cdot 25010 (25010 + 1) = 1251050220\)</span> flops. That is 521 times more flops. Similar ratios are shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>More formerly, the former is <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2) = \mathcal O(np^2 + np\bar q + \sum_{i = 1}^nq_i^2)\)</span> where <span class="math inline">\(\bar q = \sum_{i = 1}^n q_i / n\)</span> whereas the matrix-vector product in the BFGS method is <span class="math inline">\(\mathcal O((p + n\bar q)^2) = \mathcal O(p^2 + pn\bar q + (n\bar q)^2)\)</span>. Thus, the former is favorable as long as <span class="math inline">\(np^2 + \sum_{i = 1}^nq_i^2\)</span> is small compared with <span class="math inline">\((n\bar q)^2\)</span>. Furthermore, the rank-two BFGS updates are cheaper and may converge faster to a good approximation. However, we should keep in mind that the original BFGS method yields an approximation of <span class="math inline">\(\mat B_k^{-1}\)</span>. Thus, we do not need to solve a linear system. However, we may not need to take many conjugate gradient iterations to get a good approximation with the implemented quasi-Newton method.</p>
</div>
</div>
<div id="conjugate-gradient-method" class="section level2">
<h2>Conjugate Gradient Method</h2>
<p>The conjugate gradient method we use solves</p>
<p><span class="math display">\[\mat A\vec b = \vec v\]</span></p>
<p>which in our quasi-Newton method is</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1})\]</span></p>
<p>We start of with some initial value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 0\)</span>, <span class="math inline">\(\vec r_0 = \mat A\vec x_0 - \vec v\)</span>, <span class="math inline">\(\vec p_0 = -\vec r_0\)</span>, and:</p>
<ol style="list-style-type: decimal">
<li>find the step length <span class="math display">\[\alpha_k = \frac{\vec r_k^\top\vec r_k}{\vec p_k^\top\mat A\vec p_k},\]</span></li>
<li>find the new value <span class="math display">\[\vec x_{k + 1} = \vec x_k + \alpha_k\vec p_k,\]</span></li>
<li>find the new residual <span class="math display">\[\vec r_{k + 1} = \vec r_k + \alpha_k\mat A\vec p_k,\]</span></li>
<li>set <span class="math inline">\(\beta_{k + 1} = (\vec r_k^\top\vec r_k)^{-1}\vec r_{k + 1}^\top\vec r_{k + 1}\)</span>,</li>
<li>set the new search direction to <span class="math display">\[\vec p_{k + 1} = - \vec r_{k + 1} + \beta_{k + 1}\vec p_k,\]</span> and</li>
<li>stop if <span class="math inline">\(\vec r_{k + 1}^\top\vec r_{k + 1}\)</span> is smaller. Otherwise set <span class="math inline">\(k\leftarrow k + 1\)</span> and repeat.</li>
</ol>
<p>The main issue is the matrix-vector product <span class="math inline">\(\mat A\vec p_k\)</span> but as we argued in the previous section that this can be computed in <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2)\)</span> time. The conjugate gradient method will at most take <span class="math inline">\(h\)</span> iterations where <span class="math inline">\(h\)</span> is the number of rows and columns of <span class="math inline">\(\mat A\)</span>. Moreover, if <span class="math inline">\(\mat A\)</span> only has <span class="math inline">\(r &lt; h\)</span> distinct eigenvalues then we will at most make <span class="math inline">\(r\)</span> conjugate gradient iterations. Lastly, if <span class="math inline">\(\mat A\)</span> has clusters of eigenvalues then we may expect to perform only a number of iterations close to the number of distinct clusters.</p>
<p>In practice, we terminate the conjugate gradient method when <span class="math inline">\(\lVert\vec r_k\rVert &lt; \min (c, \sqrt{\lVert\nabla f(\vec x_{k -1})\rVert})\lVert\nabla f(\vec x_{k -1})\rVert\)</span> where <span class="math inline">\(c\)</span> is a constant the user can set. Moreover, we the package supports diagonal preconditioning or incomplete Cholesky factorization preconditioning The diagonal preconditioning is very cheap and may reduce the number of required conjugate gradient iterations. The incomplete Cholesky factorization preconditioning is from Eigen and may greatly reduce the number of required conjugate gradient iterations at the cost of having to factorize the Hessian approximation.</p>
<p>We can compare the flops of the matrix product in BFGS with applying the conjugate gradient method. Assume that all <span class="math inline">\(q_i\)</span>s are almost <span class="math inline">\(\bar q\)</span>. Then the ratio of flops is approximately:</p>
<p><span class="math display">\[
\frac{p^2 + 2pn\bar q + (n\bar q)^2}
     {n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
\]</span></p>
<p>where <span class="math inline">\(n_{\text{cg}}\)</span> is the number of conjugate gradient iterations. Thus, to get something which is linear in the number of element functions, <span class="math inline">\(n\)</span>, then we must have that:</p>
<p><span class="math display">\[
\begin{align*}
\frac{n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
     {p^2 + 2pn\bar q + (n\bar q)^2} &amp;\leq \frac kn \\
\Leftrightarrow n_{\text{cg}} &amp;\leq \frac kn
  \frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {np^2 + 2pn\bar q + n\bar q^2} \\
&amp;= k\frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {n^2(p^2 + 2p\bar q + \bar q^2)} \\
&amp;\approx k 
  \frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is some fixed constant with <span class="math inline">\(k &lt; n\)</span>. An example of the latter ratio is shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> in the denominator by once computing the first <span class="math inline">\(p\times p\)</span> part of the Hessian approximation prior to performing the conjugate gradient method. This is implemented. The <code>max_cg</code> argument is added because of the considerations above.</p>
</div>
<div id="line-search-and-wolfe-condition" class="section level2">
<h2>Line Search and Wolfe Condition</h2>
<p>We use line search and search for a point which satisfy <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">the strong Wolfe condition</a> by default. The constants in the Wolfe condition can be set by the user. The line search is implemented as described by <span class="citation">Nocedal and Wright (2006)</span> with cubic interpolation in the zoom phase.</p>
</div>
<div id="symmetric-rank-one-updates" class="section level2">
<h2>Symmetric Rank-one Updates</h2>
<p><a href="https://en.wikipedia.org/wiki/Symmetric_rank-one">Symmetric rank-one (SR1)</a> updates are implemented as an alternative to the BFGS updates. The user can set whether the SR1 updates should be used. The SR1 updates do not guarantee that the Hessian approximation is positive definite. Thus, the conjugate gradient method only proceeds if <span class="math inline">\(\vec p_k^\top\mat A\vec p_k &gt; 0\)</span>. That is, if the new direction is a descent direction.</p>
</div>
<div id="example-using-the-implementation" class="section level2">
<h2>Example Using the Implementation</h2>
<p>We simulate a data set below from the mixed logit model we showed earlier.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># assign model parameters, number of random effects, and fixed effects</span></a>
<a class="sourceLine" id="cb1-2" title="2">q &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># number of private parameters per cluster</span></a>
<a class="sourceLine" id="cb1-3" title="3">p &lt;-<span class="st"> </span><span class="dv">5</span> <span class="co"># number of global parameters</span></a>
<a class="sourceLine" id="cb1-4" title="4">beta &lt;-<span class="st"> </span><span class="kw">sqrt</span>((<span class="dv">1</span><span class="op">:</span>p) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(<span class="dv">1</span><span class="op">:</span>p))</a>
<a class="sourceLine" id="cb1-5" title="5">Sigma &lt;-<span class="st"> </span><span class="kw">diag</span>(q)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co"># simulate a data set</span></a>
<a class="sourceLine" id="cb1-8" title="8">n_clusters &lt;-<span class="st"> </span>800L <span class="co"># number of clusters</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">set.seed</span>(<span class="dv">66608927</span>)</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">sim_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</a>
<a class="sourceLine" id="cb1-12" title="12">  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(20L, 1L) <span class="op">+</span><span class="st"> </span>2L</a>
<a class="sourceLine" id="cb1-13" title="13">  X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(p <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)), </a>
<a class="sourceLine" id="cb1-14" title="14">              p)</a>
<a class="sourceLine" id="cb1-15" title="15">  u &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">rnorm</span>(q) <span class="op">%*%</span><span class="st"> </span><span class="kw">chol</span>(Sigma))</a>
<a class="sourceLine" id="cb1-16" title="16">  Z &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(q <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q)), </a>
<a class="sourceLine" id="cb1-17" title="17">              q)</a>
<a class="sourceLine" id="cb1-18" title="18">  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb1-19" title="19">  y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>((<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>eta))<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">&gt;</span><span class="st"> </span><span class="kw">runif</span>(n_members))</a>
<a class="sourceLine" id="cb1-20" title="20">  </a>
<a class="sourceLine" id="cb1-21" title="21">  <span class="kw">list</span>(<span class="dt">X =</span> X, <span class="dt">Z =</span> Z, <span class="dt">y =</span> y, <span class="dt">u =</span> u, <span class="dt">Sigma_inv =</span> <span class="kw">solve</span>(Sigma))</a>
<a class="sourceLine" id="cb1-22" title="22">}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co"># example of the first cluster</span></a>
<a class="sourceLine" id="cb1-25" title="25">sim_dat[[1L]]</a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">#&gt; $X</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">#&gt;         [,1]   [,2]    [,3]</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co">#&gt; [1,]  0.0416 -0.809 -0.1839</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">#&gt; [2,]  0.6524 -1.373 -0.9254</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">#&gt; [3,] -1.3339 -0.957 -0.8708</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="co">#&gt; [4,]  0.7547 -0.156  0.0178</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="co">#&gt; [5,]  0.7191 -0.681 -0.7232</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">#&gt; $Z</span></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="co">#&gt;        [,1]   [,2]   [,3]</span></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">#&gt; [1,]  0.167 -0.483 -0.785</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">#&gt; [2,] -0.266 -0.823  0.794</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">#&gt; [3,]  0.609 -0.549  0.269</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="co">#&gt; [4,] -0.414 -0.457  0.605</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="co">#&gt; $y</span></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">#&gt; [1] 0 0 0</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">#&gt; $u</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">#&gt; [1]  0.0705 -1.7285  0.1538 -0.3245</span></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">#&gt; $Sigma_inv</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></a>
<a class="sourceLine" id="cb1-49" title="49"><span class="co">#&gt; [1,]    1    0    0    0</span></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="co">#&gt; [2,]    0    1    0    0</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">#&gt; [3,]    0    0    1    0</span></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="co">#&gt; [4,]    0    0    0    1</span></a></code></pre></div>
<p>The combined vector with global and private parameters can be created like this (it is a misnoma to call this <code>true_params</code> as the modes of the random effects, the private parameters, should only match the random effects if the clusters are very large):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">true_params &lt;-<span class="st"> </span><span class="kw">c</span>(beta, <span class="kw">sapply</span>(sim_dat, <span class="cf">function</span>(x) x<span class="op">$</span>u))</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co"># global parameters</span></a>
<a class="sourceLine" id="cb2-4" title="4">true_params[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">#&gt; [1] 0.258 0.365 0.447 0.516 0.577</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co"># some of the private parameters</span></a>
<a class="sourceLine" id="cb2-8" title="8">true_params[<span class="dv">1</span><span class="op">:</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>q) <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">#&gt;  [1]  0.0705 -1.7285  0.1538 -0.3245  0.2516 -0.5419 -0.5537 -0.2805 -1.1777</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">#&gt; [10] -1.7539  1.7338  0.5616 -0.8379  1.2412 -1.2046  1.4547</span></a></code></pre></div>
<p>As a reference, we will create the following function to evaluate the log of the integrand:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">eval_integrand &lt;-<span class="st"> </span><span class="cf">function</span>(par){</a>
<a class="sourceLine" id="cb3-2" title="2">  out &lt;-<span class="st"> </span><span class="fl">0.</span></a>
<a class="sourceLine" id="cb3-3" title="3">  inc &lt;-<span class="st"> </span>p</a>
<a class="sourceLine" id="cb3-4" title="4">  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</a>
<a class="sourceLine" id="cb3-6" title="6">    dat &lt;-<span class="st"> </span>sim_dat[[i]]</a>
<a class="sourceLine" id="cb3-7" title="7">    X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</a>
<a class="sourceLine" id="cb3-8" title="8">    Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</a>
<a class="sourceLine" id="cb3-9" title="9">    y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</a>
<a class="sourceLine" id="cb3-10" title="10">    Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</a>
<a class="sourceLine" id="cb3-11" title="11">    </a>
<a class="sourceLine" id="cb3-12" title="12">    u &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>inc]</a>
<a class="sourceLine" id="cb3-13" title="13">    inc &lt;-<span class="st"> </span>inc <span class="op">+</span><span class="st"> </span>q</a>
<a class="sourceLine" id="cb3-14" title="14">    eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb3-15" title="15">    </a>
<a class="sourceLine" id="cb3-16" title="16">    out &lt;-<span class="st"> </span>out <span class="op">-</span><span class="st"> </span><span class="kw">drop</span>(y <span class="op">%*%</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta))) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="st">      </span><span class="fl">.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(u <span class="op">%*%</span><span class="st"> </span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>u)</a>
<a class="sourceLine" id="cb3-18" title="18">  }</a>
<a class="sourceLine" id="cb3-19" title="19">  </a>
<a class="sourceLine" id="cb3-20" title="20">  out</a>
<a class="sourceLine" id="cb3-21" title="21">}</a>
<a class="sourceLine" id="cb3-22" title="22"></a>
<a class="sourceLine" id="cb3-23" title="23"><span class="co"># check the log integrand at true global parameters and the random effects</span></a>
<a class="sourceLine" id="cb3-24" title="24"><span class="kw">eval_integrand</span>(true_params)</a>
<a class="sourceLine" id="cb3-25" title="25"><span class="co">#&gt; [1] 6898</span></a></code></pre></div>
<p>We will use this function to compare with our C++ implementation.</p>
<div id="r-implementation" class="section level3">
<h3>R Implementation</h3>
<p>A R function which we need to pass to <code>psqn</code> to minimize the partially separable function is given below:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># evaluates the negative log integrand. </span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"># </span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"># Args:</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">#   i cluster/element function index. </span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">#   par the global and private parameter for this cluster. It has length </span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">#       zero if the number of parameters is requested.</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">#   comp_grad logical for whether to compute the gradient. </span></a>
<a class="sourceLine" id="cb4-8" title="8">r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</a>
<a class="sourceLine" id="cb4-9" title="9">  dat &lt;-<span class="st"> </span>sim_dat[[i]]</a>
<a class="sourceLine" id="cb4-10" title="10">  X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</a>
<a class="sourceLine" id="cb4-11" title="11">  Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</a>
<a class="sourceLine" id="cb4-12" title="12">  </a>
<a class="sourceLine" id="cb4-13" title="13">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="co"># requested the dimension of the parameter</span></a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>X), <span class="dt">private_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>Z)))</a>
<a class="sourceLine" id="cb4-16" title="16">  </a>
<a class="sourceLine" id="cb4-17" title="17">  y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</a>
<a class="sourceLine" id="cb4-18" title="18">  Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</a>
<a class="sourceLine" id="cb4-19" title="19">  </a>
<a class="sourceLine" id="cb4-20" title="20">  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb4-21" title="21">  uhat &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb4-22" title="22">  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>uhat <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb4-23" title="23">  exp_eta &lt;-<span class="st"> </span><span class="kw">exp</span>(eta)</a>
<a class="sourceLine" id="cb4-24" title="24">  </a>
<a class="sourceLine" id="cb4-25" title="25">  out &lt;-<span class="st"> </span><span class="op">-</span><span class="kw">sum</span>(y <span class="op">*</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-26" title="26"><span class="st">    </span><span class="kw">sum</span>(uhat <span class="op">*</span><span class="st"> </span>(Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)) <span class="op">/</span><span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-27" title="27">  <span class="cf">if</span>(comp_grad){</a>
<a class="sourceLine" id="cb4-28" title="28">    d_eta &lt;-<span class="st"> </span><span class="op">-</span>y <span class="op">+</span><span class="st"> </span>exp_eta <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)</a>
<a class="sourceLine" id="cb4-29" title="29">    grad &lt;-<span class="st"> </span><span class="kw">c</span>(X <span class="op">%*%</span><span class="st"> </span>d_eta, </a>
<a class="sourceLine" id="cb4-30" title="30">              Z <span class="op">%*%</span><span class="st"> </span>d_eta <span class="op">+</span><span class="st"> </span>dat<span class="op">$</span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)</a>
<a class="sourceLine" id="cb4-31" title="31">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</a>
<a class="sourceLine" id="cb4-32" title="32">  }</a>
<a class="sourceLine" id="cb4-33" title="33">  </a>
<a class="sourceLine" id="cb4-34" title="34">  out</a>
<a class="sourceLine" id="cb4-35" title="35">}</a></code></pre></div>
<p>Here is a check that the above yields the same as the function we defined before:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># check the function</span></a>
<a class="sourceLine" id="cb5-2" title="2">r_func_val &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span>n_clusters, <span class="cf">function</span>(i)</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">FALSE</span>)))</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">all.equal</span>(<span class="kw">eval_integrand</span>(true_params), r_func_val)</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co"># we could check the gradient like this</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="cf">if</span>(<span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb5-9" title="9">  r_func_gr &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(true_params))</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</a>
<a class="sourceLine" id="cb5-11" title="11">    out_i &lt;-<span class="st"> </span><span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb5-12" title="12">    r_func_gr[<span class="dv">1</span><span class="op">:</span>p] &lt;-<span class="st"> </span>r_func_gr[<span class="dv">1</span><span class="op">:</span>p] <span class="op">+</span><span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb5-13" title="13">    r_func_gr[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p] &lt;-<span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb5-14" title="14">  }</a>
<a class="sourceLine" id="cb5-15" title="15">  </a>
<a class="sourceLine" id="cb5-16" title="16">  <span class="kw">library</span>(numDeriv)</a>
<a class="sourceLine" id="cb5-17" title="17">  gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(<span class="cf">function</span>(par) <span class="kw">eval_integrand</span>(par), true_params)</a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="kw">all.equal</span>(r_func_gr, gr_num, <span class="dt">tolerance =</span> <span class="fl">1e-6</span>)</a>
<a class="sourceLine" id="cb5-19" title="19">}</a></code></pre></div>
<p>The partially separable function can be minimized like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">start_val &lt;-<span class="st"> </span>true_params </a>
<a class="sourceLine" id="cb6-2" title="2">start_val[  <span class="dv">1</span><span class="op">:</span>p ] &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="st">  </span>start_val[  <span class="dv">1</span><span class="op">:</span>p ] <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="st">  </span><span class="kw">c</span>(<span class="fl">0.49</span>, <span class="fl">-0.63</span>, <span class="fl">-0.4</span>, <span class="fl">-0.33</span>, <span class="fl">-0.38</span>) <span class="co"># ~rnorm(length(beta), sd = .5)</span></a>
<a class="sourceLine" id="cb6-5" title="5">start_val[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span>p)] &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">library</span>(psqn)</a>
<a class="sourceLine" id="cb6-8" title="8">r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb6-9" title="9">                        <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">pre_method =</span> 1L)</a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb6-11" title="11">       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">pre_method =</span> pre_method)</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13">R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(start_val)</a></code></pre></div>
<p>We will later compare this with the result from the C++ implementation which we provide in the next section.</p>
</div>
<div id="c-implementation" class="section level3">
<h3>C++ Implementation</h3>
<p>We provide a C++ implementation with the package as an example of how to use this package. The location of the implementation can be found by calling <code>system.file(&quot;mlogit-ex.cpp&quot;, package = &quot;psqn&quot;)</code>. The most important part of the implementation is the problem specific <code>m_logit_func</code> class, the <code>get_mlogit_optimizer</code> function, and the <code>optim_mlogit</code> function which are needed to perform the optimization. The content of the file is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// we will use OpenMP to perform the computation in parallel</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">// we use RcppArmadillo to simplify the code</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">// we change the unsigned integer type that is used by the package by defining</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="co">// the PSQN_SIZE_T macro variable</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="pp">#define PSQN_SIZE_T </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">int</span></a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="co">// we want to use the incomplete Cholesky factorization as the preconditioner</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="co">// and therefore with need RcppEigen</span></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="pp">#define P</span>SQN_USE_EIGEN</a>
<a class="sourceLine" id="cb7-15" title="15"><span class="co">// [[Rcpp::depends(RcppEigen)]]</span></a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="co">// [[Rcpp::depends(psqn)]]</span></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="pp">#include </span><span class="im">&quot;psqn-Rcpp-wrapper.h&quot;</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></a>
<a class="sourceLine" id="cb7-20" title="20"><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></a>
<a class="sourceLine" id="cb7-21" title="21"><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</a>
<a class="sourceLine" id="cb7-22" title="22"><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></a>
<a class="sourceLine" id="cb7-23" title="23"></a>
<a class="sourceLine" id="cb7-24" title="24"><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></a>
<a class="sourceLine" id="cb7-25" title="25"><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, psqn_uint <span class="at">const</span> n_ele){</a>
<a class="sourceLine" id="cb7-26" title="26">  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-27" title="27">}</a>
<a class="sourceLine" id="cb7-28" title="28"></a>
<a class="sourceLine" id="cb7-29" title="29"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-30" title="30"><span class="co"> implements the element function for a given cluster. The class must provide</span></a>
<a class="sourceLine" id="cb7-31" title="31"><span class="co"> the member functions which we provide here.</span></a>
<a class="sourceLine" id="cb7-32" title="32"></a>
<a class="sourceLine" id="cb7-33" title="33"><span class="co"> We do not need to inherit from the element_function class but we can do it</span></a>
<a class="sourceLine" id="cb7-34" title="34"><span class="co"> to ensure that we have implemented all the member functions.</span></a>
<a class="sourceLine" id="cb7-35" title="35"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-36" title="36"><span class="kw">class</span> <span class="va">m_logit_func</span> <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</a>
<a class="sourceLine" id="cb7-37" title="37">  <span class="co">/// design matrices</span></a>
<a class="sourceLine" id="cb7-38" title="38">  arma::mat <span class="at">const</span> X, Z;</a>
<a class="sourceLine" id="cb7-39" title="39">  <span class="co">/// outcomes</span></a>
<a class="sourceLine" id="cb7-40" title="40">  arma::vec <span class="at">const</span> y;</a>
<a class="sourceLine" id="cb7-41" title="41">  <span class="co">/// inverse covariance matrix</span></a>
<a class="sourceLine" id="cb7-42" title="42">  arma::mat <span class="at">const</span> Sigma_inv;</a>
<a class="sourceLine" id="cb7-43" title="43"></a>
<a class="sourceLine" id="cb7-44" title="44"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb7-45" title="45">  <span class="va">m_logit_func</span>(List data):</a>
<a class="sourceLine" id="cb7-46" title="46">  X        (as&lt;arma::mat&gt;(data[<span class="st">&quot;X&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-47" title="47">  Z        (as&lt;arma::mat&gt;(data[<span class="st">&quot;Z&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-48" title="48">  y        (as&lt;arma::vec&gt;(data[<span class="st">&quot;y&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-49" title="49">  Sigma_inv(as&lt;arma::mat&gt;(data[<span class="st">&quot;Sigma_inv&quot;</span>])) { }</a>
<a class="sourceLine" id="cb7-50" title="50"></a>
<a class="sourceLine" id="cb7-51" title="51">  <span class="co">/// dimension of the global parameters</span></a>
<a class="sourceLine" id="cb7-52" title="52">  psqn_uint global_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-53" title="53">    <span class="cf">return</span> X.n_rows;</a>
<a class="sourceLine" id="cb7-54" title="54">  }</a>
<a class="sourceLine" id="cb7-55" title="55">  <span class="co">/// dimension of the private parameters</span></a>
<a class="sourceLine" id="cb7-56" title="56">  psqn_uint private_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-57" title="57">    <span class="cf">return</span> Z.n_rows;</a>
<a class="sourceLine" id="cb7-58" title="58">  }</a>
<a class="sourceLine" id="cb7-59" title="59"></a>
<a class="sourceLine" id="cb7-60" title="60">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-61" title="61"><span class="co">   computes the element function.</span></a>
<a class="sourceLine" id="cb7-62" title="62"><span class="co">   @param point point to compute function at.</span></a>
<a class="sourceLine" id="cb7-63" title="63"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-64" title="64">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-65" title="65">    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</a>
<a class="sourceLine" id="cb7-66" title="66">                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</a>
<a class="sourceLine" id="cb7-67" title="67"></a>
<a class="sourceLine" id="cb7-68" title="68">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-69" title="69">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</a>
<a class="sourceLine" id="cb7-70" title="70">      <span class="dt">double</span> <span class="at">const</span> eta =</a>
<a class="sourceLine" id="cb7-71" title="71">        arma::dot(beta, X.col(i)) + arma::dot(u, Z.col(i));</a>
<a class="sourceLine" id="cb7-72" title="72">      out -= y[i] * eta - log(<span class="dv">1</span> + exp(eta));</a>
<a class="sourceLine" id="cb7-73" title="73">    }</a>
<a class="sourceLine" id="cb7-74" title="74"></a>
<a class="sourceLine" id="cb7-75" title="75">    out += arma::dot(u, Sigma_inv * u) * <span class="fl">.5</span>;</a>
<a class="sourceLine" id="cb7-76" title="76"></a>
<a class="sourceLine" id="cb7-77" title="77">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-78" title="78">  }</a>
<a class="sourceLine" id="cb7-79" title="79"></a>
<a class="sourceLine" id="cb7-80" title="80">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-81" title="81"><span class="co">   computes the element function and its gradient.</span></a>
<a class="sourceLine" id="cb7-82" title="82"><span class="co">   @param point point to compute function at.</span></a>
<a class="sourceLine" id="cb7-83" title="83"><span class="co">   @param gr gradient vector with respect to global and private parameters.</span></a>
<a class="sourceLine" id="cb7-84" title="84"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-85" title="85">  <span class="dt">double</span> grad</a>
<a class="sourceLine" id="cb7-86" title="86">    (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-87" title="87">    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</a>
<a class="sourceLine" id="cb7-88" title="88">                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</a>
<a class="sourceLine" id="cb7-89" title="89"></a>
<a class="sourceLine" id="cb7-90" title="90">    <span class="co">// create objects to write to for the gradient</span></a>
<a class="sourceLine" id="cb7-91" title="91">    <span class="bu">std::</span>fill(gr, gr + beta.n_elem + u.n_elem, <span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb7-92" title="92">    arma::vec dbeta(gr              , beta.n_elem, <span class="kw">false</span>),</a>
<a class="sourceLine" id="cb7-93" title="93">              du   (gr + beta.n_elem, u.n_elem   , <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-94" title="94"></a>
<a class="sourceLine" id="cb7-95" title="95">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-96" title="96">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</a>
<a class="sourceLine" id="cb7-97" title="97">      arma::vec <span class="at">const</span> xi = X.unsafe_col(i),</a>
<a class="sourceLine" id="cb7-98" title="98">                      zi = Z.unsafe_col(i);</a>
<a class="sourceLine" id="cb7-99" title="99">      <span class="dt">double</span> <span class="at">const</span> eta = arma::dot(beta, xi) + arma::dot(u, zi),</a>
<a class="sourceLine" id="cb7-100" title="100">               exp_eta = exp(eta),</a>
<a class="sourceLine" id="cb7-101" title="101">               d_eta   = y[i] - exp_eta / (<span class="dv">1</span> + exp_eta);</a>
<a class="sourceLine" id="cb7-102" title="102">      out -= y[i] * eta - log(<span class="dv">1</span> + exp_eta);</a>
<a class="sourceLine" id="cb7-103" title="103">      dbeta -= d_eta * xi;</a>
<a class="sourceLine" id="cb7-104" title="104">      du    -= d_eta * zi;</a>
<a class="sourceLine" id="cb7-105" title="105">    }</a>
<a class="sourceLine" id="cb7-106" title="106"></a>
<a class="sourceLine" id="cb7-107" title="107">    arma::vec u_scaled = Sigma_inv * u;</a>
<a class="sourceLine" id="cb7-108" title="108">    out += arma::dot(u, u_scaled) * <span class="fl">.5</span>;</a>
<a class="sourceLine" id="cb7-109" title="109">    du += u_scaled;</a>
<a class="sourceLine" id="cb7-110" title="110"></a>
<a class="sourceLine" id="cb7-111" title="111">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-112" title="112">  }</a>
<a class="sourceLine" id="cb7-113" title="113"></a>
<a class="sourceLine" id="cb7-114" title="114">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-115" title="115"><span class="co">   returns true if the member functions are thread-safe.</span></a>
<a class="sourceLine" id="cb7-116" title="116"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-117" title="117">  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-118" title="118">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb7-119" title="119">  }</a>
<a class="sourceLine" id="cb7-120" title="120">};</a>
<a class="sourceLine" id="cb7-121" title="121"></a>
<a class="sourceLine" id="cb7-122" title="122"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-123" title="123"><span class="co"> as an example, we provide a toy example of an equality constraint. We impose</span></a>
<a class="sourceLine" id="cb7-124" title="124"><span class="co"> that some of the parameters (including the private ones) are on a ball. You</span></a>
<a class="sourceLine" id="cb7-125" title="125"><span class="co"> can skip this if you do not need constraints.</span></a>
<a class="sourceLine" id="cb7-126" title="126"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-127" title="127"><span class="kw">class</span> mlogit_constraint : <span class="kw">public</span> PSQN::base_worker,</a>
<a class="sourceLine" id="cb7-128" title="128">                          <span class="kw">public</span> PSQN::constraint_base&lt;mlogit_constraint&gt;</a>
<a class="sourceLine" id="cb7-129" title="129">{</a>
<a class="sourceLine" id="cb7-130" title="130">  <span class="dt">double</span> radius_sq;</a>
<a class="sourceLine" id="cb7-131" title="131">  <span class="bu">std::</span>vector&lt;psqn_uint&gt; indices_vec;</a>
<a class="sourceLine" id="cb7-132" title="132"></a>
<a class="sourceLine" id="cb7-133" title="133"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb7-134" title="134">  mlogit_constraint(Rcpp::IntegerVector indices_in, <span class="dt">double</span> <span class="at">const</span> radius):</a>
<a class="sourceLine" id="cb7-135" title="135">  base_worker(indices_in.size()),</a>
<a class="sourceLine" id="cb7-136" title="136">  radius_sq{radius * radius}</a>
<a class="sourceLine" id="cb7-137" title="137">  {</a>
<a class="sourceLine" id="cb7-138" title="138">    <span class="co">// fill in the indices</span></a>
<a class="sourceLine" id="cb7-139" title="139">    indices_vec.reserve(indices_in.size());</a>
<a class="sourceLine" id="cb7-140" title="140">    <span class="cf">for</span>(<span class="dt">int</span> i : indices_in){</a>
<a class="sourceLine" id="cb7-141" title="141">      indices_vec.emplace_back</a>
<a class="sourceLine" id="cb7-142" title="142">        (<span class="kw">static_cast</span>&lt;psqn_uint&gt;(i - <span class="dv">1</span>)); <span class="co">// assume one-based</span></a>
<a class="sourceLine" id="cb7-143" title="143">    }</a>
<a class="sourceLine" id="cb7-144" title="144">  }</a>
<a class="sourceLine" id="cb7-145" title="145"></a>
<a class="sourceLine" id="cb7-146" title="146">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb7-147" title="147"><span class="co">   there may be non-linear in-equality constraints in the future and linear</span></a>
<a class="sourceLine" id="cb7-148" title="148"><span class="co">   constraints.</span></a>
<a class="sourceLine" id="cb7-149" title="149"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-150" title="150">  PSQN::<span class="dt">constraint_type</span> type() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-151" title="151">    <span class="cf">return</span> PSQN::<span class="dt">constraint_type</span>::non_lin_eq;</a>
<a class="sourceLine" id="cb7-152" title="152">  }</a>
<a class="sourceLine" id="cb7-153" title="153"></a>
<a class="sourceLine" id="cb7-154" title="154">  psqn_uint n_constrained() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-155" title="155">    <span class="cf">return</span> indices_vec.size();</a>
<a class="sourceLine" id="cb7-156" title="156">  }</a>
<a class="sourceLine" id="cb7-157" title="157">  psqn_uint <span class="at">const</span> * indices() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-158" title="158">    <span class="cf">return</span> indices_vec.data();</a>
<a class="sourceLine" id="cb7-159" title="159">  }</a>
<a class="sourceLine" id="cb7-160" title="160">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *par) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-161" title="161">    <span class="dt">double</span> out{<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb7-162" title="162">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_constrained(); ++i){</a>
<a class="sourceLine" id="cb7-163" title="163">      out += par[i] * par[i];</a>
<a class="sourceLine" id="cb7-164" title="164">    }</a>
<a class="sourceLine" id="cb7-165" title="165">    <span class="cf">return</span> out - radius_sq;</a>
<a class="sourceLine" id="cb7-166" title="166">  }</a>
<a class="sourceLine" id="cb7-167" title="167">  <span class="dt">double</span> grad(<span class="dt">double</span> <span class="at">const</span> *par, <span class="dt">double</span> *gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-168" title="168">    <span class="dt">double</span> out{<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb7-169" title="169">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_constrained(); ++i){</a>
<a class="sourceLine" id="cb7-170" title="170">      out += par[i] * par[i];</a>
<a class="sourceLine" id="cb7-171" title="171">      gr[i] = <span class="dv">2</span> * par[i];</a>
<a class="sourceLine" id="cb7-172" title="172">    }</a>
<a class="sourceLine" id="cb7-173" title="173">    <span class="cf">return</span> out - radius_sq;</a>
<a class="sourceLine" id="cb7-174" title="174">  }</a>
<a class="sourceLine" id="cb7-175" title="175">};</a>
<a class="sourceLine" id="cb7-176" title="176"></a>
<a class="sourceLine" id="cb7-177" title="177"></a>
<a class="sourceLine" id="cb7-178" title="178"><span class="kw">using</span> mlogit_topim = PSQN::optimizer</a>
<a class="sourceLine" id="cb7-179" title="179">  &lt;<span class="va">m_logit_func</span>, PSQN::R_reporter, PSQN::R_interrupter,</a>
<a class="sourceLine" id="cb7-180" title="180">   PSQN::default_caller&lt;<span class="va">m_logit_func</span>&gt;, mlogit_constraint&gt;;</a>
<a class="sourceLine" id="cb7-181" title="181"></a>
<a class="sourceLine" id="cb7-182" title="182"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-183" title="183"><span class="co"> creates a pointer to an object which is needed in the optim_mlogit</span></a>
<a class="sourceLine" id="cb7-184" title="184"><span class="co"> function.</span></a>
<a class="sourceLine" id="cb7-185" title="185"><span class="co"> @param data list with data for each element function.</span></a>
<a class="sourceLine" id="cb7-186" title="186"><span class="co"> @param max_threads maximum number of threads to use.</span></a>
<a class="sourceLine" id="cb7-187" title="187"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-188" title="188"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-189" title="189">SEXP get_mlogit_optimizer(List data, <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</a>
<a class="sourceLine" id="cb7-190" title="190">  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</a>
<a class="sourceLine" id="cb7-191" title="191">  <span class="bu">std::</span>vector&lt;<span class="va">m_logit_func</span>&gt; funcs;</a>
<a class="sourceLine" id="cb7-192" title="192">  funcs.reserve(n_elem_funcs);</a>
<a class="sourceLine" id="cb7-193" title="193">  <span class="cf">for</span>(<span class="kw">auto</span> dat : data)</a>
<a class="sourceLine" id="cb7-194" title="194">    funcs.emplace_back(List(dat));</a>
<a class="sourceLine" id="cb7-195" title="195"></a>
<a class="sourceLine" id="cb7-196" title="196">  <span class="co">// create an XPtr to the object we will need</span></a>
<a class="sourceLine" id="cb7-197" title="197">  XPtr&lt;mlogit_topim&gt; ptr(<span class="kw">new</span> mlogit_topim(funcs, max_threads));</a>
<a class="sourceLine" id="cb7-198" title="198"></a>
<a class="sourceLine" id="cb7-199" title="199">  <span class="co">// return the pointer to be used later</span></a>
<a class="sourceLine" id="cb7-200" title="200">  <span class="cf">return</span> ptr;</a>
<a class="sourceLine" id="cb7-201" title="201">}</a>
<a class="sourceLine" id="cb7-202" title="202"></a>
<a class="sourceLine" id="cb7-203" title="203"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-204" title="204"><span class="co"> performs the optimization.</span></a>
<a class="sourceLine" id="cb7-205" title="205"><span class="co"> @param val vector with starting value for the global and private</span></a>
<a class="sourceLine" id="cb7-206" title="206"><span class="co"> parameters.</span></a>
<a class="sourceLine" id="cb7-207" title="207"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-208" title="208"><span class="co"> @param rel_eps relative convergence threshold.</span></a>
<a class="sourceLine" id="cb7-209" title="209"><span class="co"> @param max_it maximum number iterations.</span></a>
<a class="sourceLine" id="cb7-210" title="210"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-211" title="211"><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></a>
<a class="sourceLine" id="cb7-212" title="212"><span class="co"> @param use_bfgs boolean for whether to use SR1 or BFGS updates.</span></a>
<a class="sourceLine" id="cb7-213" title="213"><span class="co"> @param trace integer where larger values gives more information during the</span></a>
<a class="sourceLine" id="cb7-214" title="214"><span class="co"> optimization.</span></a>
<a class="sourceLine" id="cb7-215" title="215"><span class="co"> @param cg_tol threshold for conjugate gradient method.</span></a>
<a class="sourceLine" id="cb7-216" title="216"><span class="co"> @param strong_wolfe true if the strong Wolfe condition should be used.</span></a>
<a class="sourceLine" id="cb7-217" title="217"><span class="co"> @param max_cg maximum number of conjugate gradient iterations in each</span></a>
<a class="sourceLine" id="cb7-218" title="218"><span class="co"> iteration. Use zero if there should not be a limit.</span></a>
<a class="sourceLine" id="cb7-219" title="219"><span class="co"> @param pre_method preconditioning method in conjugate gradient method.</span></a>
<a class="sourceLine" id="cb7-220" title="220"><span class="co"> zero yields no preconditioning, one yields diagonal preconditioning, and</span></a>
<a class="sourceLine" id="cb7-221" title="221"><span class="co"> two yields the incomplete Cholesky factorization from Eigen.</span></a>
<a class="sourceLine" id="cb7-222" title="222"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-223" title="223"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-224" title="224">List opti<span class="va">m_mlogit</span></a>
<a class="sourceLine" id="cb7-225" title="225">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb7-226" title="226">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb7-227" title="227">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</a>
<a class="sourceLine" id="cb7-228" title="228">   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb7-229" title="229">   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</a>
<a class="sourceLine" id="cb7-230" title="230">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-231" title="231"></a>
<a class="sourceLine" id="cb7-232" title="232">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-233" title="233">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-234" title="234">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-235" title="235"></a>
<a class="sourceLine" id="cb7-236" title="236">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb7-237" title="237">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-238" title="238">  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</a>
<a class="sourceLine" id="cb7-239" title="239">                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb7-240" title="240">                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb7-241" title="241">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb7-242" title="242">    res.n_eval, res.n_grad,  res.n_cg);</a>
<a class="sourceLine" id="cb7-243" title="243">  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</a>
<a class="sourceLine" id="cb7-244" title="244"></a>
<a class="sourceLine" id="cb7-245" title="245">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb7-246" title="246">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb7-247" title="247">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</a>
<a class="sourceLine" id="cb7-248" title="248">    _[<span class="st">&quot;counts&quot;</span>] = counts,</a>
<a class="sourceLine" id="cb7-249" title="249">    _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged );</a>
<a class="sourceLine" id="cb7-250" title="250">}</a>
<a class="sourceLine" id="cb7-251" title="251"></a>
<a class="sourceLine" id="cb7-252" title="252"><span class="co">/**</span></a>
<a class="sourceLine" id="cb7-253" title="253"><span class="co"> like optim_mlogit but possibly with constraints. The additional parameters are</span></a>
<a class="sourceLine" id="cb7-254" title="254"></a>
<a class="sourceLine" id="cb7-255" title="255"><span class="co"> </span><span class="an">@param</span><span class="co"> </span><span class="cv">consts</span><span class="co"> list of lists which each has elements indices and radius. The</span></a>
<a class="sourceLine" id="cb7-256" title="256"><span class="co"> former is the one-based indices of the constraint parameters and the later is</span></a>
<a class="sourceLine" id="cb7-257" title="257"><span class="co"> the radius of the ball.</span></a>
<a class="sourceLine" id="cb7-258" title="258"><span class="co"> </span><span class="an">@param</span><span class="co"> </span><span class="cv">max_it_outer</span><span class="co"> maximum number of augmented Lagrangian step.</span></a>
<a class="sourceLine" id="cb7-259" title="259"><span class="co"> </span><span class="an">@param</span><span class="co"> </span><span class="cv">penalty_start</span><span class="co"> starting value for the augmented Lagrangian method.</span></a>
<a class="sourceLine" id="cb7-260" title="260"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-261" title="261"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-262" title="262">List opti<span class="va">m_aug_Lagrang_mlogit</span></a>
<a class="sourceLine" id="cb7-263" title="263">  (NumericVector val, SEXP ptr, List consts, <span class="dt">double</span> <span class="at">const</span> rel_eps,</a>
<a class="sourceLine" id="cb7-264" title="264">   <span class="dt">unsigned</span> <span class="at">const</span> max_it, <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb7-265" title="265">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">unsigned</span> <span class="at">const</span> max_it_outer, <span class="dt">double</span> <span class="at">const</span> penalty_start = <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb7-266" title="266">   <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb7-267" title="267">   <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>,</a>
<a class="sourceLine" id="cb7-268" title="268">   <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>, psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>,</a>
<a class="sourceLine" id="cb7-269" title="269">   <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</a>
<a class="sourceLine" id="cb7-270" title="270">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-271" title="271"></a>
<a class="sourceLine" id="cb7-272" title="272">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-273" title="273">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-274" title="274">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-275" title="275"></a>
<a class="sourceLine" id="cb7-276" title="276">  <span class="co">// add the constraints</span></a>
<a class="sourceLine" id="cb7-277" title="277">  optim-&gt;constraints.reserve(consts.size());</a>
<a class="sourceLine" id="cb7-278" title="278">  <span class="cf">for</span>(SEXP l : consts){</a>
<a class="sourceLine" id="cb7-279" title="279">    List l_list(l);</a>
<a class="sourceLine" id="cb7-280" title="280">    optim-&gt;constraints.emplace_back(as&lt;IntegerVector&gt;(l_list[<span class="st">&quot;indices&quot;</span>]),</a>
<a class="sourceLine" id="cb7-281" title="281">                                    as&lt;NumericVector&gt;(l_list[<span class="st">&quot;radius&quot;</span>])[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb7-282" title="282">  }</a>
<a class="sourceLine" id="cb7-283" title="283"></a>
<a class="sourceLine" id="cb7-284" title="284">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb7-285" title="285">  <span class="co">// the multipliers for the augmented Lagrangian method</span></a>
<a class="sourceLine" id="cb7-286" title="286">  NumericVector multipliers(consts.size(), <span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb7-287" title="287">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-288" title="288"></a>
<a class="sourceLine" id="cb7-289" title="289">  <span class="kw">auto</span> res = optim-&gt;opti<span class="va">m_aug_Lagrang</span></a>
<a class="sourceLine" id="cb7-290" title="290">    (&amp;par[<span class="dv">0</span>], &amp;multipliers[<span class="dv">0</span>], penalty_start,</a>
<a class="sourceLine" id="cb7-291" title="291">     rel_eps, max_it,</a>
<a class="sourceLine" id="cb7-292" title="292">     max_it_outer, <span class="fl">1e-5</span>,  <span class="co">/* violations_norm_thresh */</span></a>
<a class="sourceLine" id="cb7-293" title="293">     c1, c2,</a>
<a class="sourceLine" id="cb7-294" title="294">     <span class="fl">1.5</span>, <span class="co">/* tau */</span></a>
<a class="sourceLine" id="cb7-295" title="295">     use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb7-296" title="296">     <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb7-297" title="297"></a>
<a class="sourceLine" id="cb7-298" title="298">  <span class="co">// must remember to remove the constraints again</span></a>
<a class="sourceLine" id="cb7-299" title="299">  optim-&gt;constraints.clear();</a>
<a class="sourceLine" id="cb7-300" title="300"></a>
<a class="sourceLine" id="cb7-301" title="301">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb7-302" title="302">    res.n_eval, res.n_grad,  res.n_cg, res.n_aug_Lagrang);</a>
<a class="sourceLine" id="cb7-303" title="303">  counts.names() = CharacterVector::create</a>
<a class="sourceLine" id="cb7-304" title="304">    (<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>, <span class="st">&quot;n_aug_Lagrang&quot;</span>);</a>
<a class="sourceLine" id="cb7-305" title="305"></a>
<a class="sourceLine" id="cb7-306" title="306">  <span class="co">// we have to compute the function value again if we want it without the</span></a>
<a class="sourceLine" id="cb7-307" title="307">  <span class="co">// additional terms from the augmented Lagrangian method</span></a>
<a class="sourceLine" id="cb7-308" title="308">  res.value = optim-&gt;eval(&amp;par[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-309" title="309"></a>
<a class="sourceLine" id="cb7-310" title="310">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb7-311" title="311">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb7-312" title="312">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;multipliers&quot;</span>] = multipliers, _[<span class="st">&quot;value&quot;</span>] = res.value,</a>
<a class="sourceLine" id="cb7-313" title="313">      _[<span class="st">&quot;info&quot;</span>] = info, _[<span class="st">&quot;counts&quot;</span>] = counts, _[<span class="st">&quot;penalty&quot;</span>] = res.penalty,</a>
<a class="sourceLine" id="cb7-314" title="314">    _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged );</a>
<a class="sourceLine" id="cb7-315" title="315">}</a>
<a class="sourceLine" id="cb7-316" title="316"></a>
<a class="sourceLine" id="cb7-317" title="317"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-318" title="318"><span class="co"> performs the optimization but only for the private parameters.</span></a>
<a class="sourceLine" id="cb7-319" title="319"><span class="co"> @param val vector with starting value for the global and private</span></a>
<a class="sourceLine" id="cb7-320" title="320"><span class="co"> parameters.</span></a>
<a class="sourceLine" id="cb7-321" title="321"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-322" title="322"><span class="co"> @param rel_eps relative convergence threshold.</span></a>
<a class="sourceLine" id="cb7-323" title="323"><span class="co"> @param max_it maximum number iterations.</span></a>
<a class="sourceLine" id="cb7-324" title="324"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-325" title="325"><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></a>
<a class="sourceLine" id="cb7-326" title="326"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-327" title="327"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-328" title="328">NumericVector opti<span class="va">m_mlogit_private</span></a>
<a class="sourceLine" id="cb7-329" title="329">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb7-330" title="330">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1, <span class="dt">double</span> <span class="at">const</span> c2){</a>
<a class="sourceLine" id="cb7-331" title="331">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-332" title="332"></a>
<a class="sourceLine" id="cb7-333" title="333">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-334" title="334">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-335" title="335">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit_private: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-336" title="336"></a>
<a class="sourceLine" id="cb7-337" title="337">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb7-338" title="338">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-339" title="339">  <span class="dt">double</span> <span class="at">const</span> res = optim-&gt;optim_priv(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2);</a>
<a class="sourceLine" id="cb7-340" title="340">  par.attr(<span class="st">&quot;value&quot;</span>) = res;</a>
<a class="sourceLine" id="cb7-341" title="341">  <span class="cf">return</span> par;</a>
<a class="sourceLine" id="cb7-342" title="342">}</a>
<a class="sourceLine" id="cb7-343" title="343"></a>
<a class="sourceLine" id="cb7-344" title="344"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-345" title="345"><span class="co"> evaluates the partially separable function.</span></a>
<a class="sourceLine" id="cb7-346" title="346"><span class="co"> @param val vector with global and private parameters to evaluate the</span></a>
<a class="sourceLine" id="cb7-347" title="347"><span class="co"> function at.</span></a>
<a class="sourceLine" id="cb7-348" title="348"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-349" title="349"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-350" title="350"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-351" title="351"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-352" title="352"><span class="dt">double</span> eval_mlogit(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb7-353" title="353">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-354" title="354"></a>
<a class="sourceLine" id="cb7-355" title="355">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-356" title="356">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-357" title="357">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-358" title="358"></a>
<a class="sourceLine" id="cb7-359" title="359">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-360" title="360">  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-361" title="361">}</a>
<a class="sourceLine" id="cb7-362" title="362"></a>
<a class="sourceLine" id="cb7-363" title="363"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-364" title="364"><span class="co"> evaluates the gradient of a partially separable function.</span></a>
<a class="sourceLine" id="cb7-365" title="365"><span class="co"> @param val vector with global and private parameters to evaluate the</span></a>
<a class="sourceLine" id="cb7-366" title="366"><span class="co"> function at.</span></a>
<a class="sourceLine" id="cb7-367" title="367"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-368" title="368"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-369" title="369"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-370" title="370"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-371" title="371">NumericVector grad_mlogit(NumericVector val, SEXP ptr,</a>
<a class="sourceLine" id="cb7-372" title="372">                          <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb7-373" title="373">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-374" title="374"></a>
<a class="sourceLine" id="cb7-375" title="375">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-376" title="376">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-377" title="377">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-378" title="378"></a>
<a class="sourceLine" id="cb7-379" title="379">  NumericVector grad(val.size());</a>
<a class="sourceLine" id="cb7-380" title="380">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-381" title="381">  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</a>
<a class="sourceLine" id="cb7-382" title="382"></a>
<a class="sourceLine" id="cb7-383" title="383">  <span class="cf">return</span> grad;</a>
<a class="sourceLine" id="cb7-384" title="384">}</a>
<a class="sourceLine" id="cb7-385" title="385"></a>
<a class="sourceLine" id="cb7-386" title="386"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-387" title="387"><span class="co"> returns the current Hessian approximation.</span></a>
<a class="sourceLine" id="cb7-388" title="388"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-389" title="389"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-390" title="390"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-391" title="391">NumericMatrix get_Hess_approx_mlogit(SEXP ptr){</a>
<a class="sourceLine" id="cb7-392" title="392">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-393" title="393"></a>
<a class="sourceLine" id="cb7-394" title="394">  NumericMatrix out(optim-&gt;n_par, optim-&gt;n_par);</a>
<a class="sourceLine" id="cb7-395" title="395">  optim-&gt;get_hess(&amp;out[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb7-396" title="396"></a>
<a class="sourceLine" id="cb7-397" title="397">  <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-398" title="398">}</a>
<a class="sourceLine" id="cb7-399" title="399"></a>
<a class="sourceLine" id="cb7-400" title="400"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-401" title="401"><span class="co"> returns the current Hessian approximation as a sparse matrix.</span></a>
<a class="sourceLine" id="cb7-402" title="402"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-403" title="403"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-404" title="404"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-405" title="405">Eigen::SparseMatrix&lt;<span class="dt">double</span>&gt; get_sparse_Hess_approx_mlogit(SEXP ptr){</a>
<a class="sourceLine" id="cb7-406" title="406">  <span class="cf">return</span> XPtr&lt;mlogit_topim&gt;(ptr)-&gt;get_hess_sparse();</a>
<a class="sourceLine" id="cb7-407" title="407">}</a>
<a class="sourceLine" id="cb7-408" title="408"></a>
<a class="sourceLine" id="cb7-409" title="409"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-410" title="410"><span class="co"> returns the true Hessian as a sparse matrix.</span></a>
<a class="sourceLine" id="cb7-411" title="411"></a>
<a class="sourceLine" id="cb7-412" title="412"><span class="co"> @param ptr returned object from get_mlogit_optimizer</span></a>
<a class="sourceLine" id="cb7-413" title="413"><span class="co"> @param val where to evaluate the function at</span></a>
<a class="sourceLine" id="cb7-414" title="414"><span class="co"> @param eps determines the step size given by max(eps, |x| * eps)</span></a>
<a class="sourceLine" id="cb7-415" title="415"><span class="co"> @param scale scaling factor in the Richardson extrapolation</span></a>
<a class="sourceLine" id="cb7-416" title="416"><span class="co"> @param tol relative convergence criteria given by max(tol, |f| * tol)</span></a>
<a class="sourceLine" id="cb7-417" title="417"><span class="co"> @param order maximum number of iteration of the Richardson extrapolation</span></a>
<a class="sourceLine" id="cb7-418" title="418"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-419" title="419"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-420" title="420">Eigen::SparseMatrix&lt;<span class="dt">double</span>&gt; true_hess_sparse</a>
<a class="sourceLine" id="cb7-421" title="421">  (SEXP ptr, NumericVector val, <span class="dt">double</span> <span class="at">const</span> eps = <span class="fl">0.001</span>, <span class="dt">double</span> <span class="at">const</span> scale = <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb7-422" title="422">   <span class="dt">double</span> <span class="at">const</span> tol = <span class="fl">0.000000001</span>, <span class="dt">unsigned</span> <span class="at">const</span> order = <span class="dv">6</span>){</a>
<a class="sourceLine" id="cb7-423" title="423"></a>
<a class="sourceLine" id="cb7-424" title="424">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-425" title="425"></a>
<a class="sourceLine" id="cb7-426" title="426">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-427" title="427">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-428" title="428">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-429" title="429"></a>
<a class="sourceLine" id="cb7-430" title="430">  <span class="cf">return</span> optim-&gt;true_hess_sparse(&amp;val[<span class="dv">0</span>], eps, scale, tol, order);</a>
<a class="sourceLine" id="cb7-431" title="431">}</a>
<a class="sourceLine" id="cb7-432" title="432"></a>
<a class="sourceLine" id="cb7-433" title="433"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-434" title="434"><span class="co"> sets the masked (fixed) parameters.</span></a>
<a class="sourceLine" id="cb7-435" title="435"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-436" title="436"><span class="co"> @param indices zero based indices of the masked parameters.</span></a>
<a class="sourceLine" id="cb7-437" title="437"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-438" title="438"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-439" title="439"><span class="dt">void</span> set_masked(SEXP ptr, Rcpp::IntegerVector indices){</a>
<a class="sourceLine" id="cb7-440" title="440">  XPtr&lt;mlogit_topim&gt;(ptr)-&gt;set_masked(indices.begin(), indices.end());</a>
<a class="sourceLine" id="cb7-441" title="441">}</a>
<a class="sourceLine" id="cb7-442" title="442"></a>
<a class="sourceLine" id="cb7-443" title="443"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-444" title="444"><span class="co"> clears all masked (fixed) parameters.</span></a>
<a class="sourceLine" id="cb7-445" title="445"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-446" title="446"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-447" title="447"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-448" title="448"><span class="dt">void</span> clear_masked(SEXP ptr){</a>
<a class="sourceLine" id="cb7-449" title="449">  XPtr&lt;mlogit_topim&gt;(ptr)-&gt;clear_masked();</a>
<a class="sourceLine" id="cb7-450" title="450">}</a></code></pre></div>
<p>The <code>PSQN::R_reporter</code> class ensures that output will be printed when one passes a <code>trace</code> argument which is greater than zero. The <code>PSQN::R_interrupter</code> class ensures that the user can interrupt the computation. These two classes can be replaced with custom classes if one wants to and provides another implementation. See the source code of this package for the required members.</p>
<p>We can use the code by calling <code>Rcpp::sourceCpp</code> to compile the code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">library</span>(Rcpp)</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;mlogit-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">#&gt; Registered S3 methods overwritten by &#39;RcppEigen&#39;:</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">#&gt;   method               from         </span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">#&gt;   predict.fastLm       RcppArmadillo</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="co">#&gt;   print.fastLm         RcppArmadillo</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">#&gt;   summary.fastLm       RcppArmadillo</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">#&gt;   print.summary.fastLm RcppArmadillo</span></a></code></pre></div>
<p>Then we can create a pointer to an optimizer and check that it yields the correct value and gradient like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1">optimizer &lt;-<span class="st"> </span><span class="kw">get_mlogit_optimizer</span>(sim_dat, <span class="dt">max_threads =</span> 4L)</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="kw">eval_integrand</span>(true_params), </a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)))</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">library</span>(numDeriv)</a>
<a class="sourceLine" id="cb9-8" title="8">gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(</a>
<a class="sourceLine" id="cb9-9" title="9">  <span class="cf">function</span>(par) <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb9-10" title="10">  true_params)</a>
<a class="sourceLine" id="cb9-11" title="11">gr_opt &lt;-<span class="st"> </span><span class="kw">grad_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(gr_num, gr_opt, <span class="dt">tolerance =</span> <span class="fl">1e-5</span>, </a>
<a class="sourceLine" id="cb9-14" title="14">                    <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb9-15" title="15">          <span class="co"># also check the function value!</span></a>
<a class="sourceLine" id="cb9-16" title="16">          <span class="kw">all.equal</span>(<span class="kw">attr</span>(gr_opt, <span class="st">&quot;value&quot;</span>), </a>
<a class="sourceLine" id="cb9-17" title="17">                    <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, </a>
<a class="sourceLine" id="cb9-18" title="18">                                <span class="dt">n_threads =</span> 2L)))</a></code></pre></div>
<p>We can now use the BFGS implementation in the <code>optim</code> function to compare with like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">optim_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">optim</span>(</a>
<a class="sourceLine" id="cb10-3" title="3">    par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb10-4" title="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb10-6" title="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">reltol =</span> <span class="fl">1e-8</span>))</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9">bfgs_res &lt;-<span class="st"> </span><span class="kw">optim_func</span>(start_val)</a></code></pre></div>
<p>We then use the quasi-Newton method like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb11-2" title="2">                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L, <span class="dt">use_bfgs =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb11-3" title="3">                      <span class="dt">opt_private =</span> <span class="ot">FALSE</span>, <span class="dt">pre_method =</span> 1L){</a>
<a class="sourceLine" id="cb11-4" title="4">  rel_eps &lt;-<span class="st"> </span><span class="fl">1e-8</span></a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="cf">if</span>(opt_private){</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="co"># it may be useful to fix the global parameters and optimize the </span></a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="co"># private parameters to get starting values. This is very fast as each </span></a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="co"># set of parameters can be optimized separately</span></a>
<a class="sourceLine" id="cb11-9" title="9">    par &lt;-<span class="st"> </span><span class="kw">optim_mlogit_private</span>(</a>
<a class="sourceLine" id="cb11-10" title="10">      <span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="kw">sqrt</span>(rel_eps), <span class="dt">max_it =</span> <span class="dv">100</span>, </a>
<a class="sourceLine" id="cb11-11" title="11">      <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2)</a>
<a class="sourceLine" id="cb11-12" title="12">  }</a>
<a class="sourceLine" id="cb11-13" title="13">  <span class="kw">optim_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> rel_eps, </a>
<a class="sourceLine" id="cb11-14" title="14">               <span class="dt">max_it =</span> 1000L, <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </a>
<a class="sourceLine" id="cb11-15" title="15">               <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, <span class="dt">use_bfgs =</span> use_bfgs, </a>
<a class="sourceLine" id="cb11-16" title="16">               <span class="dt">pre_method =</span> pre_method)</a>
<a class="sourceLine" id="cb11-17" title="17">}</a>
<a class="sourceLine" id="cb11-18" title="18"></a>
<a class="sourceLine" id="cb11-19" title="19">psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val)</a>
<a class="sourceLine" id="cb11-20" title="20"></a>
<a class="sourceLine" id="cb11-21" title="21"><span class="co"># using SR1 updates</span></a>
<a class="sourceLine" id="cb11-22" title="22">psqn_res_sr1 &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb11-23" title="23"><span class="kw">all.equal</span>(psqn_res_sr1<span class="op">$</span>value, psqn_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb11-24" title="24"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb11-25" title="25"></a>
<a class="sourceLine" id="cb11-26" title="26"><span class="co"># w/ different starting values</span></a>
<a class="sourceLine" id="cb11-27" title="27">psqn_res_diff_start &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">opt_private =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-28" title="28"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_diff_start<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb11-29" title="29"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>The <code>counts</code> element contains the number of function evaluations, gradient evaluations, and the total number of conjugate gradient iterations:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">psqn_res<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">#&gt;       13       12       20</span></a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co"># it is the same as we got from R</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>par, R_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, R_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co"># compare with optim</span></a>
<a class="sourceLine" id="cb12-12" title="12">bfgs_res<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">#&gt; function gradient </span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co">#&gt;       62       19</span></a></code></pre></div>
<p>We can compare the solution with the solution from <code>optim</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">all.equal</span>(bfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">#&gt; [1] &quot;Mean relative difference: 7.81e-05&quot;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value, <span class="dt">tolerance =</span> <span class="fl">1e-8</span>)</a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb13-5" title="5">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>bfgs_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">#&gt; [1] -5.61e-06</span></a></code></pre></div>
<p>The <code>optim_mlogit</code> takes fewer iterations possibly because we quicker get a good approximation of the Hessian. Furthermore, we only take <code>psqn_res$counts[&quot;n_cg&quot;]</code>, 20, conjugate gradient iterations. This in contrast to the worst case scenario where we make <code>length(start_val)</code>, 3205, iterations for just one iteration of the quasi-Newton method! We can also compare with the limited memory BFGS minimizer from the <code>lbfgsb3c</code> package:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">library</span>(lbfgsb3c)</a>
<a class="sourceLine" id="cb14-2" title="2">lbfgsb3c_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">lbfgsb3c</span>(<span class="dt">par =</span> par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb14-4" title="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb14-6" title="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">factr =</span> <span class="fl">1e-8</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>, <span class="dt">maxit =</span> 1000L))</a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9">lbfgsb3c_res &lt;-<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val)</a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb14-12" title="12"><span class="co">#&gt; [1] &quot;Mean relative difference: 1.71e-05&quot;</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb14-14" title="14"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb14-15" title="15">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgsb3c_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb14-16" title="16"><span class="co">#&gt; [1] 2.22e-06</span></a></code></pre></div>
<p>We can also compare with the limited memory BFGS minimizer from the <code>lbfgs</code> package:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">library</span>(lbfgs)</a>
<a class="sourceLine" id="cb15-2" title="2">lbfgs_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="kw">lbfgs</span>(<span class="dt">vars =</span> par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb15-4" title="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb15-6" title="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="dt">invisible =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9">lbfgs_res &lt;-<span class="st"> </span><span class="kw">lbfgs_func</span>(start_val)</a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb15-12" title="12"><span class="co">#&gt; [1] &quot;Mean relative difference: 1.74e-05&quot;</span></a>
<a class="sourceLine" id="cb15-13" title="13"><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb15-14" title="14"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb15-15" title="15">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgs_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb15-16" title="16"><span class="co">#&gt; [1] 2.22e-06</span></a></code></pre></div>
<div id="getting-the-hessian-approximation" class="section level4">
<h4>Getting the Hessian Approximation</h4>
<p>We can get the Hessian approximation by calling the <code>get_Hess_approx_mlogit</code> and <code>get_sparse_Hess_approx_mlogit</code> we declared after calling the optimizer:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1">aprox_hes &lt;-<span class="st"> </span><span class="kw">get_Hess_approx_mlogit</span>(<span class="dt">ptr =</span> optimizer)</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">dim</span>(aprox_hes) <span class="co"># quite large; requires a lot of memory</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">#&gt; [1] 3205 3205</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co"># we can also get the sparse version</span></a>
<a class="sourceLine" id="cb16-6" title="6">aprox_hes_sparse &lt;-<span class="st"> </span><span class="kw">get_sparse_Hess_approx_mlogit</span>(optimizer)</a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">all.equal</span>(<span class="kw">as.matrix</span>(aprox_hes_sparse), aprox_hes, </a>
<a class="sourceLine" id="cb16-8" title="8">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="co"># this require much less memory </span></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="kw">object.size</span>(aprox_hes)</a>
<a class="sourceLine" id="cb16-13" title="13"><span class="co">#&gt; 82176416 bytes</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="kw">object.size</span>(aprox_hes_sparse)</a>
<a class="sourceLine" id="cb16-15" title="15"><span class="co">#&gt; 552224 bytes</span></a>
<a class="sourceLine" id="cb16-16" title="16"></a>
<a class="sourceLine" id="cb16-17" title="17"><span class="co"># we can roughly check against the true values as follows</span></a>
<a class="sourceLine" id="cb16-18" title="18"><span class="cf">if</span>(<span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb16-19" title="19">  <span class="co"># only feasible for smaller problem</span></a>
<a class="sourceLine" id="cb16-20" title="20">  hess_true &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</a>
<a class="sourceLine" id="cb16-21" title="21">    <span class="cf">function</span>(par) <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb16-22" title="22">    psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb16-23" title="23">  </a>
<a class="sourceLine" id="cb16-24" title="24">  <span class="co"># should not hold exactly! Might not be that good of an approximation.</span></a>
<a class="sourceLine" id="cb16-25" title="25">  <span class="kw">all.equal</span>(aprox_hes, hess_true)</a>
<a class="sourceLine" id="cb16-26" title="26">  </a>
<a class="sourceLine" id="cb16-27" title="27">  <span class="co"># the non-zero entries should match </span></a>
<a class="sourceLine" id="cb16-28" title="28">  v1 &lt;-<span class="st"> </span><span class="kw">abs</span>(hess_true) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb16-29" title="29">  v2 &lt;-<span class="st"> </span><span class="kw">abs</span>(aprox_hes) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb16-30" title="30">  <span class="kw">all.equal</span>(v1, v2)</a>
<a class="sourceLine" id="cb16-31" title="31">}</a>
<a class="sourceLine" id="cb16-32" title="32"></a>
<a class="sourceLine" id="cb16-33" title="33"><span class="co"># create a plot like before. Black entries are non-zero</span></a>
<a class="sourceLine" id="cb16-34" title="34"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>))</a>
<a class="sourceLine" id="cb16-35" title="35">idx &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">min</span>(<span class="dv">1000</span>, <span class="kw">NROW</span>(aprox_hes))</a>
<a class="sourceLine" id="cb16-36" title="36">aprox_hes &lt;-<span class="st"> </span>aprox_hes[idx, idx] <span class="co"># reduce dimension to plot quickly</span></a>
<a class="sourceLine" id="cb16-37" title="37"><span class="kw">image</span>(<span class="kw">abs</span>(aprox_hes[, <span class="kw">NCOL</span>(aprox_hes)<span class="op">:</span><span class="dv">1</span>]) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dt">xaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>,</a>
<a class="sourceLine" id="cb16-38" title="38">      <span class="dt">col =</span> <span class="kw">gray.colors</span>(2L, <span class="dv">1</span>, <span class="dv">0</span>))</a></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The true Hessian is very sparse.</p>
</div>
<div id="getting-the-true-hessian" class="section level4">
<h4>Getting the True Hessian</h4>
<p>We can also get the true Hessian. This is computed with numerical differentiation using Richardson extrapolation. We provide an example of this below.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" title="1"><span class="co"># compute the hessian with the package</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">system.time</span>(hess &lt;-<span class="st"> </span><span class="kw">true_hess_sparse</span>(<span class="dt">val =</span> psqn_res<span class="op">$</span>par, <span class="dt">ptr =</span> optimizer))</a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">#&gt;    user  system elapsed </span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">#&gt;   0.029   0.000   0.030</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co"># compare with numerical differentiation from R. We only check the first </span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co"># elements</span></a>
<a class="sourceLine" id="cb17-8" title="8">n_comp &lt;-<span class="st"> </span>160L</a>
<a class="sourceLine" id="cb17-9" title="9"><span class="kw">system.time</span>(</a>
<a class="sourceLine" id="cb17-10" title="10">  hess_num_deriv &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</a>
<a class="sourceLine" id="cb17-11" title="11">      <span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb17-12" title="12">        par &lt;-<span class="st"> </span>psqn_res<span class="op">$</span>par</a>
<a class="sourceLine" id="cb17-13" title="13">        par[<span class="dv">1</span><span class="op">:</span>n_comp] &lt;-<span class="st"> </span>x</a>
<a class="sourceLine" id="cb17-14" title="14">        <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)[<span class="dv">1</span><span class="op">:</span>n_comp]</a>
<a class="sourceLine" id="cb17-15" title="15">      }, </a>
<a class="sourceLine" id="cb17-16" title="16">      <span class="kw">head</span>(psqn_res<span class="op">$</span>par, n_comp)))</a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co">#&gt;    user  system elapsed </span></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="co">#&gt;   0.650   0.008   0.330</span></a>
<a class="sourceLine" id="cb17-19" title="19"></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb17-21" title="21"><span class="kw">all.equal</span>(Matrix<span class="op">::</span><span class="kw">Matrix</span>(hess_num_deriv, <span class="dt">sparse =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb17-22" title="22">          hess[<span class="dv">1</span><span class="op">:</span>n_comp, <span class="dv">1</span><span class="op">:</span>n_comp])</a>
<a class="sourceLine" id="cb17-23" title="23"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="using-different-preconditioners" class="section level4">
<h4>Using Different Preconditioners</h4>
<p>We can use different preconditioners. We illustrate this below. Notice that you have to define the <code>PSQN_USE_EIGEN</code> macro variable prior to including any of the psqn headers files if you are using the C++ interface in order to use the incomplete Cholesky factorization from Eigen. You will also have to include RcppEigen or the psqn-Rcpp-wrapper.h header.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" title="1"><span class="co"># without any preconditioner</span></a>
<a class="sourceLine" id="cb18-2" title="2">psqn_res_no_pre &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">pre_method =</span> 0L)</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co"># we get the same</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_no_pre<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb18-6" title="6"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb18-7" title="7"></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="co"># we mainly use more conjugate gradient steps</span></a>
<a class="sourceLine" id="cb18-9" title="9">psqn_res       <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb18-10" title="10"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="co">#&gt;       13       12       20</span></a>
<a class="sourceLine" id="cb18-12" title="12">psqn_res_no_pre<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb18-13" title="13"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb18-14" title="14"><span class="co">#&gt;       16       15       59</span></a>
<a class="sourceLine" id="cb18-15" title="15"></a>
<a class="sourceLine" id="cb18-16" title="16"><span class="co"># with the incomplete Cholesky factorization</span></a>
<a class="sourceLine" id="cb18-17" title="17">psqn_res_cholesky &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">pre_method =</span> 2L)</a>
<a class="sourceLine" id="cb18-18" title="18"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_cholesky<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb18-19" title="19"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb18-20" title="20"></a>
<a class="sourceLine" id="cb18-21" title="21"><span class="co"># we use fewer conjugate gradient steps</span></a>
<a class="sourceLine" id="cb18-22" title="22">psqn_res_cholesky<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb18-23" title="23"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb18-24" title="24"><span class="co">#&gt;       12       11       10</span></a>
<a class="sourceLine" id="cb18-25" title="25">psqn_res         <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb18-26" title="26"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb18-27" title="27"><span class="co">#&gt;       13       12       20</span></a>
<a class="sourceLine" id="cb18-28" title="28"></a>
<a class="sourceLine" id="cb18-29" title="29"><span class="co"># we can equally use the R interface</span></a>
<a class="sourceLine" id="cb18-30" title="30">psqn_res_cholesky_R &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(start_val, <span class="dt">pre_method =</span> 2L)</a>
<a class="sourceLine" id="cb18-31" title="31"></a>
<a class="sourceLine" id="cb18-32" title="32"><span class="kw">all.equal</span>(psqn_res_cholesky_R[<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)], </a>
<a class="sourceLine" id="cb18-33" title="33">          psqn_res_cholesky  [<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)])</a>
<a class="sourceLine" id="cb18-34" title="34"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="benchmarking" class="section level4">
<h4>Benchmarking</h4>
<p>Finally, here is a benchmark to compare the computation time:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" title="1">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="st">`</span><span class="dt">   optim BFGS (2 threads)</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">optim_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="st">`</span><span class="dt">         lbfgs (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="st">`</span><span class="dt">         lbfgs(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="st">`</span><span class="dt">         lbfgs(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="st">`</span><span class="dt">      lbfgsb3c (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb19-7" title="7">  <span class="st">`</span><span class="dt">      lbfgsb3c(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb19-8" title="8">  <span class="st">`</span><span class="dt">      lbfgsb3c(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb19-9" title="9">  <span class="st">`</span><span class="dt">       psqn (R; 1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb19-10" title="10">  <span class="st">`</span><span class="dt">       psqn(R; 2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb19-11" title="11">  <span class="st">`</span><span class="dt">     psqn (1 thread, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb19-12" title="12">                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb19-13" title="13">  <span class="st">`</span><span class="dt">     psqn(2 threads, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L, </a>
<a class="sourceLine" id="cb19-14" title="14">                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="st">`</span><span class="dt">psqn  (1 thread, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb19-16" title="16">                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb19-17" title="17">  <span class="st">`</span><span class="dt">psqn (2 threads, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 2L, </a>
<a class="sourceLine" id="cb19-18" title="18">                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb19-19" title="19">  <span class="st">`</span><span class="dt">  psqn (1 thread; no pre)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb19-20" title="20">                                              <span class="dt">pre_method =</span> 0L),</a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="st">`</span><span class="dt">psqn (1 thread; Cholesky)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb19-22" title="22">                                              <span class="dt">pre_method =</span> 2L),</a>
<a class="sourceLine" id="cb19-23" title="23">  <span class="st">`</span><span class="dt">          psqn (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb19-24" title="24">  <span class="st">`</span><span class="dt">          psqn(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb19-25" title="25">  <span class="st">`</span><span class="dt">          psqn(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb19-26" title="26">  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb19-27" title="27"><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></a>
<a class="sourceLine" id="cb19-28" title="28"><span class="co">#&gt; # A tibble: 18 × 6</span></a>
<a class="sourceLine" id="cb19-29" title="29"><span class="co">#&gt;    expression                      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb19-30" title="30"><span class="co">#&gt;    &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb19-31" title="31"><span class="co">#&gt;  1    optim BFGS (2 threads)     1.14s    1.15s     0.852   42.38MB    0    </span></a>
<a class="sourceLine" id="cb19-32" title="32"><span class="co">#&gt;  2          lbfgs (1 thread)  148.27ms 149.67ms     6.59    49.52MB    0.998</span></a>
<a class="sourceLine" id="cb19-33" title="33"><span class="co">#&gt;  3          lbfgs(2 threads)  102.65ms 103.66ms     9.55    51.27MB    1.79 </span></a>
<a class="sourceLine" id="cb19-34" title="34"><span class="co">#&gt;  4          lbfgs(4 threads)    58.4ms  59.65ms    16.1      49.5MB    3.19 </span></a>
<a class="sourceLine" id="cb19-35" title="35"><span class="co">#&gt;  5       lbfgsb3c (1 thread)  265.83ms 268.58ms     3.71    36.59MB    0.586</span></a>
<a class="sourceLine" id="cb19-36" title="36"><span class="co">#&gt;  6       lbfgsb3c(2 threads)   92.07ms  92.82ms    10.7     22.27MB    0.994</span></a>
<a class="sourceLine" id="cb19-37" title="37"><span class="co">#&gt;  7       lbfgsb3c(4 threads)   65.78ms  67.41ms    14.6     25.97MB    1.59 </span></a>
<a class="sourceLine" id="cb19-38" title="38"><span class="co">#&gt;  8        psqn (R; 1 thread)  201.26ms 205.23ms     4.85     7.93MB    9.50 </span></a>
<a class="sourceLine" id="cb19-39" title="39"><span class="co">#&gt;  9        psqn(R; 2 threads)  207.48ms 213.12ms     4.69     7.91MB    9.19 </span></a>
<a class="sourceLine" id="cb19-40" title="40"><span class="co">#&gt; 10      psqn (1 thread, SR1)   17.45ms  17.51ms    57.0     27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-41" title="41"><span class="co">#&gt; 11      psqn(2 threads, SR1)    11.2ms  11.85ms    84.6     27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-42" title="42"><span class="co">#&gt; 12 psqn  (1 thread, opt pri.)  13.69ms  13.72ms    72.7     60.23KB    0    </span></a>
<a class="sourceLine" id="cb19-43" title="43"><span class="co">#&gt; 13 psqn (2 threads, opt pri.)   7.77ms   8.19ms   122.      55.16KB    0    </span></a>
<a class="sourceLine" id="cb19-44" title="44"><span class="co">#&gt; 14   psqn (1 thread; no pre)   13.93ms  14.02ms    71.2     27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-45" title="45"><span class="co">#&gt; 15 psqn (1 thread; Cholesky)   47.34ms  47.71ms    20.9     27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-46" title="46"><span class="co">#&gt; 16           psqn (1 thread)   10.49ms  10.55ms    94.6     27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-47" title="47"><span class="co">#&gt; 17           psqn(2 threads)    6.14ms   6.23ms   160.      27.58KB    0    </span></a>
<a class="sourceLine" id="cb19-48" title="48"><span class="co">#&gt; 18           psqn(4 threads)    3.87ms   3.94ms   253.      27.58KB    0</span></a></code></pre></div>
<p>We see a large reduction. To be fair, we can use the C interface for the limited-memory BFGS methods to avoid re-allocating the gradient at every iteration. This will reduce their computation time. The R version of the quasi-Newton method is slower mainly as the R version to evaluate the log of the integrand and its derivative is slower than the version used by all the other methods. We can illustrate this by comparing with the computation time with the <code>eval_integrand</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="st">`</span><span class="dt">  R</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_integrand</span>(true_params), </a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="st">`</span><span class="dt">C++</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="dt">min_iterations =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">#&gt; # A tibble: 2 × 6</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="co">#&gt; 1   R          3.13ms   3.71ms      265.  139.17KB     8.54</span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="co">#&gt; 2 C++        252.88µs 260.74µs     3709.    2.49KB     0</span></a></code></pre></div>
<p>There is a big difference. Moreover, there is an overhead with repeatedly going back and forward between R and C++. A fair comparison would use an R implementation for all methods.</p>
</div>
<div id="masking-fixing-parameters" class="section level4">
<h4>Masking (Fixing) Parameters</h4>
<p>It is possible to mask (fix) the parameters both in the R and C++ interface. We illustrate this below.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" title="1"><span class="co"># set the parameters to mask</span></a>
<a class="sourceLine" id="cb21-2" title="2">par_mask &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(psqn_res<span class="op">$</span>par))</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb21-4" title="4">idx_mask &lt;-<span class="st"> </span><span class="kw">sample.int</span>(<span class="kw">length</span>(par_mask), 250L) <span class="co"># random indices we mask</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="co"># add some noise to the parameters</span></a>
<a class="sourceLine" id="cb21-6" title="6">par_mask[idx_mask] &lt;-<span class="st"> </span>par_mask[idx_mask] <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(idx_mask), <span class="dt">sd =</span> <span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="co"># fit the model with the R interface</span></a>
<a class="sourceLine" id="cb21-9" title="9">mask_psqn_res &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="st">  </span><span class="kw">psqn</span>(<span class="dt">par =</span> par_mask, r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb21-11" title="11">       <span class="dt">n_threads =</span> 1L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">pre_method =</span> 1L, </a>
<a class="sourceLine" id="cb21-12" title="12">       <span class="dt">mask =</span> idx_mask <span class="op">-</span><span class="st"> </span>1L) <span class="co"># -1L as it is zero based</span></a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14"><span class="co"># do the same with optim</span></a>
<a class="sourceLine" id="cb21-15" title="15">mask_optim &lt;-<span class="st"> </span><span class="kw">optim</span>(</a>
<a class="sourceLine" id="cb21-16" title="16">    par_mask[<span class="op">-</span>idx_mask], <span class="cf">function</span>(par){ </a>
<a class="sourceLine" id="cb21-17" title="17">      par_mask[<span class="op">-</span>idx_mask] &lt;-<span class="st"> </span>par</a>
<a class="sourceLine" id="cb21-18" title="18">      <span class="kw">eval_mlogit</span>(par_mask, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 1L)</a>
<a class="sourceLine" id="cb21-19" title="19">    }, </a>
<a class="sourceLine" id="cb21-20" title="20">    <span class="cf">function</span>(par){</a>
<a class="sourceLine" id="cb21-21" title="21">      par_mask[<span class="op">-</span>idx_mask] &lt;-<span class="st"> </span>par</a>
<a class="sourceLine" id="cb21-22" title="22">      <span class="kw">grad_mlogit</span>(par_mask, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 1L)[<span class="op">-</span>idx_mask]</a>
<a class="sourceLine" id="cb21-23" title="23">    }, </a>
<a class="sourceLine" id="cb21-24" title="24">    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">reltol =</span> <span class="fl">1e-8</span>))</a>
<a class="sourceLine" id="cb21-25" title="25"></a>
<a class="sourceLine" id="cb21-26" title="26"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb21-27" title="27"><span class="kw">all.equal</span>(mask_psqn_res<span class="op">$</span>par[<span class="op">-</span>idx_mask], mask_optim<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb21-28" title="28"><span class="co">#&gt; [1] &quot;Mean relative difference: 8.72e-05&quot;</span></a>
<a class="sourceLine" id="cb21-29" title="29"></a>
<a class="sourceLine" id="cb21-30" title="30"><span class="co"># the value is lower </span></a>
<a class="sourceLine" id="cb21-31" title="31">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>mask_psqn_res<span class="op">$</span>value <span class="co"># recall minus one times the integrand</span></a>
<a class="sourceLine" id="cb21-32" title="32"><span class="co">#&gt; [1] -65</span></a>
<a class="sourceLine" id="cb21-33" title="33"></a>
<a class="sourceLine" id="cb21-34" title="34"><span class="co"># the fixed parameters are the same</span></a>
<a class="sourceLine" id="cb21-35" title="35"><span class="kw">all.equal</span>(mask_psqn_res<span class="op">$</span>par[idx_mask], par_mask[idx_mask])</a>
<a class="sourceLine" id="cb21-36" title="36"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb21-37" title="37"></a>
<a class="sourceLine" id="cb21-38" title="38"><span class="co"># the C++ interface gives the same</span></a>
<a class="sourceLine" id="cb21-39" title="39"><span class="kw">set_masked</span>(<span class="dt">ptr =</span> optimizer, <span class="dt">indices =</span> idx_mask <span class="op">-</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb21-40" title="40">mask_psqn_res_cpp &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(par_mask)</a>
<a class="sourceLine" id="cb21-41" title="41"><span class="kw">clear_masked</span>(optimizer) <span class="co"># remember to clear again!</span></a>
<a class="sourceLine" id="cb21-42" title="42"></a>
<a class="sourceLine" id="cb21-43" title="43"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb21-44" title="44"><span class="kw">all.equal</span>(mask_psqn_res<span class="op">$</span>par, mask_psqn_res_cpp<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb21-45" title="45"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="non-linear-equality-constraints" class="section level4">
<h4>Non-linear Equality Constraints</h4>
<p>Non-linear equality constraints are supported in both the R and the C++ interface. We added a toy example in C++ code where we constrain some of the parameters to be on a ball. We use the implementation below to make a random set restrictions on some parameters.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1"><span class="co"># find the parameters we will restrict</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-3" title="3">restrict &lt;-<span class="st"> </span><span class="kw">replicate</span>(50L, {</a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="co"># sample number of parameters, indices, and the radius</span></a>
<a class="sourceLine" id="cb22-5" title="5">  n_restrict &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">3</span><span class="op">:</span><span class="dv">7</span>, 1L)</a>
<a class="sourceLine" id="cb22-6" title="6">  indices &lt;-<span class="st"> </span><span class="kw">sample.int</span>(<span class="kw">length</span>(psqn_res<span class="op">$</span>par), n_restrict)</a>
<a class="sourceLine" id="cb22-7" title="7">  radius &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>, <span class="fl">.2</span>, <span class="fl">1.5</span>)</a>
<a class="sourceLine" id="cb22-8" title="8">  <span class="kw">list</span>(<span class="dt">indices =</span> indices, <span class="dt">radius =</span> radius)</a>
<a class="sourceLine" id="cb22-9" title="9">}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb22-10" title="10"></a>
<a class="sourceLine" id="cb22-11" title="11"><span class="co"># apply the restriction</span></a>
<a class="sourceLine" id="cb22-12" title="12">psqn_restrict &lt;-<span class="st"> </span><span class="kw">optim_aug_Lagrang_mlogit</span>(</a>
<a class="sourceLine" id="cb22-13" title="13">  <span class="dt">val =</span> start_val, <span class="dt">pre_method =</span> 1L, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="fl">1e-8</span>, </a>
<a class="sourceLine" id="cb22-14" title="14">  <span class="dt">max_it =</span> 1000L, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">use_bfgs =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb22-15" title="15">  <span class="dt">trace =</span> 0L, <span class="dt">max_it_outer =</span> 100L,</a>
<a class="sourceLine" id="cb22-16" title="16">  <span class="dt">consts =</span> restrict)</a>
<a class="sourceLine" id="cb22-17" title="17"></a>
<a class="sourceLine" id="cb22-18" title="18">psqn_restrict<span class="op">$</span>info</a>
<a class="sourceLine" id="cb22-19" title="19"><span class="co">#&gt; [1] 0</span></a>
<a class="sourceLine" id="cb22-20" title="20">psqn_restrict<span class="op">$</span>value</a>
<a class="sourceLine" id="cb22-21" title="21"><span class="co">#&gt; [1] 5299</span></a>
<a class="sourceLine" id="cb22-22" title="22"></a>
<a class="sourceLine" id="cb22-23" title="23"><span class="co"># the value is higher (worse)</span></a>
<a class="sourceLine" id="cb22-24" title="24">psqn_restrict<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>psqn_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb22-25" title="25"><span class="co">#&gt; [1] 15.8</span></a>
<a class="sourceLine" id="cb22-26" title="26"></a>
<a class="sourceLine" id="cb22-27" title="27"><span class="co"># evaluates the constraints from R (should be zero)</span></a>
<a class="sourceLine" id="cb22-28" title="28">consts &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, what){</a>
<a class="sourceLine" id="cb22-29" title="29">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb22-30" title="30">    <span class="co"># for the R version later</span></a>
<a class="sourceLine" id="cb22-31" title="31">    <span class="kw">return</span>(restrict[[i]]<span class="op">$</span>indices)</a>
<a class="sourceLine" id="cb22-32" title="32">  </a>
<a class="sourceLine" id="cb22-33" title="33">  out &lt;-<span class="st"> </span><span class="kw">sum</span>(par<span class="op">^</span><span class="dv">2</span>) <span class="op">-</span><span class="st"> </span>restrict[[i]]<span class="op">$</span>radius<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb22-34" title="34">  <span class="cf">if</span>(what <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-35" title="35">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>par</a>
<a class="sourceLine" id="cb22-36" title="36">  out</a>
<a class="sourceLine" id="cb22-37" title="37">}</a>
<a class="sourceLine" id="cb22-38" title="38"></a>
<a class="sourceLine" id="cb22-39" title="39"><span class="co"># check the constraints. All ~0</span></a>
<a class="sourceLine" id="cb22-40" title="40"><span class="kw">sapply</span>(<span class="kw">seq_along</span>(restrict), <span class="cf">function</span>(i)</a>
<a class="sourceLine" id="cb22-41" title="41">  <span class="kw">consts</span>(i, psqn_restrict<span class="op">$</span>par[restrict[[i]]<span class="op">$</span>indices], <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb22-42" title="42"><span class="co">#&gt;  [1] -1.84e-07  1.60e-07 -3.18e-10 -1.56e-11 -2.20e-08 -1.95e-10 -3.65e-10</span></a>
<a class="sourceLine" id="cb22-43" title="43"><span class="co">#&gt;  [8] -1.58e-11 -2.08e-11 -3.01e-11 -4.32e-08  1.18e-11 -2.59e-09 -2.80e-10</span></a>
<a class="sourceLine" id="cb22-44" title="44"><span class="co">#&gt; [15]  3.58e-11 -8.83e-10 -7.69e-06 -5.31e-11  4.97e-10 -2.05e-06  6.91e-12</span></a>
<a class="sourceLine" id="cb22-45" title="45"><span class="co">#&gt; [22] -4.32e-10  1.18e-09  5.10e-09  1.30e-11 -1.82e-10 -8.72e-11  4.29e-11</span></a>
<a class="sourceLine" id="cb22-46" title="46"><span class="co">#&gt; [29] -5.77e-12  8.57e-09  2.02e-06 -8.76e-09 -1.46e-06  2.52e-09 -1.47e-11</span></a>
<a class="sourceLine" id="cb22-47" title="47"><span class="co">#&gt; [36]  2.53e-09 -3.94e-06 -4.72e-11 -2.64e-10  3.35e-11  2.80e-11  5.51e-11</span></a>
<a class="sourceLine" id="cb22-48" title="48"><span class="co">#&gt; [43] -8.13e-11 -7.57e-11 -3.10e-08 -1.01e-08  1.04e-07 -3.32e-11  3.24e-09</span></a>
<a class="sourceLine" id="cb22-49" title="49"><span class="co">#&gt; [50] -2.24e-10</span></a>
<a class="sourceLine" id="cb22-50" title="50"></a>
<a class="sourceLine" id="cb22-51" title="51"><span class="co"># we can do the same from R</span></a>
<a class="sourceLine" id="cb22-52" title="52">psqn_restrict_R &lt;-<span class="st"> </span><span class="kw">psqn_aug_Lagrang</span>(</a>
<a class="sourceLine" id="cb22-53" title="53">  <span class="dt">par =</span> start_val, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb22-54" title="54">  <span class="dt">n_threads =</span> 1L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">pre_method =</span> 1L, </a>
<a class="sourceLine" id="cb22-55" title="55">  <span class="dt">consts =</span> consts, <span class="dt">n_constraints =</span> <span class="kw">length</span>(restrict))</a>
<a class="sourceLine" id="cb22-56" title="56"></a>
<a class="sourceLine" id="cb22-57" title="57"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb22-58" title="58"><span class="kw">all.equal</span>(psqn_restrict_R<span class="op">$</span>par, psqn_restrict<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb22-59" title="59"><span class="co">#&gt; [1] &quot;Mean relative difference: 8.51e-05&quot;</span></a>
<a class="sourceLine" id="cb22-60" title="60"></a>
<a class="sourceLine" id="cb22-61" title="61"><span class="co"># check the constraints. All ~0</span></a>
<a class="sourceLine" id="cb22-62" title="62"><span class="kw">sapply</span>(<span class="kw">seq_along</span>(restrict), <span class="cf">function</span>(i)</a>
<a class="sourceLine" id="cb22-63" title="63">  <span class="kw">consts</span>(i, psqn_restrict_R<span class="op">$</span>par[restrict[[i]]<span class="op">$</span>indices], <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb22-64" title="64"><span class="co">#&gt;  [1] -2.44e-09  5.02e-11 -5.71e-14  8.88e-16 -1.54e-12 -8.37e-14  9.95e-14</span></a>
<a class="sourceLine" id="cb22-65" title="65"><span class="co">#&gt;  [8] -3.20e-13  2.00e-13  3.66e-14 -8.07e-13 -1.18e-14  4.28e-13  2.56e-14</span></a>
<a class="sourceLine" id="cb22-66" title="66"><span class="co">#&gt; [15] -1.96e-12 -2.12e-12  1.31e-09  2.29e-12 -7.32e-14 -8.33e-11  4.55e-15</span></a>
<a class="sourceLine" id="cb22-67" title="67"><span class="co">#&gt; [22]  7.11e-14 -1.86e-10  5.78e-12  1.48e-12 -5.34e-14  1.55e-14  1.16e-12</span></a>
<a class="sourceLine" id="cb22-68" title="68"><span class="co">#&gt; [29]  9.77e-15 -2.75e-09 -5.83e-11 -1.51e-12 -5.98e-11 -5.83e-13  6.61e-15</span></a>
<a class="sourceLine" id="cb22-69" title="69"><span class="co">#&gt; [36]  7.35e-09 -1.66e-10 -1.79e-14 -6.77e-15  3.79e-14  1.52e-12 -5.95e-14</span></a>
<a class="sourceLine" id="cb22-70" title="70"><span class="co">#&gt; [43]  2.68e-14 -1.66e-14  1.33e-12  3.97e-09  1.18e-10  1.07e-14  7.29e-12</span></a>
<a class="sourceLine" id="cb22-71" title="71"><span class="co">#&gt; [50]  1.50e-10</span></a></code></pre></div>
</div>
</div>
<div id="polynomial-example" class="section level3">
<h3>Polynomial Example</h3>
<p>We consider the following trivial (regression) example as there is an explicit solution to compare with:</p>
<p><span class="math display">\[
\begin{align*}
\mathcal G &amp;=\{1,\dots, p\} \\
\mathcal G  \cap \mathcal P_i &amp;= \emptyset \\
\mathcal P_j \cap \mathcal P_i &amp;= \emptyset, \qquad i\neq j \\
\mathcal I_i &amp;\in \{1,\dots, p\}^{\lvert\mathcal P_i\rvert} \\
f(\vec x) &amp;= (\vec x_{\mathcal G} - \vec\mu_{\mathcal G})^\top
  (\vec x_{\mathcal G} - \vec\mu_{\mathcal G}) +
  \sum_{i = 1}^n 
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i})^\top
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i}) 
\end{align*}
\]</span> This is not because the problem is interesting per se but it is meant as another illustration. R code to simulate from this model is given below:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" title="1"><span class="co"># simulate the data</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb23-3" title="3">n_global &lt;-<span class="st"> </span>10L</a>
<a class="sourceLine" id="cb23-4" title="4">n_clusters &lt;-<span class="st"> </span>50L</a>
<a class="sourceLine" id="cb23-5" title="5"></a>
<a class="sourceLine" id="cb23-6" title="6">mu_global &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_global)</a>
<a class="sourceLine" id="cb23-7" title="7">idx_start &lt;-<span class="st"> </span>n_global</a>
<a class="sourceLine" id="cb23-8" title="8"></a>
<a class="sourceLine" id="cb23-9" title="9">cluster_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</a>
<a class="sourceLine" id="cb23-10" title="10">  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n_global, 1L)</a>
<a class="sourceLine" id="cb23-11" title="11">  g_idx &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">sample.int</span>(n_global, n_members))</a>
<a class="sourceLine" id="cb23-12" title="12">  mu_cluster &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_members)</a>
<a class="sourceLine" id="cb23-13" title="13">  Psi &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n_members <span class="op">*</span><span class="st"> </span>n_members), n_members, n_members)</a>
<a class="sourceLine" id="cb23-14" title="14">  </a>
<a class="sourceLine" id="cb23-15" title="15">  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">idx =</span> idx_start <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span>n_members, <span class="dt">g_idx =</span> g_idx,</a>
<a class="sourceLine" id="cb23-16" title="16">              <span class="dt">mu_cluster =</span> mu_cluster, <span class="dt">Psi =</span> Psi)</a>
<a class="sourceLine" id="cb23-17" title="17">  idx_start &lt;&lt;-<span class="st"> </span>idx_start <span class="op">+</span><span class="st"> </span>n_members</a>
<a class="sourceLine" id="cb23-18" title="18">  out</a>
<a class="sourceLine" id="cb23-19" title="19">}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb23-20" title="20"></a>
<a class="sourceLine" id="cb23-21" title="21"><span class="co"># assign matrices needed for comparisons</span></a>
<a class="sourceLine" id="cb23-22" title="22"><span class="kw">library</span>(Matrix)</a>
<a class="sourceLine" id="cb23-23" title="23">M &lt;-<span class="st"> </span><span class="kw">diag</span>(idx_start)</a>
<a class="sourceLine" id="cb23-24" title="24"><span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat)</a>
<a class="sourceLine" id="cb23-25" title="25">  M[cl<span class="op">$</span>idx, cl<span class="op">$</span>g_idx] &lt;-<span class="st"> </span><span class="op">-</span>cl<span class="op">$</span>Psi</a>
<a class="sourceLine" id="cb23-26" title="26">M &lt;-<span class="st"> </span><span class="kw">as</span>(M, <span class="st">&quot;dgCMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb23-27" title="27"></a>
<a class="sourceLine" id="cb23-28" title="28"><span class="co"># Assign two R functions to evaluate the objective function. There are two </span></a>
<a class="sourceLine" id="cb23-29" title="29"><span class="co"># versions of the function to show that we get the same with one being </span></a>
<a class="sourceLine" id="cb23-30" title="30"><span class="co"># closer to the shown equation</span></a>
<a class="sourceLine" id="cb23-31" title="31">fn_one &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb23-32" title="32">  delta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>n_global] <span class="op">-</span><span class="st"> </span>mu_global</a>
<a class="sourceLine" id="cb23-33" title="33">  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb23-34" title="34">  <span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat){</a>
<a class="sourceLine" id="cb23-35" title="35">    delta &lt;-<span class="st"> </span><span class="kw">drop</span>(par[cl<span class="op">$</span>idx] <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>mu_cluster <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>Psi <span class="op">%*%</span><span class="st"> </span>par[cl<span class="op">$</span>g_idx])</a>
<a class="sourceLine" id="cb23-36" title="36">    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb23-37" title="37">  }</a>
<a class="sourceLine" id="cb23-38" title="38">  out</a>
<a class="sourceLine" id="cb23-39" title="39">}</a>
<a class="sourceLine" id="cb23-40" title="40">fn_two &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb23-41" title="41">  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb23-42" title="42">  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)</a>
<a class="sourceLine" id="cb23-43" title="43">  <span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb23-44" title="44">}</a>
<a class="sourceLine" id="cb23-45" title="45"></a>
<a class="sourceLine" id="cb23-46" title="46">tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</a>
<a class="sourceLine" id="cb23-47" title="47"><span class="kw">all.equal</span>(<span class="kw">fn_one</span>(tmp), <span class="kw">fn_two</span>(tmp)) <span class="co"># we get the same w/ the two</span></a>
<a class="sourceLine" id="cb23-48" title="48"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb23-49" title="49">fn &lt;-<span class="st"> </span>fn_two</a>
<a class="sourceLine" id="cb23-50" title="50"><span class="kw">rm</span>(fn_one, fn_two, tmp)</a>
<a class="sourceLine" id="cb23-51" title="51"></a>
<a class="sourceLine" id="cb23-52" title="52"><span class="co"># assign gradient function</span></a>
<a class="sourceLine" id="cb23-53" title="53">gr &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb23-54" title="54">  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb23-55" title="55">  <span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(M, <span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)))</a>
<a class="sourceLine" id="cb23-56" title="56">}</a>
<a class="sourceLine" id="cb23-57" title="57"></a>
<a class="sourceLine" id="cb23-58" title="58"><span class="co"># we can easily find the explicit solution</span></a>
<a class="sourceLine" id="cb23-59" title="59">mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb23-60" title="60">exp_res &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">solve</span>(M, mu))</a>
<a class="sourceLine" id="cb23-61" title="61"><span class="kw">fn</span>(exp_res) <span class="co"># ~ zero as it should be</span></a>
<a class="sourceLine" id="cb23-62" title="62"><span class="co">#&gt; [1] 2.98e-29</span></a></code></pre></div>
<p>C++ code to work with this function is provided at <code>system.file(&quot;poly-ex.cpp&quot;, package = &quot;psqn&quot;)</code> with the package and given below:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="co">// see `mlogit-ex.cpp` for an example with more comments</span></a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">// we will use OpenMP to perform the computation in parallel</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="co">// we use RcppArmadillo to simplify the code</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="co">// [[Rcpp::depends(psqn)]]</span></a>
<a class="sourceLine" id="cb24-11" title="11"><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></a>
<a class="sourceLine" id="cb24-12" title="12"><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14"><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</a>
<a class="sourceLine" id="cb24-15" title="15"><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></a>
<a class="sourceLine" id="cb24-16" title="16"></a>
<a class="sourceLine" id="cb24-17" title="17"><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></a>
<a class="sourceLine" id="cb24-18" title="18"><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, psqn_uint <span class="at">const</span> n_ele){</a>
<a class="sourceLine" id="cb24-19" title="19">  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb24-20" title="20">}</a>
<a class="sourceLine" id="cb24-21" title="21"></a>
<a class="sourceLine" id="cb24-22" title="22"><span class="kw">class</span> poly_func <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</a>
<a class="sourceLine" id="cb24-23" title="23">  <span class="co">/// global parameter indices</span></a>
<a class="sourceLine" id="cb24-24" title="24">  arma::uvec <span class="at">const</span> <span class="va">g_idx</span>;</a>
<a class="sourceLine" id="cb24-25" title="25">  <span class="co">/// centroid vector</span></a>
<a class="sourceLine" id="cb24-26" title="26">  arma::vec <span class="at">const</span> mu_cluster;</a>
<a class="sourceLine" id="cb24-27" title="27">  <span class="co">/// matrix used to transform subset of global parameters</span></a>
<a class="sourceLine" id="cb24-28" title="28">  arma::mat <span class="at">const</span> Psi;</a>
<a class="sourceLine" id="cb24-29" title="29">  <span class="co">/// number of global parameters</span></a>
<a class="sourceLine" id="cb24-30" title="30">  psqn_uint <span class="at">const</span> n_global;</a>
<a class="sourceLine" id="cb24-31" title="31">  <span class="co">/// global parameter centroid vector</span></a>
<a class="sourceLine" id="cb24-32" title="32">  arma::vec <span class="at">const</span> mu_global;</a>
<a class="sourceLine" id="cb24-33" title="33">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb24-34" title="34"><span class="co">   true if this element function should compute the terms from the global</span></a>
<a class="sourceLine" id="cb24-35" title="35"><span class="co">   paramaters */</span></a>
<a class="sourceLine" id="cb24-36" title="36">  <span class="dt">bool</span> <span class="at">const</span> comp_global;</a>
<a class="sourceLine" id="cb24-37" title="37"></a>
<a class="sourceLine" id="cb24-38" title="38"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb24-39" title="39">  poly_func(List data, arma::vec <span class="at">const</span> &amp;mu_g, <span class="dt">bool</span> <span class="at">const</span> comp_global):</a>
<a class="sourceLine" id="cb24-40" title="40">  <span class="va">g_idx</span>     (as&lt;arma::uvec&gt;(data[<span class="st">&quot;g_idx&quot;</span>    ]) - <span class="dv">1</span><span class="bu">L</span>),</a>
<a class="sourceLine" id="cb24-41" title="41">  mu_cluster(as&lt;arma::vec&gt;(data[<span class="st">&quot;mu_cluster&quot;</span>])     ),</a>
<a class="sourceLine" id="cb24-42" title="42">  Psi       (as&lt;arma::mat&gt;(data[<span class="st">&quot;Psi&quot;</span>       ])     ),</a>
<a class="sourceLine" id="cb24-43" title="43">  n_global(mu_g.n_elem),</a>
<a class="sourceLine" id="cb24-44" title="44">  mu_global(comp_global ? mu_g : arma::vec() ),</a>
<a class="sourceLine" id="cb24-45" title="45">  comp_global(comp_global)</a>
<a class="sourceLine" id="cb24-46" title="46">  { }</a>
<a class="sourceLine" id="cb24-47" title="47"></a>
<a class="sourceLine" id="cb24-48" title="48">  psqn_uint global_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb24-49" title="49">    <span class="cf">return</span> n_global;</a>
<a class="sourceLine" id="cb24-50" title="50">  }</a>
<a class="sourceLine" id="cb24-51" title="51">  psqn_uint private_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb24-52" title="52">    <span class="cf">return</span> mu_cluster.n_elem;</a>
<a class="sourceLine" id="cb24-53" title="53">  }</a>
<a class="sourceLine" id="cb24-54" title="54"></a>
<a class="sourceLine" id="cb24-55" title="55">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb24-56" title="56">    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</a>
<a class="sourceLine" id="cb24-57" title="57">                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</a>
<a class="sourceLine" id="cb24-58" title="58">                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</a>
<a class="sourceLine" id="cb24-59" title="59"></a>
<a class="sourceLine" id="cb24-60" title="60">    <span class="co">// compute the function</span></a>
<a class="sourceLine" id="cb24-61" title="61">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb24-62" title="62">    out += arma::dot(delta, delta);</a>
<a class="sourceLine" id="cb24-63" title="63"></a>
<a class="sourceLine" id="cb24-64" title="64">    <span class="cf">if</span>(comp_global)</a>
<a class="sourceLine" id="cb24-65" title="65">      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</a>
<a class="sourceLine" id="cb24-66" title="66"></a>
<a class="sourceLine" id="cb24-67" title="67">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb24-68" title="68">  }</a>
<a class="sourceLine" id="cb24-69" title="69"></a>
<a class="sourceLine" id="cb24-70" title="70">  <span class="dt">double</span> grad</a>
<a class="sourceLine" id="cb24-71" title="71">  (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb24-72" title="72">    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</a>
<a class="sourceLine" id="cb24-73" title="73">                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</a>
<a class="sourceLine" id="cb24-74" title="74">                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</a>
<a class="sourceLine" id="cb24-75" title="75"></a>
<a class="sourceLine" id="cb24-76" title="76">    <span class="co">// create objects to write to for the gradient</span></a>
<a class="sourceLine" id="cb24-77" title="77">    <span class="bu">std::</span>fill(gr, gr + x_glob.n_elem, <span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb24-78" title="78">    arma::vec d_glob(gr                , x_glob.n_elem, <span class="kw">false</span>),</a>
<a class="sourceLine" id="cb24-79" title="79">              d_priv(gr + x_glob.n_elem, x_priv.n_elem, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb24-80" title="80"></a>
<a class="sourceLine" id="cb24-81" title="81">    <span class="co">// compute the function and the gradient</span></a>
<a class="sourceLine" id="cb24-82" title="82">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb24-83" title="83">    out += arma::dot(delta, delta);</a>
<a class="sourceLine" id="cb24-84" title="84">    d_glob(<span class="va">g_idx</span>) -= <span class="dv">2</span> * Psi.t() * delta;</a>
<a class="sourceLine" id="cb24-85" title="85">    d_priv         = <span class="dv">2</span> * delta;</a>
<a class="sourceLine" id="cb24-86" title="86"></a>
<a class="sourceLine" id="cb24-87" title="87">    <span class="cf">if</span>(comp_global){</a>
<a class="sourceLine" id="cb24-88" title="88">      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</a>
<a class="sourceLine" id="cb24-89" title="89">      d_glob += <span class="fl">2.</span> * x_glob;</a>
<a class="sourceLine" id="cb24-90" title="90">      d_glob -= <span class="dv">2</span> * mu_global;</a>
<a class="sourceLine" id="cb24-91" title="91">    }</a>
<a class="sourceLine" id="cb24-92" title="92"></a>
<a class="sourceLine" id="cb24-93" title="93">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb24-94" title="94">  }</a>
<a class="sourceLine" id="cb24-95" title="95"></a>
<a class="sourceLine" id="cb24-96" title="96">  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb24-97" title="97">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb24-98" title="98">  }</a>
<a class="sourceLine" id="cb24-99" title="99">};</a>
<a class="sourceLine" id="cb24-100" title="100"></a>
<a class="sourceLine" id="cb24-101" title="101"><span class="kw">using</span> poly_optim = PSQN::optimizer&lt;poly_func, PSQN::R_reporter,</a>
<a class="sourceLine" id="cb24-102" title="102">                                   PSQN::R_interrupter&gt;;</a>
<a class="sourceLine" id="cb24-103" title="103"></a>
<a class="sourceLine" id="cb24-104" title="104"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb24-105" title="105">SEXP get_poly_optimizer(List data, arma::vec <span class="at">const</span> &amp;mu_global,</a>
<a class="sourceLine" id="cb24-106" title="106">                        <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</a>
<a class="sourceLine" id="cb24-107" title="107">  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</a>
<a class="sourceLine" id="cb24-108" title="108">  <span class="bu">std::</span>vector&lt;poly_func&gt; funcs;</a>
<a class="sourceLine" id="cb24-109" title="109">  funcs.reserve(n_elem_funcs);</a>
<a class="sourceLine" id="cb24-110" title="110">  <span class="dt">bool</span> comp_global(<span class="kw">true</span>);</a>
<a class="sourceLine" id="cb24-111" title="111">  <span class="cf">for</span>(<span class="kw">auto</span> dat : data){</a>
<a class="sourceLine" id="cb24-112" title="112">    funcs.emplace_back(List(dat), mu_global, comp_global);</a>
<a class="sourceLine" id="cb24-113" title="113">    comp_global = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb24-114" title="114">  }</a>
<a class="sourceLine" id="cb24-115" title="115"></a>
<a class="sourceLine" id="cb24-116" title="116">  <span class="co">// create an XPtr to the object we will need</span></a>
<a class="sourceLine" id="cb24-117" title="117">  XPtr&lt;poly_optim&gt;ptr(<span class="kw">new</span> poly_optim(funcs, max_threads));</a>
<a class="sourceLine" id="cb24-118" title="118"></a>
<a class="sourceLine" id="cb24-119" title="119">  <span class="co">// return the pointer to be used later</span></a>
<a class="sourceLine" id="cb24-120" title="120">  <span class="cf">return</span> ptr;</a>
<a class="sourceLine" id="cb24-121" title="121">}</a>
<a class="sourceLine" id="cb24-122" title="122"></a>
<a class="sourceLine" id="cb24-123" title="123"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb24-124" title="124">List opti<span class="va">m_poly</span></a>
<a class="sourceLine" id="cb24-125" title="125">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb24-126" title="126">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb24-127" title="127">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</a>
<a class="sourceLine" id="cb24-128" title="128">   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb24-129" title="129">   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</a>
<a class="sourceLine" id="cb24-130" title="130">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb24-131" title="131"></a>
<a class="sourceLine" id="cb24-132" title="132">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb24-133" title="133">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb24-134" title="134">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb24-135" title="135"></a>
<a class="sourceLine" id="cb24-136" title="136">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb24-137" title="137">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb24-138" title="138">  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</a>
<a class="sourceLine" id="cb24-139" title="139">                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb24-140" title="140">                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb24-141" title="141">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb24-142" title="142">    res.n_eval, res.n_grad,  res.n_cg);</a>
<a class="sourceLine" id="cb24-143" title="143">  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</a>
<a class="sourceLine" id="cb24-144" title="144"></a>
<a class="sourceLine" id="cb24-145" title="145">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb24-146" title="146">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb24-147" title="147">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</a>
<a class="sourceLine" id="cb24-148" title="148">      _[<span class="st">&quot;counts&quot;</span>] = counts,</a>
<a class="sourceLine" id="cb24-149" title="149">      _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged);</a>
<a class="sourceLine" id="cb24-150" title="150">}</a>
<a class="sourceLine" id="cb24-151" title="151"></a>
<a class="sourceLine" id="cb24-152" title="152"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb24-153" title="153"><span class="dt">double</span> eval_poly(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb24-154" title="154">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb24-155" title="155"></a>
<a class="sourceLine" id="cb24-156" title="156">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb24-157" title="157">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb24-158" title="158">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb24-159" title="159"></a>
<a class="sourceLine" id="cb24-160" title="160">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb24-161" title="161">  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb24-162" title="162">}</a>
<a class="sourceLine" id="cb24-163" title="163"></a>
<a class="sourceLine" id="cb24-164" title="164"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb24-165" title="165">NumericVector grad_poly(NumericVector val, SEXP ptr,</a>
<a class="sourceLine" id="cb24-166" title="166">                        <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb24-167" title="167">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb24-168" title="168"></a>
<a class="sourceLine" id="cb24-169" title="169">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb24-170" title="170">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb24-171" title="171">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb24-172" title="172"></a>
<a class="sourceLine" id="cb24-173" title="173">  NumericVector grad(val.size());</a>
<a class="sourceLine" id="cb24-174" title="174">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb24-175" title="175">  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</a>
<a class="sourceLine" id="cb24-176" title="176"></a>
<a class="sourceLine" id="cb24-177" title="177">  <span class="cf">return</span> grad;</a>
<a class="sourceLine" id="cb24-178" title="178">}</a></code></pre></div>
<p>We can <code>Rcpp::sourceCpp</code> the file and use the code like below to find the solution:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">library</span>(Rcpp)</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;poly-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co"># get a pointer to C++ object</span></a>
<a class="sourceLine" id="cb25-5" title="5">optimizer &lt;-<span class="st"> </span><span class="kw">get_poly_optimizer</span>(cluster_dat, <span class="dt">mu_global =</span> mu_global, </a>
<a class="sourceLine" id="cb25-6" title="6">                                <span class="dt">max_threads =</span> 2L)</a>
<a class="sourceLine" id="cb25-7" title="7"></a>
<a class="sourceLine" id="cb25-8" title="8"><span class="co"># we get the same function value and gradient</span></a>
<a class="sourceLine" id="cb25-9" title="9">tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</a>
<a class="sourceLine" id="cb25-10" title="10"><span class="kw">all.equal</span>(<span class="kw">fn</span>       (tmp), </a>
<a class="sourceLine" id="cb25-11" title="11">          <span class="kw">eval_poly</span>(tmp, optimizer, 1L))</a>
<a class="sourceLine" id="cb25-12" title="12"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb25-13" title="13"><span class="kw">all.equal</span>(<span class="kw">gr</span>       (tmp), </a>
<a class="sourceLine" id="cb25-14" title="14">          <span class="kw">grad_poly</span>(tmp, optimizer, 1L), </a>
<a class="sourceLine" id="cb25-15" title="15">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb25-16" title="16"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb25-17" title="17"></a>
<a class="sourceLine" id="cb25-18" title="18"><span class="co"># run the optimization</span></a>
<a class="sourceLine" id="cb25-19" title="19">psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb25-20" title="20">                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L)</a>
<a class="sourceLine" id="cb25-21" title="21">  <span class="kw">optim_poly</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="fl">1e-8</span>, <span class="dt">max_it =</span> 1000L, </a>
<a class="sourceLine" id="cb25-22" title="22">             <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </a>
<a class="sourceLine" id="cb25-23" title="23">             <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace)</a>
<a class="sourceLine" id="cb25-24" title="24"></a>
<a class="sourceLine" id="cb25-25" title="25">psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(<span class="kw">numeric</span>(idx_start))</a>
<a class="sourceLine" id="cb25-26" title="26"><span class="kw">all.equal</span>(exp_res, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb25-27" title="27"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>A version using the R function <code>psqn</code> is:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1"><span class="co"># assign function to pass to psqn</span></a>
<a class="sourceLine" id="cb26-2" title="2">r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</a>
<a class="sourceLine" id="cb26-3" title="3">  dat &lt;-<span class="st"> </span>cluster_dat[[i]]</a>
<a class="sourceLine" id="cb26-4" title="4">  g_idx &lt;-<span class="st"> </span>dat<span class="op">$</span>g_idx</a>
<a class="sourceLine" id="cb26-5" title="5">  mu_cluster &lt;-<span class="st"> </span>dat<span class="op">$</span>mu_cluster</a>
<a class="sourceLine" id="cb26-6" title="6">  Psi &lt;-<span class="st"> </span>dat<span class="op">$</span>Psi</a>
<a class="sourceLine" id="cb26-7" title="7">  </a>
<a class="sourceLine" id="cb26-8" title="8">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="co"># requested the dimension of the parameter</span></a>
<a class="sourceLine" id="cb26-10" title="10">    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">length</span>(mu_global), </a>
<a class="sourceLine" id="cb26-11" title="11">             <span class="dt">private_dim =</span> <span class="kw">length</span>(mu_cluster)))</a>
<a class="sourceLine" id="cb26-12" title="12">  </a>
<a class="sourceLine" id="cb26-13" title="13">  is_glob &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(mu_global)</a>
<a class="sourceLine" id="cb26-14" title="14">  x_glob &lt;-<span class="st"> </span>par[is_glob]</a>
<a class="sourceLine" id="cb26-15" title="15">  x_priv &lt;-<span class="st"> </span>par[<span class="op">-</span>is_glob]</a>
<a class="sourceLine" id="cb26-16" title="16">  </a>
<a class="sourceLine" id="cb26-17" title="17">  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(x_priv <span class="op">-</span><span class="st"> </span>Psi <span class="op">%*%</span><span class="st"> </span>x_glob[g_idx] <span class="op">-</span><span class="st"> </span>mu_cluster)</a>
<a class="sourceLine" id="cb26-18" title="18">  </a>
<a class="sourceLine" id="cb26-19" title="19">  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb26-20" title="20">  <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L){</a>
<a class="sourceLine" id="cb26-21" title="21">    delta_glob &lt;-<span class="st"> </span>x_glob <span class="op">-</span><span class="st"> </span>mu_global</a>
<a class="sourceLine" id="cb26-22" title="22">    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta_glob <span class="op">%*%</span><span class="st"> </span>delta_glob)</a>
<a class="sourceLine" id="cb26-23" title="23">  }</a>
<a class="sourceLine" id="cb26-24" title="24">  </a>
<a class="sourceLine" id="cb26-25" title="25">  <span class="cf">if</span>(comp_grad){</a>
<a class="sourceLine" id="cb26-26" title="26">    grad &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(mu_cluster) <span class="op">+</span><span class="st"> </span><span class="kw">length</span>(mu_global))</a>
<a class="sourceLine" id="cb26-27" title="27">    grad[g_idx] &lt;-<span class="st"> </span><span class="dv">-2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(Psi, delta))</a>
<a class="sourceLine" id="cb26-28" title="28">    grad[<span class="op">-</span>is_glob] &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta</a>
<a class="sourceLine" id="cb26-29" title="29">    <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb26-30" title="30">      grad[is_glob] &lt;-<span class="st"> </span>grad[is_glob] <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta_glob</a>
<a class="sourceLine" id="cb26-31" title="31">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</a>
<a class="sourceLine" id="cb26-32" title="32">  }</a>
<a class="sourceLine" id="cb26-33" title="33">  </a>
<a class="sourceLine" id="cb26-34" title="34">  out</a>
<a class="sourceLine" id="cb26-35" title="35">}</a>
<a class="sourceLine" id="cb26-36" title="36"></a>
<a class="sourceLine" id="cb26-37" title="37"><span class="co"># use the function</span></a>
<a class="sourceLine" id="cb26-38" title="38">r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">cg_tol =</span> <span class="fl">.5</span>,</a>
<a class="sourceLine" id="cb26-39" title="39">                        <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L, <span class="dt">pre_method =</span> 1L)</a>
<a class="sourceLine" id="cb26-40" title="40">  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb26-41" title="41">       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">cg_tol =</span> cg_tol,</a>
<a class="sourceLine" id="cb26-42" title="42">       <span class="dt">trace =</span> trace, <span class="dt">max_it =</span> 1000L, <span class="dt">pre_method =</span> pre_method)</a>
<a class="sourceLine" id="cb26-43" title="43"></a>
<a class="sourceLine" id="cb26-44" title="44">R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(<span class="kw">numeric</span>(idx_start))</a>
<a class="sourceLine" id="cb26-45" title="45"><span class="kw">all.equal</span>(exp_res, R_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb26-46" title="46"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="generic-example" class="section level3">
<h3>Generic Example</h3>
<p>We will provide a toy example of a problem which is partially separable but which does not have the same structure as the problems we have shown before. The problem we consider is:</p>
<p><span class="math display">\[
\begin{align*}
f(\vec x) &amp;= \sum_{i = 1}^n
  -y_i \sum_{j = 1}^{L_i} x_{k_{ij}}
  +\exp\left(\sum_{j = 1}^{L_i} x_{k_{ij}}\right)
  , \qquad \vec x\in\mathbb R^K \\
\mathcal K_i &amp;= \{k_{i1} , \dots, k_{iL_i}\} \subseteq \{1, \dots, K\}.
\end{align*}
\]</span> This is a special kind of a GLM with a Poison model with the log link. While there are other ways to estimate this model, we will mainly compare the BFGS implementation from <code>optim</code> with the psqn package. For some <span class="math inline">\(j\neq i\)</span>, we will have that <span class="math inline">\(\mathcal K_i \cap \mathcal K_j \neq \emptyset\)</span> without much structure in their intersection unlike before.</p>
<p>There is a class called <code>optimizer_generic</code> provided by the psqn package which can work with more general partially separable problems like the one above. This though yields some additional computational overhead. A C++ implementation to work with the function stated above using the <code>optimizer_generic</code> class is in the <code>generic_example.cpp</code> file which is shown below:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="co">// see `mlogit-ex.cpp` for an example with more comments</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">// we will use OpenMP to perform the computation in parallel</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></a>
<a class="sourceLine" id="cb27-5" title="5"></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="co">// we change the unsigned integer type that is used by the package by defining</span></a>
<a class="sourceLine" id="cb27-7" title="7"><span class="co">// the PSQN_SIZE_T macro variable</span></a>
<a class="sourceLine" id="cb27-8" title="8"><span class="pp">#define PSQN_SIZE_T </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">int</span></a>
<a class="sourceLine" id="cb27-9" title="9"></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="co">// we want to use the incomplete Cholesky factorization as the preconditioner</span></a>
<a class="sourceLine" id="cb27-11" title="11"><span class="co">// and therefore with need RcppEigen</span></a>
<a class="sourceLine" id="cb27-12" title="12"><span class="pp">#define P</span>SQN_USE_EIGEN</a>
<a class="sourceLine" id="cb27-13" title="13"><span class="co">// [[Rcpp::depends(RcppEigen)]]</span></a>
<a class="sourceLine" id="cb27-14" title="14"></a>
<a class="sourceLine" id="cb27-15" title="15"><span class="co">// [[Rcpp::depends(psqn)]]</span></a>
<a class="sourceLine" id="cb27-16" title="16"><span class="pp">#include </span><span class="im">&quot;psqn-Rcpp-wrapper.h&quot;</span></a>
<a class="sourceLine" id="cb27-17" title="17"><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></a>
<a class="sourceLine" id="cb27-18" title="18"><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></a>
<a class="sourceLine" id="cb27-19" title="19"><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</a>
<a class="sourceLine" id="cb27-20" title="20"><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></a>
<a class="sourceLine" id="cb27-21" title="21"></a>
<a class="sourceLine" id="cb27-22" title="22"><span class="kw">class</span> generic_example <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function_generic {</a>
<a class="sourceLine" id="cb27-23" title="23">  <span class="co">/// number of argument to this element function;</span></a>
<a class="sourceLine" id="cb27-24" title="24">  psqn_uint <span class="at">const</span> n_args_val;</a>
<a class="sourceLine" id="cb27-25" title="25">  <span class="co">/// indices of the element function parameters</span></a>
<a class="sourceLine" id="cb27-26" title="26">  <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; indices_array;</a>
<a class="sourceLine" id="cb27-27" title="27">  <span class="co">/// y point</span></a>
<a class="sourceLine" id="cb27-28" title="28">  <span class="dt">double</span> <span class="at">const</span> y;</a>
<a class="sourceLine" id="cb27-29" title="29"></a>
<a class="sourceLine" id="cb27-30" title="30"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb27-31" title="31">  generic_example(List data):</a>
<a class="sourceLine" id="cb27-32" title="32">  n_args_val(as&lt;IntegerVector&gt;(data[<span class="st">&quot;indices&quot;</span>]).size()),</a>
<a class="sourceLine" id="cb27-33" title="33">  indices_array(([&amp;]() -&gt; <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; {</a>
<a class="sourceLine" id="cb27-34" title="34">    IntegerVector indices = as&lt;IntegerVector&gt;(data[<span class="st">&quot;indices&quot;</span>]);</a>
<a class="sourceLine" id="cb27-35" title="35">    <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; out(<span class="kw">new</span> psqn_uint[n_args_val]);</a>
<a class="sourceLine" id="cb27-36" title="36">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</a>
<a class="sourceLine" id="cb27-37" title="37">      out[i] = indices[i];</a>
<a class="sourceLine" id="cb27-38" title="38">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb27-39" title="39">  })()),</a>
<a class="sourceLine" id="cb27-40" title="40">  y(as&lt;<span class="dt">double</span>&gt;(data[<span class="st">&quot;y&quot;</span>]))</a>
<a class="sourceLine" id="cb27-41" title="41">  { }</a>
<a class="sourceLine" id="cb27-42" title="42"></a>
<a class="sourceLine" id="cb27-43" title="43">  <span class="co">// we need to make a copy constructor because of the unique_ptr</span></a>
<a class="sourceLine" id="cb27-44" title="44">  generic_example(generic_example <span class="at">const</span> &amp;other):</a>
<a class="sourceLine" id="cb27-45" title="45">  n_args_val(other.n_args_val),</a>
<a class="sourceLine" id="cb27-46" title="46">  indices_array(([&amp;]() -&gt; <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; {</a>
<a class="sourceLine" id="cb27-47" title="47">    <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; out(<span class="kw">new</span> psqn_uint[n_args_val]);</a>
<a class="sourceLine" id="cb27-48" title="48">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</a>
<a class="sourceLine" id="cb27-49" title="49">      out[i] = other.indices_array[i];</a>
<a class="sourceLine" id="cb27-50" title="50">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb27-51" title="51">  })()),</a>
<a class="sourceLine" id="cb27-52" title="52">  y(other.y) { }</a>
<a class="sourceLine" id="cb27-53" title="53"></a>
<a class="sourceLine" id="cb27-54" title="54">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb27-55" title="55"><span class="co">   returns the number of parameters that this element function is depending on.</span></a>
<a class="sourceLine" id="cb27-56" title="56"><span class="co">   */</span></a>
<a class="sourceLine" id="cb27-57" title="57">  psqn_uint n_args() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb27-58" title="58">    <span class="cf">return</span> n_args_val;</a>
<a class="sourceLine" id="cb27-59" title="59">  }</a>
<a class="sourceLine" id="cb27-60" title="60"></a>
<a class="sourceLine" id="cb27-61" title="61">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb27-62" title="62"><span class="co">   zero-based indices to the parameters that this element function is depending</span></a>
<a class="sourceLine" id="cb27-63" title="63"><span class="co">   on.</span></a>
<a class="sourceLine" id="cb27-64" title="64"><span class="co">   */</span></a>
<a class="sourceLine" id="cb27-65" title="65">  psqn_uint <span class="at">const</span> * indices() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb27-66" title="66">    <span class="cf">return</span> indices_array.get();</a>
<a class="sourceLine" id="cb27-67" title="67">  }</a>
<a class="sourceLine" id="cb27-68" title="68"></a>
<a class="sourceLine" id="cb27-69" title="69">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> * point) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb27-70" title="70">    <span class="dt">double</span> sum(<span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb27-71" title="71">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</a>
<a class="sourceLine" id="cb27-72" title="72">      sum += point[i];</a>
<a class="sourceLine" id="cb27-73" title="73">    <span class="cf">return</span> -y * sum + <span class="bu">std::</span>exp(sum);</a>
<a class="sourceLine" id="cb27-74" title="74">  }</a>
<a class="sourceLine" id="cb27-75" title="75"></a>
<a class="sourceLine" id="cb27-76" title="76">  <span class="dt">double</span> grad</a>
<a class="sourceLine" id="cb27-77" title="77">  (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb27-78" title="78">    <span class="dt">double</span> sum(<span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb27-79" title="79">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</a>
<a class="sourceLine" id="cb27-80" title="80">      sum += point[i];</a>
<a class="sourceLine" id="cb27-81" title="81">    <span class="dt">double</span> <span class="at">const</span> exp_sum = <span class="bu">std::</span>exp(sum),</a>
<a class="sourceLine" id="cb27-82" title="82">                    fact = -y + exp_sum;</a>
<a class="sourceLine" id="cb27-83" title="83">    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</a>
<a class="sourceLine" id="cb27-84" title="84">      gr[i] = fact;</a>
<a class="sourceLine" id="cb27-85" title="85"></a>
<a class="sourceLine" id="cb27-86" title="86">    <span class="cf">return</span> -y * sum + <span class="bu">std::</span>exp(sum);</a>
<a class="sourceLine" id="cb27-87" title="87">  }</a>
<a class="sourceLine" id="cb27-88" title="88"></a>
<a class="sourceLine" id="cb27-89" title="89">  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb27-90" title="90">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb27-91" title="91">  }</a>
<a class="sourceLine" id="cb27-92" title="92">};</a>
<a class="sourceLine" id="cb27-93" title="93"></a>
<a class="sourceLine" id="cb27-94" title="94"><span class="kw">using</span> generic_opt =</a>
<a class="sourceLine" id="cb27-95" title="95">  PSQN::optimizer_generic&lt;generic_example, PSQN::R_reporter,</a>
<a class="sourceLine" id="cb27-96" title="96">                          PSQN::R_interrupter&gt;;</a>
<a class="sourceLine" id="cb27-97" title="97"></a>
<a class="sourceLine" id="cb27-98" title="98"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-99" title="99">SEXP get_generic_ex_obj(List data, <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</a>
<a class="sourceLine" id="cb27-100" title="100">  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</a>
<a class="sourceLine" id="cb27-101" title="101">  <span class="bu">std::</span>vector&lt;generic_example&gt; funcs;</a>
<a class="sourceLine" id="cb27-102" title="102">  funcs.reserve(n_elem_funcs);</a>
<a class="sourceLine" id="cb27-103" title="103">  <span class="cf">for</span>(<span class="kw">auto</span> dat : data)</a>
<a class="sourceLine" id="cb27-104" title="104">    funcs.emplace_back(List(dat));</a>
<a class="sourceLine" id="cb27-105" title="105"></a>
<a class="sourceLine" id="cb27-106" title="106">  <span class="co">// create an XPtr to the object we will need</span></a>
<a class="sourceLine" id="cb27-107" title="107">  XPtr&lt;generic_opt&gt;ptr(<span class="kw">new</span> generic_opt(funcs, max_threads));</a>
<a class="sourceLine" id="cb27-108" title="108"></a>
<a class="sourceLine" id="cb27-109" title="109">  <span class="co">// return the pointer to be used later</span></a>
<a class="sourceLine" id="cb27-110" title="110">  <span class="cf">return</span> ptr;</a>
<a class="sourceLine" id="cb27-111" title="111">}</a>
<a class="sourceLine" id="cb27-112" title="112"></a>
<a class="sourceLine" id="cb27-113" title="113"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-114" title="114">List opti<span class="va">m_generic_ex</span></a>
<a class="sourceLine" id="cb27-115" title="115">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb27-116" title="116">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb27-117" title="117">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</a>
<a class="sourceLine" id="cb27-118" title="118">   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb27-119" title="119">   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</a>
<a class="sourceLine" id="cb27-120" title="120">  XPtr&lt;generic_opt&gt; optim(ptr);</a>
<a class="sourceLine" id="cb27-121" title="121"></a>
<a class="sourceLine" id="cb27-122" title="122">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb27-123" title="123">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb27-124" title="124">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_generic_ex: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb27-125" title="125"></a>
<a class="sourceLine" id="cb27-126" title="126">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb27-127" title="127">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb27-128" title="128">  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</a>
<a class="sourceLine" id="cb27-129" title="129">                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb27-130" title="130">                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb27-131" title="131">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb27-132" title="132">    res.n_eval, res.n_grad,  res.n_cg);</a>
<a class="sourceLine" id="cb27-133" title="133">  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</a>
<a class="sourceLine" id="cb27-134" title="134"></a>
<a class="sourceLine" id="cb27-135" title="135">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb27-136" title="136">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb27-137" title="137">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</a>
<a class="sourceLine" id="cb27-138" title="138">      _[<span class="st">&quot;counts&quot;</span>] = counts,</a>
<a class="sourceLine" id="cb27-139" title="139">      _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged);</a>
<a class="sourceLine" id="cb27-140" title="140">}</a>
<a class="sourceLine" id="cb27-141" title="141"></a>
<a class="sourceLine" id="cb27-142" title="142"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-143" title="143"><span class="dt">double</span> eval_generic_ex(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb27-144" title="144">  XPtr&lt;generic_opt&gt; optim(ptr);</a>
<a class="sourceLine" id="cb27-145" title="145"></a>
<a class="sourceLine" id="cb27-146" title="146">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb27-147" title="147">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb27-148" title="148">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_generic_ex: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb27-149" title="149"></a>
<a class="sourceLine" id="cb27-150" title="150">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb27-151" title="151">  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb27-152" title="152">}</a>
<a class="sourceLine" id="cb27-153" title="153"></a>
<a class="sourceLine" id="cb27-154" title="154"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-155" title="155">NumericVector grad_generic_ex(NumericVector val, SEXP ptr,</a>
<a class="sourceLine" id="cb27-156" title="156">                              <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb27-157" title="157">  XPtr&lt;generic_opt&gt; optim(ptr);</a>
<a class="sourceLine" id="cb27-158" title="158"></a>
<a class="sourceLine" id="cb27-159" title="159">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb27-160" title="160">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</a>
<a class="sourceLine" id="cb27-161" title="161">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_generic_ex: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb27-162" title="162"></a>
<a class="sourceLine" id="cb27-163" title="163">  NumericVector grad(val.size());</a>
<a class="sourceLine" id="cb27-164" title="164">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb27-165" title="165">  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</a>
<a class="sourceLine" id="cb27-166" title="166"></a>
<a class="sourceLine" id="cb27-167" title="167">  <span class="cf">return</span> grad;</a>
<a class="sourceLine" id="cb27-168" title="168">}</a>
<a class="sourceLine" id="cb27-169" title="169"></a>
<a class="sourceLine" id="cb27-170" title="170"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-171" title="171">NumericMatrix get_Hess_approx_generic(SEXP ptr){</a>
<a class="sourceLine" id="cb27-172" title="172">  XPtr&lt;generic_opt&gt; optim(ptr);</a>
<a class="sourceLine" id="cb27-173" title="173"></a>
<a class="sourceLine" id="cb27-174" title="174">  NumericMatrix out(optim-&gt;n_par, optim-&gt;n_par);</a>
<a class="sourceLine" id="cb27-175" title="175">  optim-&gt;get_hess(&amp;out[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb27-176" title="176"></a>
<a class="sourceLine" id="cb27-177" title="177">  <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb27-178" title="178">}</a>
<a class="sourceLine" id="cb27-179" title="179"></a>
<a class="sourceLine" id="cb27-180" title="180"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-181" title="181">Eigen::SparseMatrix&lt;<span class="dt">double</span>&gt; get_sparse_Hess_approx_generic(SEXP ptr){</a>
<a class="sourceLine" id="cb27-182" title="182">  <span class="cf">return</span> XPtr&lt;generic_opt&gt;(ptr)-&gt;get_hess_sparse();</a>
<a class="sourceLine" id="cb27-183" title="183">}</a>
<a class="sourceLine" id="cb27-184" title="184"></a>
<a class="sourceLine" id="cb27-185" title="185"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-186" title="186"><span class="dt">void</span> set_masked(SEXP ptr, Rcpp::IntegerVector indices){</a>
<a class="sourceLine" id="cb27-187" title="187">  XPtr&lt;generic_opt&gt;(ptr)-&gt;set_masked(indices.begin(), indices.end());</a>
<a class="sourceLine" id="cb27-188" title="188">}</a>
<a class="sourceLine" id="cb27-189" title="189"></a>
<a class="sourceLine" id="cb27-190" title="190"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb27-191" title="191"><span class="dt">void</span> clear_masked(SEXP ptr){</a>
<a class="sourceLine" id="cb27-192" title="192">  XPtr&lt;generic_opt&gt;(ptr)-&gt;clear_masked();</a>
<a class="sourceLine" id="cb27-193" title="193">}</a></code></pre></div>
<p>The required member functions are very similar to those needed for the <code>optimizer</code> class. We now simulate some data to work with this type of model as an example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1"><span class="co"># parameters for the simulation</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb28-3" title="3">K &lt;-<span class="st"> </span>2000L</a>
<a class="sourceLine" id="cb28-4" title="4">n &lt;-<span class="st"> </span>5L <span class="op">*</span><span class="st"> </span>K</a>
<a class="sourceLine" id="cb28-5" title="5"></a>
<a class="sourceLine" id="cb28-6" title="6"><span class="co"># simulate the data</span></a>
<a class="sourceLine" id="cb28-7" title="7">truth_limit &lt;-<span class="st"> </span><span class="kw">runif</span>(K, <span class="dv">-1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb28-8" title="8">dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(</a>
<a class="sourceLine" id="cb28-9" title="9">  n, {</a>
<a class="sourceLine" id="cb28-10" title="10">    <span class="co"># sample the indices</span></a>
<a class="sourceLine" id="cb28-11" title="11">    n_samp &lt;-<span class="st"> </span><span class="kw">sample.int</span>(5L, 1L) <span class="op">+</span><span class="st"> </span>1L</a>
<a class="sourceLine" id="cb28-12" title="12">    indices &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">sample.int</span>(K, n_samp))</a>
<a class="sourceLine" id="cb28-13" title="13"></a>
<a class="sourceLine" id="cb28-14" title="14">    <span class="co"># sample the outcome, y, and return    </span></a>
<a class="sourceLine" id="cb28-15" title="15">    <span class="kw">list</span>(<span class="dt">y =</span> <span class="kw">rpois</span>(<span class="dv">1</span>, <span class="kw">exp</span>(<span class="kw">sum</span>(truth_limit[indices]))), </a>
<a class="sourceLine" id="cb28-16" title="16">         <span class="dt">indices =</span> indices)</a>
<a class="sourceLine" id="cb28-17" title="17">  }, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb28-18" title="18"></a>
<a class="sourceLine" id="cb28-19" title="19"><span class="co"># we need each variable to be present at least once</span></a>
<a class="sourceLine" id="cb28-20" title="20"><span class="kw">stopifnot</span>(<span class="kw">length</span>(<span class="kw">unique</span>(<span class="kw">unlist</span>(</a>
<a class="sourceLine" id="cb28-21" title="21">  <span class="kw">lapply</span>(dat, <span class="st">`</span><span class="dt">[</span><span class="st">`</span>, <span class="st">&quot;indices&quot;</span>)</a>
<a class="sourceLine" id="cb28-22" title="22">))) <span class="op">==</span><span class="st"> </span>K) <span class="co"># otherwise we need to change the code</span></a></code></pre></div>
<p>We can minimize this problem using the following R code:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" title="1"><span class="co"># define a version in R to compute the function and its gradient</span></a>
<a class="sourceLine" id="cb29-2" title="2">R_func &lt;-<span class="st"> </span><span class="cf">function</span>(x){</a>
<a class="sourceLine" id="cb29-3" title="3">  out &lt;-<span class="st"> </span><span class="kw">vapply</span>(dat, <span class="cf">function</span>(z){</a>
<a class="sourceLine" id="cb29-4" title="4">    eta &lt;-<span class="st"> </span><span class="kw">sum</span>(x[z<span class="op">$</span>indices])</a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="op">-</span>z<span class="op">$</span>y <span class="op">*</span><span class="st"> </span>eta <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta)</a>
<a class="sourceLine" id="cb29-6" title="6">  }, <span class="fl">0.</span>)</a>
<a class="sourceLine" id="cb29-7" title="7">  <span class="kw">sum</span>(out)</a>
<a class="sourceLine" id="cb29-8" title="8">}</a>
<a class="sourceLine" id="cb29-9" title="9"></a>
<a class="sourceLine" id="cb29-10" title="10">R_func_gr &lt;-<span class="st"> </span><span class="cf">function</span>(x){</a>
<a class="sourceLine" id="cb29-11" title="11">  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</a>
<a class="sourceLine" id="cb29-12" title="12">  <span class="cf">for</span>(z <span class="cf">in</span> dat){</a>
<a class="sourceLine" id="cb29-13" title="13">    idx_i &lt;-<span class="st"> </span>z<span class="op">$</span>indices </a>
<a class="sourceLine" id="cb29-14" title="14">    eta &lt;-<span class="st"> </span><span class="kw">sum</span>(x[idx_i])</a>
<a class="sourceLine" id="cb29-15" title="15">    out[idx_i] &lt;-<span class="st"> </span>out[idx_i] <span class="op">-</span>z<span class="op">$</span>y <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta) </a>
<a class="sourceLine" id="cb29-16" title="16">  }</a>
<a class="sourceLine" id="cb29-17" title="17">  out</a>
<a class="sourceLine" id="cb29-18" title="18">}</a>
<a class="sourceLine" id="cb29-19" title="19"></a>
<a class="sourceLine" id="cb29-20" title="20"><span class="co"># find the optimum</span></a>
<a class="sourceLine" id="cb29-21" title="21"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb29-22" title="22">start &lt;-<span class="st"> </span>truth_limit <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(K, <span class="dt">sd =</span> <span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb29-23" title="23"><span class="co"># all.equal(numDeriv::grad(R_func, start), R_func_gr(start))</span></a>
<a class="sourceLine" id="cb29-24" title="24">opt &lt;-<span class="st"> </span><span class="kw">optim</span>(start, R_func, R_func_gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, </a>
<a class="sourceLine" id="cb29-25" title="25">             <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">maxit =</span> 1000L))</a>
<a class="sourceLine" id="cb29-26" title="26">opt<span class="op">$</span>value <span class="co"># optimal solution</span></a>
<a class="sourceLine" id="cb29-27" title="27"><span class="co">#&gt; [1] -8621</span></a></code></pre></div>
<p>The model can also be estimated using <code>glm</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="co"># create the design matrix</span></a>
<a class="sourceLine" id="cb30-2" title="2">X &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">vapply</span>(dat, <span class="cf">function</span>(x){</a>
<a class="sourceLine" id="cb30-3" title="3">  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(K)</a>
<a class="sourceLine" id="cb30-4" title="4">  out[x<span class="op">$</span>indices] &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb30-5" title="5">  out</a>
<a class="sourceLine" id="cb30-6" title="6">}, <span class="kw">numeric</span>(K)))</a>
<a class="sourceLine" id="cb30-7" title="7">y &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">sapply</span>(dat, <span class="st">`</span><span class="dt">[[</span><span class="st">`</span>, <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb30-8" title="8"></a>
<a class="sourceLine" id="cb30-9" title="9"><span class="co"># this is very slow...</span></a>
<a class="sourceLine" id="cb30-10" title="10"><span class="kw">system.time</span>(glm_fit &lt;-<span class="st"> </span><span class="kw">glm.fit</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> y, <span class="dt">family =</span> <span class="kw">poisson</span>(), </a>
<a class="sourceLine" id="cb30-11" title="11">                               <span class="dt">start =</span> start))</a>
<a class="sourceLine" id="cb30-12" title="12"><span class="co">#&gt;    user  system elapsed </span></a>
<a class="sourceLine" id="cb30-13" title="13"><span class="co">#&gt; 155.251   0.328 155.587</span></a>
<a class="sourceLine" id="cb30-14" title="14"></a>
<a class="sourceLine" id="cb30-15" title="15"><span class="co"># we get (roughly) the same</span></a>
<a class="sourceLine" id="cb30-16" title="16"><span class="kw">all.equal</span>(glm_fit<span class="op">$</span>coefficients, opt<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb30-17" title="17"><span class="co">#&gt; [1] &quot;Mean relative difference: 9.95e-05&quot;</span></a>
<a class="sourceLine" id="cb30-18" title="18"><span class="kw">R_func</span>(glm_fit<span class="op">$</span>coefficients)</a>
<a class="sourceLine" id="cb30-19" title="19"><span class="co">#&gt; [1] -8621</span></a>
<a class="sourceLine" id="cb30-20" title="20">glm_fit &lt;-<span class="st"> </span>glm_fit[<span class="kw">c</span>(<span class="st">&quot;coefficients&quot;</span>, <span class="st">&quot;deviance&quot;</span>)]</a>
<a class="sourceLine" id="cb30-21" title="21"></a>
<a class="sourceLine" id="cb30-22" title="22"><span class="co"># the objects are quite big so we remove them </span></a>
<a class="sourceLine" id="cb30-23" title="23"><span class="kw">rm</span>(X, y)</a></code></pre></div>
<p>The above could possibly be done much faster if sparse matrices where used in <code>glm.fit</code>. The problem can also be solved with the C++ implementation using the following code:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" title="1"><span class="co"># source the C++ version used in this package</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">library</span>(Rcpp)</a>
<a class="sourceLine" id="cb31-3" title="3"><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;generic_example.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="co"># create the list to pass to C++</span></a>
<a class="sourceLine" id="cb31-6" title="6">cpp_arg &lt;-<span class="st"> </span><span class="kw">lapply</span>(dat, <span class="cf">function</span>(x){</a>
<a class="sourceLine" id="cb31-7" title="7">  x<span class="op">$</span>indices &lt;-<span class="st"> </span>x<span class="op">$</span>indices <span class="op">-</span><span class="st"> </span>1L <span class="co"># C++ needs zero-based indices</span></a>
<a class="sourceLine" id="cb31-8" title="8">  x</a>
<a class="sourceLine" id="cb31-9" title="9">})</a>
<a class="sourceLine" id="cb31-10" title="10">ptr &lt;-<span class="st"> </span><span class="kw">get_generic_ex_obj</span>(cpp_arg, <span class="dt">max_threads =</span> 4L)</a>
<a class="sourceLine" id="cb31-11" title="11"></a>
<a class="sourceLine" id="cb31-12" title="12"><span class="co"># check that we get the same</span></a>
<a class="sourceLine" id="cb31-13" title="13">noise &lt;-<span class="st"> </span><span class="kw">rnorm</span>(K)</a>
<a class="sourceLine" id="cb31-14" title="14"><span class="kw">all.equal</span>(<span class="kw">eval_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb31-15" title="15">          <span class="kw">R_func</span>         (noise))</a>
<a class="sourceLine" id="cb31-16" title="16"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-17" title="17"><span class="kw">all.equal</span>(gv &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb31-18" title="18">          <span class="kw">R_func_gr</span>            (noise), </a>
<a class="sourceLine" id="cb31-19" title="19">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb31-20" title="20"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-21" title="21"><span class="kw">all.equal</span>(<span class="kw">attr</span>(gv, <span class="st">&quot;value&quot;</span>), <span class="kw">R_func</span>(noise))</a>
<a class="sourceLine" id="cb31-22" title="22"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-23" title="23"></a>
<a class="sourceLine" id="cb31-24" title="24"><span class="co"># also gives the same with two threads</span></a>
<a class="sourceLine" id="cb31-25" title="25"><span class="kw">all.equal</span>(<span class="kw">eval_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb31-26" title="26">          <span class="kw">R_func</span>         (noise))</a>
<a class="sourceLine" id="cb31-27" title="27"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-28" title="28"><span class="kw">all.equal</span>(gv &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb31-29" title="29">          <span class="kw">R_func_gr</span>            (noise), </a>
<a class="sourceLine" id="cb31-30" title="30">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb31-31" title="31"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-32" title="32"><span class="kw">all.equal</span>(<span class="kw">attr</span>(gv, <span class="st">&quot;value&quot;</span>), <span class="kw">R_func</span>(noise))</a>
<a class="sourceLine" id="cb31-33" title="33"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-34" title="34"></a>
<a class="sourceLine" id="cb31-35" title="35"><span class="co"># optimize and compare the result with one thread</span></a>
<a class="sourceLine" id="cb31-36" title="36">psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 1L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.1</span>, <span class="dt">trace =</span> 0L, </a>
<a class="sourceLine" id="cb31-37" title="37">                      <span class="dt">pre_method =</span> 1L, <span class="dt">cg_tol =</span> <span class="fl">.5</span>)</a>
<a class="sourceLine" id="cb31-38" title="38">  <span class="kw">optim_generic_ex</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> ptr, <span class="dt">rel_eps =</span> <span class="fl">1e-9</span>, <span class="dt">max_it =</span> 1000L, </a>
<a class="sourceLine" id="cb31-39" title="39">                   <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, </a>
<a class="sourceLine" id="cb31-40" title="40">                   <span class="dt">cg_tol =</span> cg_tol, <span class="dt">pre_method =</span> pre_method)</a>
<a class="sourceLine" id="cb31-41" title="41"></a>
<a class="sourceLine" id="cb31-42" title="42">opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start)</a>
<a class="sourceLine" id="cb31-43" title="43"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, opt<span class="op">$</span>par, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb31-44" title="44"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-45" title="45"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb31-46" title="46"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-47" title="47">opt_psqn<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>opt<span class="op">$</span>value <span class="co"># (negative values implies a better solution)</span></a>
<a class="sourceLine" id="cb31-48" title="48"><span class="co">#&gt; [1] -0.000102</span></a>
<a class="sourceLine" id="cb31-49" title="49"></a>
<a class="sourceLine" id="cb31-50" title="50"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, glm_fit<span class="op">$</span>coefficients, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb31-51" title="51"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-52" title="52"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, <span class="kw">R_func</span>(glm_fit<span class="op">$</span>coefficients))</a>
<a class="sourceLine" id="cb31-53" title="53"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-54" title="54"></a>
<a class="sourceLine" id="cb31-55" title="55"><span class="co"># compare counts</span></a>
<a class="sourceLine" id="cb31-56" title="56">opt_psqn<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb31-57" title="57"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb31-58" title="58"><span class="co">#&gt;       93       59       67</span></a>
<a class="sourceLine" id="cb31-59" title="59">opt     <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb31-60" title="60"><span class="co">#&gt; function gradient </span></a>
<a class="sourceLine" id="cb31-61" title="61"><span class="co">#&gt;      425      103</span></a>
<a class="sourceLine" id="cb31-62" title="62"></a>
<a class="sourceLine" id="cb31-63" title="63"><span class="co"># we can do the same with two threads</span></a>
<a class="sourceLine" id="cb31-64" title="64">opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb31-65" title="65"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, opt<span class="op">$</span>par, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb31-66" title="66"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-67" title="67"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb31-68" title="68"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb31-69" title="69">opt_psqn<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>opt<span class="op">$</span>value <span class="co"># (negative values implies a better solution)</span></a>
<a class="sourceLine" id="cb31-70" title="70"><span class="co">#&gt; [1] -0.000102</span></a>
<a class="sourceLine" id="cb31-71" title="71"></a>
<a class="sourceLine" id="cb31-72" title="72"><span class="co"># compare counts</span></a>
<a class="sourceLine" id="cb31-73" title="73">opt_psqn<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb31-74" title="74"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb31-75" title="75"><span class="co">#&gt;       93       59       67</span></a>
<a class="sourceLine" id="cb31-76" title="76">opt     <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb31-77" title="77"><span class="co">#&gt; function gradient </span></a>
<a class="sourceLine" id="cb31-78" title="78"><span class="co">#&gt;      425      103</span></a></code></pre></div>
<p>The C++ version is much faster:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="st">`</span><span class="dt">R version</span><span class="st">`</span> =<span class="st"> </span><span class="kw">optim</span>(start, R_func, R_func_gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="st">`</span><span class="dt">R w/ C++</span><span class="st">`</span> =<span class="st"> </span><span class="kw">optim</span>(</a>
<a class="sourceLine" id="cb32-4" title="4">    start, </a>
<a class="sourceLine" id="cb32-5" title="5">    <span class="cf">function</span>(x) <span class="kw">eval_generic_ex</span>(x, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="cf">function</span>(x) <span class="kw">grad_generic_ex</span>(x, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb32-7" title="7">    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </a>
<a class="sourceLine" id="cb32-8" title="8">  <span class="dt">psqn =</span> <span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb32-9" title="9">  <span class="st">`</span><span class="dt">psqn 2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb32-10" title="10">  <span class="dt">min_iterations =</span> 2L, <span class="dt">check =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb32-11" title="11"><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></a>
<a class="sourceLine" id="cb32-12" title="12"><span class="co">#&gt; # A tibble: 4 × 6</span></a>
<a class="sourceLine" id="cb32-13" title="13"><span class="co">#&gt;   expression          min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb32-14" title="14"><span class="co">#&gt;   &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb32-15" title="15"><span class="co">#&gt; 1 R version         8.98s    9.05s     0.111    55.1MB     7.13</span></a>
<a class="sourceLine" id="cb32-16" title="16"><span class="co">#&gt; 2 R w/ C++          2.15s    2.23s     0.449      26MB     0   </span></a>
<a class="sourceLine" id="cb32-17" title="17"><span class="co">#&gt; 3 psqn            72.29ms  74.88ms    13.3      18.2KB     0   </span></a>
<a class="sourceLine" id="cb32-18" title="18"><span class="co">#&gt; 4 psqn 2 threads  39.68ms  40.51ms    24.8      18.2KB     0</span></a></code></pre></div>
<div id="generic-example-r-interface" class="section level4">
<h4>Generic Example: R Interface</h4>
<p>A R interface to the <code>optimizer_generic</code> class is provided through the <code>psqn_generic</code> function. We show an example below of how the R interface can be used to solve the same problem we had before:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" title="1"><span class="co"># assign the function to pass to psqn_generic</span></a>
<a class="sourceLine" id="cb33-2" title="2">r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</a>
<a class="sourceLine" id="cb33-3" title="3">  z &lt;-<span class="st"> </span>dat[[i]]</a>
<a class="sourceLine" id="cb33-4" title="4">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">==</span><span class="st"> </span>0L)</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="co"># we need to return the indices of the parameters that this element function</span></a>
<a class="sourceLine" id="cb33-6" title="6">    <span class="co"># depends on. These need to be one-based like in R</span></a>
<a class="sourceLine" id="cb33-7" title="7">    <span class="kw">return</span>(z<span class="op">$</span>indices)</a>
<a class="sourceLine" id="cb33-8" title="8">  </a>
<a class="sourceLine" id="cb33-9" title="9">  <span class="co"># we need to compute the element function and possibly its gradient</span></a>
<a class="sourceLine" id="cb33-10" title="10">  eta &lt;-<span class="st"> </span><span class="kw">sum</span>(par)</a>
<a class="sourceLine" id="cb33-11" title="11">  exp_eta &lt;-<span class="st"> </span><span class="kw">exp</span>(eta)</a>
<a class="sourceLine" id="cb33-12" title="12">  out &lt;-<span class="st"> </span><span class="op">-</span>z<span class="op">$</span>y <span class="op">*</span><span class="st"> </span>eta <span class="op">+</span><span class="st"> </span>exp_eta</a>
<a class="sourceLine" id="cb33-13" title="13">  <span class="cf">if</span>(comp_grad)</a>
<a class="sourceLine" id="cb33-14" title="14">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="op">-</span>z<span class="op">$</span>y <span class="op">+</span><span class="st"> </span>exp_eta, <span class="kw">length</span>(z<span class="op">$</span>indices))</a>
<a class="sourceLine" id="cb33-15" title="15">  out</a>
<a class="sourceLine" id="cb33-16" title="16">}</a>
<a class="sourceLine" id="cb33-17" title="17"></a>
<a class="sourceLine" id="cb33-18" title="18"><span class="co"># estimate the model with the R interface</span></a>
<a class="sourceLine" id="cb33-19" title="19">psqn_func_R &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.1</span>, <span class="dt">trace =</span> 0L, <span class="dt">pre_method =</span> 1L)</a>
<a class="sourceLine" id="cb33-20" title="20">  <span class="kw">psqn_generic</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> <span class="kw">length</span>(dat), </a>
<a class="sourceLine" id="cb33-21" title="21">               <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, <span class="dt">rel_eps =</span> <span class="fl">1e-9</span>, <span class="dt">max_it =</span> 1000L, </a>
<a class="sourceLine" id="cb33-22" title="22">               <span class="dt">pre_method =</span> pre_method)</a>
<a class="sourceLine" id="cb33-23" title="23"></a>
<a class="sourceLine" id="cb33-24" title="24">opt_psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func_R</span>(start)</a>
<a class="sourceLine" id="cb33-25" title="25"></a>
<a class="sourceLine" id="cb33-26" title="26"><span class="co"># we get the same </span></a>
<a class="sourceLine" id="cb33-27" title="27">opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 1L)</a>
<a class="sourceLine" id="cb33-28" title="28"><span class="kw">all.equal</span>(opt_psqn_res<span class="op">$</span>par  , opt_psqn<span class="op">$</span>par  )</a>
<a class="sourceLine" id="cb33-29" title="29"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb33-30" title="30"><span class="kw">all.equal</span>(opt_psqn_res<span class="op">$</span>value, opt_psqn<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb33-31" title="31"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>The R version is much slower though in this case. The reason is that the element functions are extremely cheap computationally to evaluate and therefore the extra overhead from the R interface is an issue.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" title="1"><span class="co"># show the computation time</span></a>
<a class="sourceLine" id="cb34-2" title="2">bench<span class="op">::</span><span class="kw">mark</span>(<span class="kw">psqn_func_R</span>(start), <span class="dt">min_iterations =</span> 2L)</a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="co">#&gt; # A tibble: 1 × 6</span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">#&gt;   expression              min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="co">#&gt; 1 psqn_func_R(start)    3.41s    3.47s     0.288    29.1KB     17.6</span></a></code></pre></div>
</div>
<div id="getting-the-hessian-approximation-1" class="section level4">
<h4>Getting the Hessian Approximation</h4>
<p>We can get the Hessian approximation by calling the <code>get_Hess_approx_generic</code> and <code>get_sparse_Hess_approx_generic</code> we declared after calling the optimizer:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" title="1">aprox_hes &lt;-<span class="st"> </span><span class="kw">get_Hess_approx_generic</span>(ptr)</a>
<a class="sourceLine" id="cb35-2" title="2"><span class="kw">dim</span>(aprox_hes) <span class="co"># quite large; requires a lot of memory</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co">#&gt; [1] 2000 2000</span></a>
<a class="sourceLine" id="cb35-4" title="4"></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co"># we can also get the sparse version</span></a>
<a class="sourceLine" id="cb35-6" title="6">aprox_hes_sparse &lt;-<span class="st"> </span><span class="kw">get_sparse_Hess_approx_generic</span>(ptr)</a>
<a class="sourceLine" id="cb35-7" title="7"><span class="kw">all.equal</span>(<span class="kw">as.matrix</span>(aprox_hes_sparse), aprox_hes, </a>
<a class="sourceLine" id="cb35-8" title="8">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb35-9" title="9"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb35-10" title="10"></a>
<a class="sourceLine" id="cb35-11" title="11"><span class="co"># this require much less memory </span></a>
<a class="sourceLine" id="cb35-12" title="12"><span class="kw">object.size</span>(aprox_hes)</a>
<a class="sourceLine" id="cb35-13" title="13"><span class="co">#&gt; 32000216 bytes</span></a>
<a class="sourceLine" id="cb35-14" title="14"><span class="kw">object.size</span>(aprox_hes_sparse)</a>
<a class="sourceLine" id="cb35-15" title="15"><span class="co">#&gt; 1717344 bytes</span></a>
<a class="sourceLine" id="cb35-16" title="16"></a>
<a class="sourceLine" id="cb35-17" title="17"><span class="co"># we can roughly check against the true values as follows</span></a>
<a class="sourceLine" id="cb35-18" title="18"><span class="cf">if</span>(<span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb35-19" title="19">  <span class="co"># only feasible for smaller problem</span></a>
<a class="sourceLine" id="cb35-20" title="20">  <span class="kw">library</span>(numDeriv)</a>
<a class="sourceLine" id="cb35-21" title="21">  hess_true &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</a>
<a class="sourceLine" id="cb35-22" title="22">    <span class="cf">function</span>(par) <span class="kw">grad_generic_ex</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb35-23" title="23">    opt_psqn<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb35-24" title="24">  </a>
<a class="sourceLine" id="cb35-25" title="25">  <span class="co"># should not hold exactly! Might not be that good of an approximation.</span></a>
<a class="sourceLine" id="cb35-26" title="26">  <span class="kw">all.equal</span>(aprox_hes, hess_true)</a>
<a class="sourceLine" id="cb35-27" title="27">  </a>
<a class="sourceLine" id="cb35-28" title="28">  <span class="co"># the non-zero entries should match </span></a>
<a class="sourceLine" id="cb35-29" title="29">  v1 &lt;-<span class="st"> </span><span class="kw">abs</span>(hess_true) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb35-30" title="30">  v2 &lt;-<span class="st"> </span><span class="kw">abs</span>(aprox_hes) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb35-31" title="31">  <span class="kw">all.equal</span>(v1, v2)</a>
<a class="sourceLine" id="cb35-32" title="32">}</a>
<a class="sourceLine" id="cb35-33" title="33"></a>
<a class="sourceLine" id="cb35-34" title="34"><span class="co"># create a plot like before. Black entries are non-zero</span></a>
<a class="sourceLine" id="cb35-35" title="35"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>))</a>
<a class="sourceLine" id="cb35-36" title="36">idx &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">min</span>(<span class="dv">1000</span>, <span class="kw">NROW</span>(aprox_hes))</a>
<a class="sourceLine" id="cb35-37" title="37">aprox_hes &lt;-<span class="st"> </span>aprox_hes[idx, idx] <span class="co"># reduce dimension to plot quickly</span></a>
<a class="sourceLine" id="cb35-38" title="38"><span class="kw">image</span>(<span class="kw">abs</span>(aprox_hes[, <span class="kw">NCOL</span>(aprox_hes)<span class="op">:</span><span class="dv">1</span>]) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dt">xaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>,</a>
<a class="sourceLine" id="cb35-39" title="39">      <span class="dt">col =</span> <span class="kw">gray.colors</span>(2L, <span class="dv">1</span>, <span class="dv">0</span>))</a></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
</div>
<div id="using-different-preconditioners-1" class="section level4">
<h4>Using Different Preconditioners</h4>
<p>We can use different preconditioner. We illustrate this below. Notice that you have to define the <code>PSQN_USE_EIGEN</code> macro variable prior to including any of the psqn headers files if you are using the C++ interface in order to use the incomplete Cholesky factorization from Eigen. You will also have to include RcppEigen or the psqn-Rcpp-wrapper.h header.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" title="1"><span class="co"># without any preconditioner</span></a>
<a class="sourceLine" id="cb36-2" title="2">opt_psqn_no_pre &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">pre_method =</span> 0L)</a>
<a class="sourceLine" id="cb36-3" title="3"></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co"># we get the same</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt_psqn_no_pre<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb36-7" title="7"></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co"># we mainly use more conjugate gradient steps</span></a>
<a class="sourceLine" id="cb36-9" title="9">opt_psqn       <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb36-10" title="10"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">#&gt;       93       59       67</span></a>
<a class="sourceLine" id="cb36-12" title="12">opt_psqn_no_pre<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb36-13" title="13"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co">#&gt;       85       57      145</span></a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="co"># with the incomplete Cholesky factorization</span></a>
<a class="sourceLine" id="cb36-17" title="17">opt_psqn_cholesky &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">pre_method =</span> 2L)</a>
<a class="sourceLine" id="cb36-18" title="18"><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt_psqn_cholesky<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb36-19" title="19"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb36-20" title="20"></a>
<a class="sourceLine" id="cb36-21" title="21"><span class="co"># we use fewer conjugate gradient steps</span></a>
<a class="sourceLine" id="cb36-22" title="22">opt_psqn_cholesky<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb36-23" title="23"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb36-24" title="24"><span class="co">#&gt;       87       51       32</span></a>
<a class="sourceLine" id="cb36-25" title="25">opt_psqn         <span class="op">$</span>counts</a>
<a class="sourceLine" id="cb36-26" title="26"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb36-27" title="27"><span class="co">#&gt;       93       59       67</span></a>
<a class="sourceLine" id="cb36-28" title="28"></a>
<a class="sourceLine" id="cb36-29" title="29"><span class="co"># we can equally use the R interface</span></a>
<a class="sourceLine" id="cb36-30" title="30">opt_psqn_cholesky_R &lt;-<span class="st"> </span><span class="kw">psqn_func_R</span>(start, <span class="dt">pre_method =</span> 2L)</a>
<a class="sourceLine" id="cb36-31" title="31"><span class="kw">all.equal</span>(opt_psqn_cholesky_R[<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)], </a>
<a class="sourceLine" id="cb36-32" title="32">          opt_psqn_cholesky  [<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)])</a>
<a class="sourceLine" id="cb36-33" title="33"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="masking-parameters" class="section level4">
<h4>Masking Parameters</h4>
<p>We can mask (fix) the parameters using both the R and C++ interface as shown below.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" title="1"><span class="co"># set the parameters to mask</span></a>
<a class="sourceLine" id="cb37-2" title="2">par_mask &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(opt_psqn_res<span class="op">$</span>par))</a>
<a class="sourceLine" id="cb37-3" title="3"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb37-4" title="4">idx_mask &lt;-<span class="st"> </span><span class="kw">sample.int</span>(<span class="kw">length</span>(par_mask), 100L) <span class="co"># random indices we mask</span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="co"># add some noise to the parameters</span></a>
<a class="sourceLine" id="cb37-6" title="6">par_mask[idx_mask] &lt;-<span class="st"> </span>par_mask[idx_mask] <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(idx_mask), <span class="dt">sd =</span> <span class="fl">.1</span>)</a>
<a class="sourceLine" id="cb37-7" title="7"></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="co"># use the R interface</span></a>
<a class="sourceLine" id="cb37-9" title="9">mask_psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_generic</span>(</a>
<a class="sourceLine" id="cb37-10" title="10">  <span class="dt">par =</span> par_mask, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> <span class="kw">length</span>(dat), <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.1</span>, </a>
<a class="sourceLine" id="cb37-11" title="11">  <span class="dt">trace =</span> 0L, <span class="dt">rel_eps =</span> <span class="fl">1e-9</span>, <span class="dt">max_it =</span> 1000L, <span class="dt">pre_method =</span> 1L,</a>
<a class="sourceLine" id="cb37-12" title="12">  <span class="dt">mask =</span> idx_mask <span class="op">-</span><span class="st"> </span>1L) <span class="co"># -1L to be zero based</span></a>
<a class="sourceLine" id="cb37-13" title="13"></a>
<a class="sourceLine" id="cb37-14" title="14"><span class="co"># we can do the same with optim</span></a>
<a class="sourceLine" id="cb37-15" title="15">opt &lt;-<span class="st"> </span><span class="kw">optim</span>(</a>
<a class="sourceLine" id="cb37-16" title="16">  par_mask[<span class="op">-</span>idx_mask], </a>
<a class="sourceLine" id="cb37-17" title="17">  <span class="cf">function</span>(x) { par_mask[<span class="op">-</span>idx_mask] &lt;-<span class="st"> </span>x; <span class="kw">R_func</span>   (par_mask) }, </a>
<a class="sourceLine" id="cb37-18" title="18">  <span class="cf">function</span>(x) { par_mask[<span class="op">-</span>idx_mask] &lt;-<span class="st"> </span>x; <span class="kw">R_func_gr</span>(par_mask)[<span class="op">-</span>idx_mask] }, </a>
<a class="sourceLine" id="cb37-19" title="19">  <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">maxit =</span> 1000L))</a>
<a class="sourceLine" id="cb37-20" title="20"></a>
<a class="sourceLine" id="cb37-21" title="21"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb37-22" title="22"><span class="kw">all.equal</span>(mask_psqn_res<span class="op">$</span>par[<span class="op">-</span>idx_mask], opt<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb37-23" title="23"><span class="co">#&gt; [1] &quot;Mean relative difference: 0.000367&quot;</span></a>
<a class="sourceLine" id="cb37-24" title="24">mask_psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>opt<span class="op">$</span>value <span class="co"># negative values is a better solution</span></a>
<a class="sourceLine" id="cb37-25" title="25"><span class="co">#&gt; [1] -0.00132</span></a>
<a class="sourceLine" id="cb37-26" title="26"></a>
<a class="sourceLine" id="cb37-27" title="27"><span class="co"># the fixed parameters are the same</span></a>
<a class="sourceLine" id="cb37-28" title="28"><span class="kw">all.equal</span>(mask_psqn_res<span class="op">$</span>par[idx_mask], par_mask[idx_mask])</a>
<a class="sourceLine" id="cb37-29" title="29"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb37-30" title="30"></a>
<a class="sourceLine" id="cb37-31" title="31"><span class="co"># we can also do this from C++</span></a>
<a class="sourceLine" id="cb37-32" title="32"><span class="kw">set_masked</span>(ptr, idx_mask <span class="op">-</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb37-33" title="33">mask_psqn_res_cpp &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(par_mask)</a>
<a class="sourceLine" id="cb37-34" title="34"><span class="kw">clear_masked</span>(ptr) <span class="co"># remember to clear!</span></a>
<a class="sourceLine" id="cb37-35" title="35"></a>
<a class="sourceLine" id="cb37-36" title="36"><span class="co"># we got the same</span></a>
<a class="sourceLine" id="cb37-37" title="37"><span class="kw">all.equal</span>(mask_psqn_res_cpp<span class="op">$</span>par, mask_psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb37-38" title="38"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
</div>
<div id="using-kahan-summation-algorithm" class="section level3">
<h3>Using Kahan Summation Algorithm</h3>
<p>By default, <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a> is used with the <code>optimizer_generic</code> class. This can be avoided by defining <code>PSQN_NO_USE_KAHAN</code> prior to including any headers from the psqn package. One may want to do so if numerical stability does not matter for a given problem. Notice though that the extra computation time may only be substantial if the <code>func</code> and <code>grad</code> member functions are evaluated very fast.</p>
<p>To illustrate this, we will show that the previous method yields almost the same regardless of the number of threads. Then we will show that the difference is larger when we define <code>PSQN_NO_USE_KAHAN</code> but the computation time is reduced.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" title="1"><span class="co"># we get almost the same regardless of the number of threads. We show this by </span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="co"># looking at the mean relative error of the gradient</span></a>
<a class="sourceLine" id="cb38-3" title="3">g1 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L)</a>
<a class="sourceLine" id="cb38-4" title="4">g2 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb38-5" title="5">g3 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L)</a>
<a class="sourceLine" id="cb38-6" title="6"></a>
<a class="sourceLine" id="cb38-7" title="7"><span class="kw">mean</span>(<span class="kw">abs</span>((g1 <span class="op">-</span><span class="st"> </span>g2) <span class="op">/</span><span class="st"> </span>g1)) </a>
<a class="sourceLine" id="cb38-8" title="8"><span class="co">#&gt; [1] 1.3e-16</span></a>
<a class="sourceLine" id="cb38-9" title="9"><span class="kw">mean</span>(<span class="kw">abs</span>((g1 <span class="op">-</span><span class="st"> </span>g3) <span class="op">/</span><span class="st"> </span>g1))</a>
<a class="sourceLine" id="cb38-10" title="10"><span class="co">#&gt; [1] 1.23e-16</span></a>
<a class="sourceLine" id="cb38-11" title="11"></a>
<a class="sourceLine" id="cb38-12" title="12"><span class="co"># the computation time is as follows</span></a>
<a class="sourceLine" id="cb38-13" title="13">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb38-14" title="14">  <span class="st">`</span><span class="dt">1 thread</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb38-15" title="15">  <span class="st">`</span><span class="dt">2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb38-16" title="16">  <span class="st">`</span><span class="dt">3 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L))</a>
<a class="sourceLine" id="cb38-17" title="17"><span class="co">#&gt; # A tibble: 3 × 6</span></a>
<a class="sourceLine" id="cb38-18" title="18"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb38-19" title="19"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb38-20" title="20"><span class="co">#&gt; 1 1 thread      382µs    394µs     2506.    18.2KB     0   </span></a>
<a class="sourceLine" id="cb38-21" title="21"><span class="co">#&gt; 2 2 threads     172µs    178µs     5490.    18.2KB     0   </span></a>
<a class="sourceLine" id="cb38-22" title="22"><span class="co">#&gt; 3 3 threads     122µs    128µs     7658.    18.2KB     2.02</span></a>
<a class="sourceLine" id="cb38-23" title="23"></a>
<a class="sourceLine" id="cb38-24" title="24"><span class="co"># next, we compile the file but having defined PSQN_NO_USE_KAHAN in the </span></a>
<a class="sourceLine" id="cb38-25" title="25"><span class="co"># beginning</span></a>
<a class="sourceLine" id="cb38-26" title="26">tmp_file &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">tempfile</span>(), <span class="st">&quot;.cpp&quot;</span>)</a>
<a class="sourceLine" id="cb38-27" title="27">tmp_file_con &lt;-<span class="st"> </span><span class="kw">file</span>(tmp_file)</a>
<a class="sourceLine" id="cb38-28" title="28"><span class="kw">writeLines</span>(</a>
<a class="sourceLine" id="cb38-29" title="29">  <span class="co"># add the macro definition to the beginning of the file</span></a>
<a class="sourceLine" id="cb38-30" title="30">  <span class="kw">c</span>(<span class="st">&quot;#define PSQN_NO_USE_KAHAN&quot;</span>, </a>
<a class="sourceLine" id="cb38-31" title="31">    <span class="kw">readLines</span>(<span class="kw">system.file</span>(<span class="st">&quot;generic_example.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))), </a>
<a class="sourceLine" id="cb38-32" title="32">  tmp_file_con)</a>
<a class="sourceLine" id="cb38-33" title="33"><span class="kw">close</span>(tmp_file_con)</a>
<a class="sourceLine" id="cb38-34" title="34"><span class="kw">sourceCpp</span>(tmp_file) <span class="co"># source the file again</span></a>
<a class="sourceLine" id="cb38-35" title="35"></a>
<a class="sourceLine" id="cb38-36" title="36"><span class="co"># re-compute the gradient and the mean relative error of the gradient</span></a>
<a class="sourceLine" id="cb38-37" title="37">ptr &lt;-<span class="st"> </span><span class="kw">get_generic_ex_obj</span>(cpp_arg, <span class="dt">max_threads =</span> 4L)</a>
<a class="sourceLine" id="cb38-38" title="38">new_g1 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L)</a>
<a class="sourceLine" id="cb38-39" title="39">new_g2 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb38-40" title="40">new_g3 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L)</a>
<a class="sourceLine" id="cb38-41" title="41"></a>
<a class="sourceLine" id="cb38-42" title="42"><span class="kw">mean</span>(<span class="kw">abs</span>((g1     <span class="op">-</span><span class="st"> </span>new_g1) <span class="op">/</span><span class="st"> </span>g1    ))</a>
<a class="sourceLine" id="cb38-43" title="43"><span class="co">#&gt; [1] 3.9e-16</span></a>
<a class="sourceLine" id="cb38-44" title="44"><span class="kw">mean</span>(<span class="kw">abs</span>((new_g1 <span class="op">-</span><span class="st"> </span>new_g2) <span class="op">/</span><span class="st"> </span>new_g1)) </a>
<a class="sourceLine" id="cb38-45" title="45"><span class="co">#&gt; [1] 2.49e-16</span></a>
<a class="sourceLine" id="cb38-46" title="46"><span class="kw">mean</span>(<span class="kw">abs</span>((new_g1 <span class="op">-</span><span class="st"> </span>new_g3) <span class="op">/</span><span class="st"> </span>new_g1))</a>
<a class="sourceLine" id="cb38-47" title="47"><span class="co">#&gt; [1] 2.76e-16</span></a>
<a class="sourceLine" id="cb38-48" title="48"></a>
<a class="sourceLine" id="cb38-49" title="49"><span class="co"># check the new computation time</span></a>
<a class="sourceLine" id="cb38-50" title="50">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb38-51" title="51">  <span class="st">`</span><span class="dt">1 thread</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb38-52" title="52">  <span class="st">`</span><span class="dt">2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb38-53" title="53">  <span class="st">`</span><span class="dt">3 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L))</a>
<a class="sourceLine" id="cb38-54" title="54"><span class="co">#&gt; # A tibble: 3 × 6</span></a>
<a class="sourceLine" id="cb38-55" title="55"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb38-56" title="56"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb38-57" title="57"><span class="co">#&gt; 1 1 thread      348µs    354µs     2808.    18.2KB        0</span></a>
<a class="sourceLine" id="cb38-58" title="58"><span class="co">#&gt; 2 2 threads     157µs    160µs     6064.    18.2KB        0</span></a>
<a class="sourceLine" id="cb38-59" title="59"><span class="co">#&gt; 3 3 threads     112µs    114µs     8581.    18.2KB        0</span></a></code></pre></div>
<p>The error is only slightly larger in the latter case in this example and the computation time is reduced because the <code>func</code> and <code>grad</code> member functions are cheap to evaluate computationally.</p>
</div>
</div>
<div id="details" class="section level2">
<h2>Details</h2>
<div id="using-the-code-in-a-package" class="section level3">
<h3>Using the Code in a Package</h3>
<p>The main part of this packages is a header-only library. Thus, the code can be used within a R package by adding <code>psqn</code> to <code>LinkingTo</code> in the DESCRIPTION file. This is an advantage as one can avoid repeated compilation of the code.</p>
<p>Moreover, since the main part of the code is a header-only library, this package can easily be used within languages which can easily call C++ code.</p>
</div>
<div id="bfgs-method" class="section level3">
<h3>BFGS Method</h3>
<p>There is also a BFGS implementation in the package. This is both available in R through the <code>psqn_bfgs</code> function and in C++ in the psqn-bfgs.h header file. An example is provided below using the example from <code>optim</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" title="1"><span class="co"># declare function and gradient from the example from help(optim)</span></a>
<a class="sourceLine" id="cb39-2" title="2">fn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb39-3" title="3">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb39-4" title="4">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb39-5" title="5">  <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb39-6" title="6">}</a>
<a class="sourceLine" id="cb39-7" title="7">gr &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb39-8" title="8">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb39-9" title="9">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb39-10" title="10">  <span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</a>
<a class="sourceLine" id="cb39-11" title="11">     <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</a>
<a class="sourceLine" id="cb39-12" title="12">}</a>
<a class="sourceLine" id="cb39-13" title="13"></a>
<a class="sourceLine" id="cb39-14" title="14"><span class="co"># we need a different function for the method in this package</span></a>
<a class="sourceLine" id="cb39-15" title="15">gr_psqn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb39-16" title="16">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb39-17" title="17">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb39-18" title="18">  out &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</a>
<a class="sourceLine" id="cb39-19" title="19">            <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</a>
<a class="sourceLine" id="cb39-20" title="20">  <span class="kw">attr</span>(out, <span class="st">&quot;value&quot;</span>) &lt;-<span class="st"> </span><span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb39-21" title="21">  out</a>
<a class="sourceLine" id="cb39-22" title="22">}</a>
<a class="sourceLine" id="cb39-23" title="23"></a>
<a class="sourceLine" id="cb39-24" title="24"><span class="co"># we get the same</span></a>
<a class="sourceLine" id="cb39-25" title="25"><span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)<span class="op">$</span>par</a>
<a class="sourceLine" id="cb39-26" title="26"><span class="co">#&gt; [1] 1 1</span></a>
<a class="sourceLine" id="cb39-27" title="27"><span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn)            <span class="op">$</span>par</a>
<a class="sourceLine" id="cb39-28" title="28"><span class="co">#&gt; [1] 1 1</span></a>
<a class="sourceLine" id="cb39-29" title="29"></a>
<a class="sourceLine" id="cb39-30" title="30"><span class="co"># they run in about the same time</span></a>
<a class="sourceLine" id="cb39-31" title="31">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb39-32" title="32">  <span class="dt">optim     =</span> <span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </a>
<a class="sourceLine" id="cb39-33" title="33">  <span class="dt">psqn_bfgs =</span> <span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn), </a>
<a class="sourceLine" id="cb39-34" title="34">  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="fl">.5</span>)</a>
<a class="sourceLine" id="cb39-35" title="35"><span class="co">#&gt; # A tibble: 2 × 6</span></a>
<a class="sourceLine" id="cb39-36" title="36"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb39-37" title="37"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb39-38" title="38"><span class="co">#&gt; 1 optim         135µs    145µs     6755.      384B     14.6</span></a>
<a class="sourceLine" id="cb39-39" title="39"><span class="co">#&gt; 2 psqn_bfgs     100µs    104µs     9266.    2.49KB     16.7</span></a></code></pre></div>
</div>
<div id="bfgs-and-partially-separable-quasi-newton" class="section level3">
<h3>BFGS and Partially Separable Quasi-Newton</h3>
<p>Below we show the ratio of flops required in the matrix-vector product in a BFGS method relative to the flops required in the matrix-vector product for the conjugate gradient method for the quasi-Newton method:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" title="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">n =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">8</span><span class="op">:</span><span class="dv">13</span>), <span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>))</a>
<a class="sourceLine" id="cb40-2" title="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb40-3" title="3">  flops_qsn &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q) <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb40-4" title="4">  flops_bfgs &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>(q <span class="op">*</span><span class="st"> </span>n <span class="op">+</span><span class="st"> </span>p)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb40-5" title="5">  ratio &lt;-<span class="st"> </span>flops_bfgs <span class="op">/</span><span class="st"> </span>flops_qsn</a>
<a class="sourceLine" id="cb40-6" title="6">})</a>
<a class="sourceLine" id="cb40-7" title="7">nq &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q))</a>
<a class="sourceLine" id="cb40-8" title="8">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(vals<span class="op">$</span>n[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], </a>
<a class="sourceLine" id="cb40-9" title="9">           vals<span class="op">$</span>p[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], <span class="kw">floor</span>(vals[, <span class="st">&quot;ratio&quot;</span>]))</a>
<a class="sourceLine" id="cb40-10" title="10"></a>
<a class="sourceLine" id="cb40-11" title="11">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb40-12" title="12">  tvals, <span class="dt">ncol =</span> nq <span class="op">+</span><span class="st"> </span>2L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb40-13" title="13">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;n&quot;</span>, <span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb40-14" title="14">knitr<span class="op">::</span><span class="kw">kable</span>(vals)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">n</th>
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">256</td>
<td align="right">4</td>
<td align="right">57</td>
<td align="right">105</td>
<td align="right">156</td>
<td align="right">196</td>
<td align="right">223</td>
<td align="right">238</td>
<td align="right">247</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">4</td>
<td align="right">114</td>
<td align="right">210</td>
<td align="right">312</td>
<td align="right">393</td>
<td align="right">447</td>
<td align="right">477</td>
<td align="right">494</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">4</td>
<td align="right">228</td>
<td align="right">420</td>
<td align="right">624</td>
<td align="right">787</td>
<td align="right">894</td>
<td align="right">955</td>
<td align="right">988</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">4</td>
<td align="right">455</td>
<td align="right">840</td>
<td align="right">1248</td>
<td align="right">1574</td>
<td align="right">1787</td>
<td align="right">1911</td>
<td align="right">1977</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">4</td>
<td align="right">910</td>
<td align="right">1680</td>
<td align="right">2496</td>
<td align="right">3149</td>
<td align="right">3575</td>
<td align="right">3822</td>
<td align="right">3955</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">4</td>
<td align="right">1820</td>
<td align="right">3361</td>
<td align="right">4993</td>
<td align="right">6297</td>
<td align="right">7151</td>
<td align="right">7645</td>
<td align="right">7911</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">8</td>
<td align="right">26</td>
<td align="right">60</td>
<td align="right">109</td>
<td align="right">160</td>
<td align="right">199</td>
<td align="right">225</td>
<td align="right">239</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">8</td>
<td align="right">52</td>
<td align="right">120</td>
<td align="right">218</td>
<td align="right">320</td>
<td align="right">399</td>
<td align="right">450</td>
<td align="right">479</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">8</td>
<td align="right">105</td>
<td align="right">241</td>
<td align="right">437</td>
<td align="right">639</td>
<td align="right">798</td>
<td align="right">900</td>
<td align="right">959</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">8</td>
<td align="right">210</td>
<td align="right">482</td>
<td align="right">874</td>
<td align="right">1279</td>
<td align="right">1596</td>
<td align="right">1801</td>
<td align="right">1918</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">8</td>
<td align="right">420</td>
<td align="right">964</td>
<td align="right">1748</td>
<td align="right">2557</td>
<td align="right">3192</td>
<td align="right">3601</td>
<td align="right">3837</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">8</td>
<td align="right">840</td>
<td align="right">1928</td>
<td align="right">3495</td>
<td align="right">5115</td>
<td align="right">6384</td>
<td align="right">7203</td>
<td align="right">7674</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">16</td>
<td align="right">10</td>
<td align="right">27</td>
<td align="right">62</td>
<td align="right">111</td>
<td align="right">162</td>
<td align="right">201</td>
<td align="right">226</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">16</td>
<td align="right">19</td>
<td align="right">55</td>
<td align="right">124</td>
<td align="right">223</td>
<td align="right">323</td>
<td align="right">401</td>
<td align="right">451</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">16</td>
<td align="right">39</td>
<td align="right">109</td>
<td align="right">248</td>
<td align="right">446</td>
<td align="right">647</td>
<td align="right">803</td>
<td align="right">903</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">16</td>
<td align="right">78</td>
<td align="right">218</td>
<td align="right">496</td>
<td align="right">892</td>
<td align="right">1294</td>
<td align="right">1607</td>
<td align="right">1807</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">16</td>
<td align="right">156</td>
<td align="right">437</td>
<td align="right">993</td>
<td align="right">1783</td>
<td align="right">2589</td>
<td align="right">3214</td>
<td align="right">3615</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">16</td>
<td align="right">312</td>
<td align="right">874</td>
<td align="right">1986</td>
<td align="right">3567</td>
<td align="right">5178</td>
<td align="right">6428</td>
<td align="right">7230</td>
</tr>
</tbody>
</table>
<p>The</p>
<p><span class="math display">\[\frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}\]</span></p>
<p>ratio from the section called <a href="#conjugate-gradient-method">Conjugate Gradient Method</a> is shown below:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" title="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</a>
<a class="sourceLine" id="cb41-2" title="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb41-3" title="3">  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(p<span class="op">^</span><span class="dv">2</span>  <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb41-4" title="4">})</a>
<a class="sourceLine" id="cb41-5" title="5">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</a>
<a class="sourceLine" id="cb41-6" title="6"></a>
<a class="sourceLine" id="cb41-7" title="7">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb41-8" title="8">  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb41-9" title="9">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb41-10" title="10">knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.7901</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0002</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.040</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
</tr>
</tbody>
</table>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> term which gives us:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" title="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</a>
<a class="sourceLine" id="cb42-2" title="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb42-3" title="3">  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb42-4" title="4">})</a>
<a class="sourceLine" id="cb42-5" title="5">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb42-8" title="8">  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb42-9" title="9">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb42-10" title="10">knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.8000</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0078</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
</tr>
</tbody>
</table>
<p>This is implemented.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-nocedal06">
<p>Nocedal, Jorge, and Stephen Wright. 2006. <em>Numerical Optimization</em>. 2nd ed. Springer Science &amp; Business Media. <a href="https://doi.org/10.1007/978-0-387-40065-5">https://doi.org/10.1007/978-0-387-40065-5</a>.</p>
</div>
<div id="ref-Ormerod11">
<p>Ormerod, J. T. 2011. “Skew-Normal Variational Approximations for Bayesian Inference.” <em>Unpublished Article</em>.</p>
</div>
<div id="ref-Ormerod12">
<p>Ormerod, J. T., and M. P. Wand. 2012. “Gaussian Variational Approximate Inference for Generalized Linear Mixed Models.” <em>Journal of Computational and Graphical Statistics</em> 21 (1): 2–17. <a href="https://doi.org/10.1198/jcgs.2011.09118">https://doi.org/10.1198/jcgs.2011.09118</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
