<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>psqn: Partially Separable Quasi-Newton</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">psqn: Partially Separable Quasi-Newton</h1>



<style>
img {
    border: none;
}
</style>
<p><span class="math display">\[\renewcommand\vec{\boldsymbol}   \def\bigO#1{\mathcal{O}(#1)}   \def\Cond#1#2{\left(#1\,\middle|\, #2\right)}   \def\mat#1{\boldsymbol{#1}}   \def\der{{\mathop{}\!\mathrm{d}}}   \def\argmax{\text{arg}\,\text{max}}  \def\Prob{\text{P}}  \def\diag{\text{diag}}   \def\argmin{\text{arg}\,\text{min}}   \def\Expe{\text{E}}\]</span></p>
<p>This package provides an optimization method for <em>partially separable</em> functions. Partially separable functions are of the following form:</p>
<p><span class="math display">\[f(\vec x) = \sum_{i = 1}^n f_i(\vec x_{\mathcal I_i})\]</span></p>
<p>where <span class="math inline">\(\vec x\in \mathbb R^l\)</span>,</p>
<p><span class="math display">\[\vec x_{\mathcal I_i} =    (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top)\vec x, \qquad    \mathcal I_i = (j_{i1}, \dots, \mathcal j_{im_i}) \subseteq    \{1, \dots, l\},\]</span> and <span class="math inline">\(\vec e_k\)</span> is the <span class="math inline">\(k\)</span>’th column of the <span class="math inline">\(l\)</span> dimensional identity matrix. Each function <span class="math inline">\(f_i\)</span> is called an <em>element function</em> and only depends on <span class="math inline">\(m_i \ll l\)</span> parameters. This allows for an efficient quasi-Newton method when all the <span class="math inline">\(m_i\)</span>’s are much smaller than the dimension of the parameter vector <span class="math inline">\(\vec x\)</span>, <span class="math inline">\(l\)</span>. The framework can be extended to allow for a linear combination of parameters but we do not cover such problems. This vignette closely follows <span class="citation">Nocedal and Wright (2006)</span> who cover the methods and alternatives in much greater detail.</p>
<p>We first focus on a more restricted form of the problem. See the section called <a href="#generic-example">Generic Example</a> for the more general interface provided by this package. Assume that each index set <span class="math inline">\(\mathcal I_i\)</span> is of the form:</p>
<p><span class="math display">\[\begin{align*}   \mathcal I_i &amp;= \{1,\dots, p\} \cup \mathcal J_i \\   \mathcal J_i \cap \mathcal J_j &amp;= \emptyset \qquad j\neq i \\   \mathcal J_i \cap \{1,\dots, p\} &amp;= \emptyset \qquad \forall i = 1,\dots, n   \end{align*}.\]</span></p>
<p>That is, each index set contains <span class="math inline">\(p\)</span> <em>global parameters</em> and <span class="math inline">\(q_i = \lvert\mathcal J_i\rvert\)</span> <em>private parameters</em> which are particular for each element function, <span class="math inline">\(f_i\)</span>. For implementation reason, we let:</p>
<p><span class="math display">\[\begin{align*}   \overleftarrow q_i &amp;=    \begin{cases} p &amp; i = 0 \\ p + \sum_{k = 1}^i q_k &amp; i &gt; 0 \end{cases} \\   \mathcal J_i &amp;=    \{1 + \overleftarrow q_{i - 1}, \dots , q_i + \overleftarrow q_{i - 1}\}   \end{align*}\]</span></p>
<p>such that the element functions’ private parameters lies in consecutive parts of <span class="math inline">\(\vec x\)</span>.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<p>We are going to consider a Taylor approximation for a generalized linear mixed model. In particular, we focus on a mixed logit regression where:</p>
<p><span class="math display">\[\begin{align*}   \vec U_i &amp;\sim N^{(r)}(\vec 0, \mat\Sigma) \\   \vec\eta_i &amp;= \mat X_i\vec\beta + \mat Z_i\vec U_i \\   Y_{ij} &amp;\sim \text{Bin}(\text{logit}^{-1}(\eta_{ij}), 1),    \qquad j = 1, \dots, t_i   \end{align*}\]</span></p>
<p>where <span class="math inline">\(N^{(r)}(\vec\mu,\mat\Sigma)\)</span> means a <span class="math inline">\(r\)</span>-dimensional a multivariate normal distribution with mean <span class="math inline">\(\vec\mu\)</span> and covariance matrix <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\text{Bin}(p, k)\)</span> means a binomial distribution probability <span class="math inline">\(p\)</span> and size <span class="math inline">\(k\)</span>. <span class="math inline">\(\vec U_i\)</span> is an unknown random effect with an unknown covariance <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\vec\beta\in\mathbb{R}^p\)</span> are unknown fixed effect coefficients. <span class="math inline">\(\mat X_i\)</span> and <span class="math inline">\(\mat Z_i\)</span> are known design matrices each with <span class="math inline">\(t_i\)</span> rows for each of the <span class="math inline">\(t_i\)</span> observed outcomes, the <span class="math inline">\(y_{ij}\)</span>s.</p>
<p>As part of a Taylor approximation, we find a mode of <span class="math inline">\(\vec x = (\vec\beta^\top, \widehat{\vec u}_1^\top, \dots, \widehat{\vec u}_n^\top)\)</span> of the log of the integrand given a covariance matrix estimate, <span class="math inline">\(\widehat{\mat \Sigma}\)</span>. That is, we are minimizing:</p>
<p><span class="math display">\[\begin{align*}   f(\vec x) &amp;= -\sum_{i = 1}^n \left(     \sum_{k = 1}^{t_i}(y_{ij}\eta_{ij} - \log(1 + \exp\eta_{ij}))     - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= -\sum_{i = 1}^n \left(     \vec y_i(\mat X_i\vec\beta + \mat Z_i\widehat{\vec u}_i)     - \sum_{k = 1}^{t_i}     \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\widehat{\vec u}_i))   - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= \sum_{i = 1}^nf_i((\vec\beta^\top, \widehat{\vec u}_i^\top)^\top) \\   f_i((\vec\beta^\top, \vec u^\top)^\top) &amp;=    -\vec y_i(\mat X_i\vec\beta + \mat Z_i\vec u)     + \sum_{k = 1}^{t_i}   \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\vec u))   + \frac 12 \vec u^\top\widehat{\mat \Sigma}^{-1} \vec u   \end{align*}\]</span></p>
<p>In this problem, <span class="math inline">\(\vec\beta\)</span> are the global parameters and the <span class="math inline">\(\widehat{\vec u}_i\)</span>’s are the private parameters. Thus, <span class="math inline">\(l = p + nr\)</span>. We will later return to this example with an implementation which uses this package.</p>
<div id="variational-approximations" class="section level3">
<h3>Variational Approximations</h3>
<p>The objective function for variational approximations for mixed models for clustered data is commonly also partially separable. We will briefly summarize the idea here. <span class="citation">Ormerod and Wand (2012)</span> and <span class="citation">Ormerod (2011)</span> are examples where one might benefit from using the methods in this package.</p>
<p>We let <span class="math inline">\(\tilde f_i\)</span> be the log marginal likelihood term from cluster <span class="math inline">\(i\)</span>. This is of the form:</p>
<p><span class="math display">\[
\tilde f_i(\vec\omega) = \log \int p_i(\vec y_i, \vec u;\vec\omega)\der \vec u 
\]</span></p>
<p>where <span class="math inline">\(\vec\omega\)</span> are unknown model parameters, <span class="math inline">\(p_i(\vec u;\vec\omega)\)</span> is the joint density of the observed data denoted by <span class="math inline">\(\vec y_i\)</span>, and <span class="math inline">\(\vec U_i\)</span> which is a cluster specific random effect. <span class="math inline">\(\exp \tilde f_i(\vec\omega)\)</span> is often intractable. An approximation of <span class="math inline">\(\tilde f_i\)</span> is to select some variational distribution denoted by <span class="math inline">\(v_i\)</span> parameterized by some set <span class="math inline">\(\Theta_i\)</span>. We then use the approximation:</p>
<p><span class="math display">\[
\begin{align*}
\tilde f_i(\vec\omega) &amp;= \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i \vec u;\vec\omega)/v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u_i \mid \vec y_i;\vec\omega)/v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u \\
  &amp;= 
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u
  + \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)}
  \right)\der\vec u \\
&amp;\geq
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u = f_i(\vec\omega,\vec\theta_i)
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span> and <span class="math inline">\(p_i(\vec u_i \mid \vec y_i;\vec\omega)\)</span> is the conditional density of the random effect given the observed data, <span class="math inline">\(\vec y_i\)</span>, and model parameters, <span class="math inline">\(\vec\omega\)</span>. <span class="math inline">\(f_i(\vec\omega,\vec\theta_i)\)</span> is a lower bound since the Kullback–Leibler divergence</p>
<p><span class="math display">\[
\int v_i(\vec u; \vec\theta_i)\log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)} 
  \right)\der\vec u
\]</span></p>
<p>is positive. The idea is to replace the minimization problem:</p>
<p><span class="math display">\[
\argmin_{\vec\omega} -\sum_{i = 1}^n \tilde f_i(\vec\omega)
\]</span></p>
<p>with a variational approximation:</p>
<p><span class="math display">\[
\argmin_{\vec\omega,\vec\theta_1,\dots,\vec\theta_n} 
  -\sum_{i = 1}^n f_i(\vec\omega,\vec\theta_i)
\]</span></p>
<p>This problem fits into the framework in the package where <span class="math inline">\(\vec\omega\)</span> are the global parameters and the <span class="math inline">\(\vec\theta_i\)</span>s are the private parameters.</p>
<p>Variational approximation have the property that if <span class="math inline">\(v_i(\vec u; \vec\theta_i) = p_i(\vec u \mid \vec y_i;\vec\omega)\)</span> then the Kullback–Leibler divergence is zero and the lower bound is equal to the log marginal likelihood. Thus, we need to use a family of variational distributions, <span class="math inline">\(v_i\)</span>, which yields a close approximation of the conditional density of the random effects, <span class="math inline">\(p_i(\vec u \mid \vec y_i;\vec\omega)\)</span>, for some <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span>. Moreover, the lower bound also needs to be easy to optimize. Variational approximations have an advantage that given estimates of <span class="math inline">\(\widehat{\vec\omega},\widehat{\vec\theta}_1,\dots,\widehat{\vec\theta}_n\)</span> then subsequent inference can be approximated using:</p>
<p><span class="math display">\[
\Expe\left(h(\vec U_i)\right) =
  \int h(\vec u) p_i(\vec u \mid \vec y_i;\vec\omega)\der\vec u 
  \approx 
  \int h(\vec u) v_i(\vec u; \widehat{\vec\theta}_i)\der\vec u.
\]</span></p>
<p>The latter integral may be much easier to work with for some functions <span class="math inline">\(h\)</span> and variational distribution, <span class="math inline">\(v_i\)</span>.</p>
</div>
</div>
<div id="quasi-newton-method-for-partially-separable-functions" class="section level2">
<h2>Quasi-Newton Method for Partially Separable Functions</h2>
<p>We are going to assume some prior knowledge of Newton’s method and the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm and we only provide a few details of these methods. However, will need a bit of notations from these methods to motivate the quasi-Newton method we have implemented.</p>
<p>Newton’s method to minimize a function is to start at some value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 1\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\nabla^2 f(\vec x_{k - 1})\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \vec p_k\)</span> or <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \gamma\vec p_k\)</span> for <span class="math inline">\(\gamma \in (0, 1]\)</span> set to satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>, and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>Computing the Hessian, <span class="math inline">\(\nabla^2 f(\vec x_{k - 1})\)</span>, at every iteration can be expensive. The BFGS algorithm offers an alternative where we use an approximation instead. Here we start with some Hessian approximation <span class="math inline">\(\mat B_0\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>find a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>, <span class="math inline">\(\vec s_k = \alpha\vec p_k = \vec x_k - \vec x_{k - 1}\)</span>, <span class="math inline">\(\vec d_k = \nabla f(\vec x_k) - \nabla f(\vec x_{k - 1})\)</span>,</li>
<li>perform a rank-two update <span class="math display">\[\mat B_k = \mat B_{k - 1} + \frac{\vec y_k\vec y_k^\top}{\vec y_k^\top\vec s_k} - \frac{\mat B_{k - 1}\vec s_k\vec s_k^\top\mat B_{k - 1}^\top}{\vec s_k^\top\mat B_{k - 1}\vec s_k},\]</span> and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This reduces the cost of computing the Hessian. Further, we can update <span class="math inline">\(\mat B_k^{-1}\)</span> to avoid solving <span class="math inline">\(\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1})\)</span>. The matrix <span class="math inline">\(\mat B_k^{-1}\)</span> will still be large and dense when <span class="math inline">\(l\)</span> is large.</p>
<div id="using-partial-separability" class="section level3">
<h3>Using Partial Separability</h3>
<p>As an alternative, we can exploit the structure of the problem we are solving. Let</p>
<p><span class="math display">\[\mat H_i = (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top).\]</span></p>
<p>The true Hessian in our case is sparse and given by</p>
<p><span class="math display">\[\nabla^2 f(\vec x) = \sum_{i = 1}^n    \mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\]</span></p>
<p>Notice that each <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> is only a <span class="math inline">\((p + q_i)\times (p + q_i)\)</span> matrix. We illustrate this below with <span class="math inline">\(n = 10\)</span> element functions. Each plot is <span class="math inline">\(\mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\)</span> where black entries are a non-zero.</p>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The whole Hessian is:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAD1BMVEUAAAAaGhoiIiJFRUX////5cEo+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgUlEQVR4nO3QQY6CABBFQRTvf2Z3jAHCUzPDINbbd+enhps2G/57wNEDFAGKAEWAIkARoAhQ9AM0XjU1rgBdBk1dAG0HKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQNHLQLcvC1AEKAIUAYoARYAiQBGgCFAEKAIUPQX0eLCFd0ZBQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYCil4Gyk1kBigBFgCJAEaAIUAQoAhQBigBFvw/00PzPJ4oBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhT9KdCihdjxCQFFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBF+wJ1hxMDFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6GtCihdjOuwBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJA0eGBttpjJ6AIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgKKPBpo33/1E+RNQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6FdAbpSAgQJsBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUPQW0HjV1LgCpNUARYAiQBGgCFAEKAIUAYrup18JmeoS7cYAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>We can use the partial separability to implement a BFGS method where we make <span class="math inline">\(n\)</span> BFGS approximations, one for each element function, <span class="math inline">\(f_i\)</span>. Let <span class="math inline">\(\mat B_{ki}\)</span> be the approximation of <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> at iteration <span class="math inline">\(k\)</span>. Then the method we have implemented starts with <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span> and</p>
<ol style="list-style-type: decimal">
<li>computes a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>finds a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>sets <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>,</li>
<li>performs BFGS updates for each <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span>, and</li>
<li>repeats with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This seems as if it is going to be much slower as we are solving a large linear system if <span class="math inline">\(l\)</span> is large. However, we can use the conjugate gradient method we describe in the next section. This will be fast if we can perform the following matrix-vector product fast:</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec z.\]</span></p>
<p>To elaborate on this, each <span class="math inline">\(\mat H_i^\top\mat B_{k - 1,i}\mat H_i\vec z\)</span> consists of matrix-vector product with a <span class="math inline">\(o_i \times o_i\)</span> symmetric matrix and a vector where <span class="math inline">\(o_i = (p + q_i)\)</span>. This can be done in <span class="math inline">\(2o_i(o_i + 1)\)</span> flops. Thus, the total cost is <span class="math inline">\(2\sum_{i = 1}^n o_i(o_i + 1)\)</span> flops. This is in contrast to the original <span class="math inline">\(2l(l + 1)\)</span> flops with the BFGS method.</p>
<p>As an example suppose that <span class="math inline">\(q_i = 5\)</span> for all <span class="math inline">\(n\)</span> element functions, <span class="math inline">\(n = 5000\)</span>, and <span class="math inline">\(p = 10\)</span>. Then <span class="math inline">\(o_i = 15\)</span> and the matrix-vector product above requires <span class="math inline">\(2\cdot 5000 \cdot 15(15 + 1) = 2400000\)</span> flops. In contrast <span class="math inline">\(l = 5000 \cdot 5 + 10 = 25010\)</span> and the matrix-vector product in the BFGS method requires <span class="math inline">\(2\cdot 25010 (25010 + 1) = 1251050220\)</span> flops. That is 521 times more flops. Similar ratios are shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>More formerly, the former is <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2) = \mathcal O(np^2 + np\bar q + \sum_{i = 1}^nq_i^2)\)</span> where <span class="math inline">\(\bar q = \sum_{i = 1}^n q_i / n\)</span> whereas the matrix-vector product in the BFGS method is <span class="math inline">\(\mathcal O((p + n\bar q)^2) = \mathcal O(p^2 + pn\bar q + (n\bar q)^2)\)</span>. Thus, the former is favorable as long as <span class="math inline">\(np^2 + \sum_{i = 1}^nq_i^2\)</span> is small compared with <span class="math inline">\((n\bar q)^2\)</span>. Furthermore, the rank-two BFGS updates are cheaper and may converge faster to a good approximation. However, we should keep in mind that the original BFGS method yields an approximation of <span class="math inline">\(\mat B_k^{-1}\)</span>. Thus, we do not need to solve a linear system. However, we may not need to take many conjugate gradient iterations to get a good approximation with the implemented quasi-Newton method.</p>
</div>
</div>
<div id="conjugate-gradient-method" class="section level2">
<h2>Conjugate Gradient Method</h2>
<p>The conjugate gradient method we use solves</p>
<p><span class="math display">\[\mat A\vec b = \vec v\]</span></p>
<p>which in our quasi-Newton method is</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1})\]</span></p>
<p>We start of with some initial value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 0\)</span>, <span class="math inline">\(\vec r_0 = \mat A\vec x_0 - \vec v\)</span>, <span class="math inline">\(\vec p_0 = -\vec r_0\)</span>, and:</p>
<ol style="list-style-type: decimal">
<li>find the step length <span class="math display">\[\alpha_k = \frac{\vec r_k^\top\vec r_k}{\vec p_k^\top\mat A\vec p_k},\]</span></li>
<li>find the new value <span class="math display">\[\vec x_{k + 1} = \vec x_k + \alpha_k\vec p_k,\]</span></li>
<li>find the new residual <span class="math display">\[\vec r_{k + 1} = \vec r_k + \alpha_k\mat A\vec p_k,\]</span></li>
<li>set <span class="math inline">\(\beta_{k + 1} = (\vec r_k^\top\vec r_k)^{-1}\vec r_{k + 1}^\top\vec r_{k + 1}\)</span>,</li>
<li>set the new search direction to <span class="math display">\[\vec p_{k + 1} = - \vec r_{k + 1} + \beta_{k + 1}\vec p_k,\]</span> and</li>
<li>stop if <span class="math inline">\(\vec r_{k + 1}^\top\vec r_{k + 1}\)</span> is smaller. Otherwise set <span class="math inline">\(k\leftarrow k + 1\)</span> and repeat.</li>
</ol>
<p>The main issue is the matrix-vector product <span class="math inline">\(\mat A\vec p_k\)</span> but as we argued in the previous section that this can be computed in <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2)\)</span> time. The conjugate gradient method will at most take <span class="math inline">\(h\)</span> iterations where <span class="math inline">\(h\)</span> is the number of rows and columns of <span class="math inline">\(\mat A\)</span>. Moreover, if <span class="math inline">\(\mat A\)</span> only has <span class="math inline">\(r &lt; h\)</span> distinct eigenvalues then we will at most make <span class="math inline">\(r\)</span> conjugate gradient iterations. Lastly, if <span class="math inline">\(\mat A\)</span> has clusters of eigenvalues then we may expect to perform only a number of iterations close to the number of distinct clusters.</p>
<p>In practice, we terminate the conjugate gradient method when <span class="math inline">\(\lVert\vec r_k\rVert &lt; \min (c, \sqrt{\lVert\nabla f(\vec x_{k -1})\rVert})\lVert\nabla f(\vec x_{k -1})\rVert\)</span> where <span class="math inline">\(c\)</span> is a constant the user can set. Moreover, we the package supports diagonal preconditioning or incomplete Cholesky factorization preconditioning The diagonal preconditioning is very cheap and may reduce the number of required conjugate gradient iterations. The incomplete Cholesky factorization preconditioning is from Eigen and may greatly reduce the number of required conjugate gradient iterations at the cost of having to factorize the Hessian approximation.</p>
<p>We can compare the flops of the matrix product in BFGS with applying the conjugate gradient method. Assume that all <span class="math inline">\(q_i\)</span>s are almost <span class="math inline">\(\bar q\)</span>. Then the ratio of flops is approximately:</p>
<p><span class="math display">\[
\frac{p^2 + 2pn\bar q + (n\bar q)^2}
     {n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
\]</span></p>
<p>where <span class="math inline">\(n_{\text{cg}}\)</span> is the number of conjugate gradient iterations. Thus, to get something which is linear in the number of element functions, <span class="math inline">\(n\)</span>, then we must have that:</p>
<p><span class="math display">\[
\begin{align*}
\frac{n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
     {p^2 + 2pn\bar q + (n\bar q)^2} &amp;\leq \frac kn \\
\Leftrightarrow n_{\text{cg}} &amp;\leq \frac kn
  \frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {np^2 + 2pn\bar q + n\bar q^2} \\
&amp;= k\frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {n^2(p^2 + 2p\bar q + \bar q^2)} \\
&amp;\approx k 
  \frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is some fixed constant with <span class="math inline">\(k &lt; n\)</span>. An example of the latter ratio is shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> in the denominator by once computing the first <span class="math inline">\(p\times p\)</span> part of the Hessian approximation prior to performing the conjugate gradient method. This is implemented. The <code>max_cg</code> argument is added because of the considerations above.</p>
</div>
<div id="line-search-and-wolfe-condition" class="section level2">
<h2>Line Search and Wolfe Condition</h2>
<p>We use line search and search for a point which satisfy <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">the strong Wolfe condition</a> by default. The constants in the Wolfe condition can be set by the user. The line search is implemented as described by <span class="citation">Nocedal and Wright (2006)</span> with cubic interpolation in the zoom phase.</p>
</div>
<div id="symmetric-rank-one-updates" class="section level2">
<h2>Symmetric Rank-one Updates</h2>
<p><a href="https://en.wikipedia.org/wiki/Symmetric_rank-one">Symmetric rank-one (SR1)</a> updates are implemented as an alternative to the BFGS updates. The user can set whether the SR1 updates should be used. The SR1 updates do not guarantee that the Hessian approximation is positive definite. Thus, the conjugate gradient method only proceeds if <span class="math inline">\(\vec p_k^\top\mat A\vec p_k &gt; 0\)</span>. That is, if the new direction is a descent direction.</p>
</div>
<div id="example-using-the-implementation" class="section level2">
<h2>Example Using the Implementation</h2>
<p>We simulate a data set below from the mixed logit model we showed earlier.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># assign model parameters, number of random effects, and fixed effects</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>q &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># number of private parameters per cluster</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>p &lt;-<span class="st"> </span><span class="dv">5</span> <span class="co"># number of global parameters</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>beta &lt;-<span class="st"> </span><span class="kw">sqrt</span>((<span class="dv">1</span><span class="op">:</span>p) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(<span class="dv">1</span><span class="op">:</span>p))</span>
<span id="cb1-5"><a href="#cb1-5"></a>Sigma &lt;-<span class="st"> </span><span class="kw">diag</span>(q)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># simulate a data set</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>n_clusters &lt;-<span class="st"> </span>800L <span class="co"># number of clusters</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">set.seed</span>(<span class="dv">66608927</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>sim_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</span>
<span id="cb1-12"><a href="#cb1-12"></a>  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(20L, 1L) <span class="op">+</span><span class="st"> </span>2L</span>
<span id="cb1-13"><a href="#cb1-13"></a>  X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(p <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)), </span>
<span id="cb1-14"><a href="#cb1-14"></a>              p)</span>
<span id="cb1-15"><a href="#cb1-15"></a>  u &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">rnorm</span>(q) <span class="op">%*%</span><span class="st"> </span><span class="kw">chol</span>(Sigma))</span>
<span id="cb1-16"><a href="#cb1-16"></a>  Z &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(q <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q)), </span>
<span id="cb1-17"><a href="#cb1-17"></a>              q)</span>
<span id="cb1-18"><a href="#cb1-18"></a>  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</span>
<span id="cb1-19"><a href="#cb1-19"></a>  y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>((<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>eta))<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">&gt;</span><span class="st"> </span><span class="kw">runif</span>(n_members))</span>
<span id="cb1-20"><a href="#cb1-20"></a>  </span>
<span id="cb1-21"><a href="#cb1-21"></a>  <span class="kw">list</span>(<span class="dt">X =</span> X, <span class="dt">Z =</span> Z, <span class="dt">y =</span> y, <span class="dt">u =</span> u, <span class="dt">Sigma_inv =</span> <span class="kw">solve</span>(Sigma))</span>
<span id="cb1-22"><a href="#cb1-22"></a>}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co"># example of the first cluster</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>sim_dat[[1L]]</span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="co">#&gt; $X</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="co">#&gt;         [,1]   [,2]    [,3]</span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co">#&gt; [1,]  0.0416 -0.809 -0.1839</span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co">#&gt; [2,]  0.6524 -1.373 -0.9254</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="co">#&gt; [3,] -1.3339 -0.957 -0.8708</span></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co">#&gt; [4,]  0.7547 -0.156  0.0178</span></span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="co">#&gt; [5,]  0.7191 -0.681 -0.7232</span></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="co">#&gt; </span></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="co">#&gt; $Z</span></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="co">#&gt;        [,1]   [,2]   [,3]</span></span>
<span id="cb1-36"><a href="#cb1-36"></a><span class="co">#&gt; [1,]  0.167 -0.483 -0.785</span></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="co">#&gt; [2,] -0.266 -0.823  0.794</span></span>
<span id="cb1-38"><a href="#cb1-38"></a><span class="co">#&gt; [3,]  0.609 -0.549  0.269</span></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="co">#&gt; [4,] -0.414 -0.457  0.605</span></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="co">#&gt; </span></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="co">#&gt; $y</span></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="co">#&gt; [1] 0 0 0</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="co">#&gt; </span></span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="co">#&gt; $u</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="co">#&gt; [1]  0.0705 -1.7285  0.1538 -0.3245</span></span>
<span id="cb1-46"><a href="#cb1-46"></a><span class="co">#&gt; </span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="co">#&gt; $Sigma_inv</span></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="co">#&gt; [1,]    1    0    0    0</span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="co">#&gt; [2,]    0    1    0    0</span></span>
<span id="cb1-51"><a href="#cb1-51"></a><span class="co">#&gt; [3,]    0    0    1    0</span></span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="co">#&gt; [4,]    0    0    0    1</span></span></code></pre></div>
<p>The combined vector with global and private parameters can be created like this (it is a misnoma to call this <code>true_params</code> as the modes of the random effects, the private parameters, should only match the random effects if the clusters are very large):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>true_params &lt;-<span class="st"> </span><span class="kw">c</span>(beta, <span class="kw">sapply</span>(sim_dat, <span class="cf">function</span>(x) x<span class="op">$</span>u))</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># global parameters</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>true_params[<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt; [1] 0.258 0.365 0.447 0.516 0.577</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co"># some of the private parameters</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>true_params[<span class="dv">1</span><span class="op">:</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>q) <span class="op">+</span><span class="st"> </span>p]</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">#&gt;  [1]  0.0705 -1.7285  0.1538 -0.3245  0.2516 -0.5419 -0.5537 -0.2805 -1.1777</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">#&gt; [10] -1.7539  1.7338  0.5616 -0.8379  1.2412 -1.2046  1.4547</span></span></code></pre></div>
<p>As a reference, we will create the following function to evaluate the log of the integrand:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>eval_integrand &lt;-<span class="st"> </span><span class="cf">function</span>(par){</span>
<span id="cb3-2"><a href="#cb3-2"></a>  out &lt;-<span class="st"> </span><span class="fl">0.</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  inc &lt;-<span class="st"> </span>p</span>
<span id="cb3-4"><a href="#cb3-4"></a>  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</span>
<span id="cb3-6"><a href="#cb3-6"></a>    dat &lt;-<span class="st"> </span>sim_dat[[i]]</span>
<span id="cb3-7"><a href="#cb3-7"></a>    X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</span>
<span id="cb3-8"><a href="#cb3-8"></a>    Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</span>
<span id="cb3-9"><a href="#cb3-9"></a>    y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</span>
<span id="cb3-10"><a href="#cb3-10"></a>    Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</span>
<span id="cb3-11"><a href="#cb3-11"></a>    </span>
<span id="cb3-12"><a href="#cb3-12"></a>    u &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>inc]</span>
<span id="cb3-13"><a href="#cb3-13"></a>    inc &lt;-<span class="st"> </span>inc <span class="op">+</span><span class="st"> </span>q</span>
<span id="cb3-14"><a href="#cb3-14"></a>    eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</span>
<span id="cb3-15"><a href="#cb3-15"></a>    </span>
<span id="cb3-16"><a href="#cb3-16"></a>    out &lt;-<span class="st"> </span>out <span class="op">-</span><span class="st"> </span><span class="kw">drop</span>(y <span class="op">%*%</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta))) <span class="op">+</span><span class="st"> </span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="st">      </span><span class="fl">.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(u <span class="op">%*%</span><span class="st"> </span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>u)</span>
<span id="cb3-18"><a href="#cb3-18"></a>  }</span>
<span id="cb3-19"><a href="#cb3-19"></a>  </span>
<span id="cb3-20"><a href="#cb3-20"></a>  out</span>
<span id="cb3-21"><a href="#cb3-21"></a>}</span>
<span id="cb3-22"><a href="#cb3-22"></a></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="co"># check the log integrand at true global parameters and the random effects</span></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="kw">eval_integrand</span>(true_params)</span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="co">#&gt; [1] 6898</span></span></code></pre></div>
<p>We will use this function to compare with our C++ implementation.</p>
<div id="r-implementation" class="section level3">
<h3>R Implementation</h3>
<p>A R function which we need to pass to <code>psqn</code> to minimize the partially separable function is given below:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># evaluates the negative log integrand. </span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"># </span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"># Args:</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#   i cluster/element function index. </span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#   par the global and private parameter for this cluster. It has length </span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#       zero if the number of parameters is requested.</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#   comp_grad logical for whether to compute the gradient. </span></span>
<span id="cb4-8"><a href="#cb4-8"></a>r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</span>
<span id="cb4-9"><a href="#cb4-9"></a>  dat &lt;-<span class="st"> </span>sim_dat[[i]]</span>
<span id="cb4-10"><a href="#cb4-10"></a>  X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</span>
<span id="cb4-11"><a href="#cb4-11"></a>  Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</span>
<span id="cb4-12"><a href="#cb4-12"></a>  </span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="co"># requested the dimension of the parameter</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>X), <span class="dt">private_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>Z)))</span>
<span id="cb4-16"><a href="#cb4-16"></a>  </span>
<span id="cb4-17"><a href="#cb4-17"></a>  y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</span>
<span id="cb4-18"><a href="#cb4-18"></a>  Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</span>
<span id="cb4-19"><a href="#cb4-19"></a>  </span>
<span id="cb4-20"><a href="#cb4-20"></a>  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb4-21"><a href="#cb4-21"></a>  uhat &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</span>
<span id="cb4-22"><a href="#cb4-22"></a>  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>uhat <span class="op">%*%</span><span class="st"> </span>Z)</span>
<span id="cb4-23"><a href="#cb4-23"></a>  exp_eta &lt;-<span class="st"> </span><span class="kw">exp</span>(eta)</span>
<span id="cb4-24"><a href="#cb4-24"></a>  </span>
<span id="cb4-25"><a href="#cb4-25"></a>  out &lt;-<span class="st"> </span><span class="op">-</span><span class="kw">sum</span>(y <span class="op">*</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="st">    </span><span class="kw">sum</span>(uhat <span class="op">*</span><span class="st"> </span>(Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)) <span class="op">/</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>  <span class="cf">if</span>(comp_grad){</span>
<span id="cb4-28"><a href="#cb4-28"></a>    d_eta &lt;-<span class="st"> </span><span class="op">-</span>y <span class="op">+</span><span class="st"> </span>exp_eta <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)</span>
<span id="cb4-29"><a href="#cb4-29"></a>    grad &lt;-<span class="st"> </span><span class="kw">c</span>(X <span class="op">%*%</span><span class="st"> </span>d_eta, </span>
<span id="cb4-30"><a href="#cb4-30"></a>              Z <span class="op">%*%</span><span class="st"> </span>d_eta <span class="op">+</span><span class="st"> </span>dat<span class="op">$</span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)</span>
<span id="cb4-31"><a href="#cb4-31"></a>    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</span>
<span id="cb4-32"><a href="#cb4-32"></a>  }</span>
<span id="cb4-33"><a href="#cb4-33"></a>  </span>
<span id="cb4-34"><a href="#cb4-34"></a>  out</span>
<span id="cb4-35"><a href="#cb4-35"></a>}</span></code></pre></div>
<p>Here is a check that the above yields the same as the function we defined before:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># check the function</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>r_func_val &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span>n_clusters, <span class="cf">function</span>(i)</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">FALSE</span>)))</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">all.equal</span>(<span class="kw">eval_integrand</span>(true_params), r_func_val)</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co"># we could check the gradient like this</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="cf">if</span>(<span class="ot">FALSE</span>){</span>
<span id="cb5-9"><a href="#cb5-9"></a>  r_func_gr &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(true_params))</span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</span>
<span id="cb5-11"><a href="#cb5-11"></a>    out_i &lt;-<span class="st"> </span><span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">TRUE</span>)</span>
<span id="cb5-12"><a href="#cb5-12"></a>    r_func_gr[<span class="dv">1</span><span class="op">:</span>p] &lt;-<span class="st"> </span>r_func_gr[<span class="dv">1</span><span class="op">:</span>p] <span class="op">+</span><span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb5-13"><a href="#cb5-13"></a>    r_func_gr[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p] &lt;-<span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</span>
<span id="cb5-14"><a href="#cb5-14"></a>  }</span>
<span id="cb5-15"><a href="#cb5-15"></a>  </span>
<span id="cb5-16"><a href="#cb5-16"></a>  <span class="kw">library</span>(numDeriv)</span>
<span id="cb5-17"><a href="#cb5-17"></a>  gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(<span class="cf">function</span>(par) <span class="kw">eval_integrand</span>(par), true_params)</span>
<span id="cb5-18"><a href="#cb5-18"></a>  <span class="kw">all.equal</span>(r_func_gr, gr_num, <span class="dt">tolerance =</span> <span class="fl">1e-6</span>)</span>
<span id="cb5-19"><a href="#cb5-19"></a>}</span></code></pre></div>
<p>The partially separable function can be minimized like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>start_val &lt;-<span class="st"> </span>true_params </span>
<span id="cb6-2"><a href="#cb6-2"></a>start_val[  <span class="dv">1</span><span class="op">:</span>p ] &lt;-<span class="st"> </span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">  </span>start_val[  <span class="dv">1</span><span class="op">:</span>p ] <span class="op">+</span><span class="st"> </span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="st">  </span><span class="kw">c</span>(<span class="fl">0.49</span>, <span class="fl">-0.63</span>, <span class="fl">-0.4</span>, <span class="fl">-0.33</span>, <span class="fl">-0.38</span>) <span class="co"># ~rnorm(length(beta), sd = .5)</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>start_val[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span>p)] &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">library</span>(psqn)</span>
<span id="cb6-8"><a href="#cb6-8"></a>r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </span>
<span id="cb6-9"><a href="#cb6-9"></a>                        <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">pre_method =</span> 1L)</span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </span>
<span id="cb6-11"><a href="#cb6-11"></a>       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">pre_method =</span> pre_method)</span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a>R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(start_val)</span></code></pre></div>
<p>We will later compare this with the result from the C++ implementation which we provide in the next section.</p>
</div>
<div id="c-implementation" class="section level3">
<h3>C++ Implementation</h3>
<p>We provide a C++ implementation with the package as an example of how to use this package. The location of the implementation can be found by calling <code>system.file(&quot;mlogit-ex.cpp&quot;, package = &quot;psqn&quot;)</code>. The most important part of the implementation is the problem specific <code>m_logit_func</code> class, the <code>get_mlogit_optimizer</code> function, and the <code>optim_mlogit</code> function which are needed to perform the optimization. The content of the file is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">// we will use OpenMP to perform the computation in parallel</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">// we use RcppArmadillo to simplify the code</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">// we change the unsigned integer type that is used by the package by defining</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co">// the PSQN_SIZE_T macro variable</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="pp">#define PSQN_SIZE_T </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">int</span></span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">// we want to use the incomplete Cholesky factorization as the preconditioner</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="co">// and therefore with need RcppEigen</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="pp">#define PSQN_USE_EIGEN</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co">// [[Rcpp::depends(RcppEigen)]]</span></span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="co">// [[Rcpp::depends(psqn)]]</span></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="pp">#include </span><span class="im">&quot;psqn-Rcpp-wrapper.h&quot;</span></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></span>
<span id="cb7-23"><a href="#cb7-23"></a></span>
<span id="cb7-24"><a href="#cb7-24"></a><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></span>
<span id="cb7-25"><a href="#cb7-25"></a><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, psqn_uint <span class="at">const</span> n_ele){</span>
<span id="cb7-26"><a href="#cb7-26"></a>  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</span>
<span id="cb7-27"><a href="#cb7-27"></a>}</span>
<span id="cb7-28"><a href="#cb7-28"></a></span>
<span id="cb7-29"><a href="#cb7-29"></a><span class="co">/***</span></span>
<span id="cb7-30"><a href="#cb7-30"></a><span class="co"> implements the element function for a given cluster. The class must provide</span></span>
<span id="cb7-31"><a href="#cb7-31"></a><span class="co"> the member functions which we provide here.</span></span>
<span id="cb7-32"><a href="#cb7-32"></a></span>
<span id="cb7-33"><a href="#cb7-33"></a><span class="co"> We do not need to inherit from the element_function class but we can do it</span></span>
<span id="cb7-34"><a href="#cb7-34"></a><span class="co"> to ensure that we have implemented all the member functions.</span></span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="co"> */</span></span>
<span id="cb7-36"><a href="#cb7-36"></a><span class="kw">class</span> <span class="va">m_logit_func</span> <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</span>
<span id="cb7-37"><a href="#cb7-37"></a>  <span class="co">/// design matrices</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>  arma::mat <span class="at">const</span> X, Z;</span>
<span id="cb7-39"><a href="#cb7-39"></a>  <span class="co">/// outcomes</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>  arma::vec <span class="at">const</span> y;</span>
<span id="cb7-41"><a href="#cb7-41"></a>  <span class="co">/// inverse covariance matrix</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>  arma::mat <span class="at">const</span> Sigma_inv;</span>
<span id="cb7-43"><a href="#cb7-43"></a></span>
<span id="cb7-44"><a href="#cb7-44"></a><span class="kw">public</span>:</span>
<span id="cb7-45"><a href="#cb7-45"></a>  <span class="va">m_logit_func</span>(List data):</span>
<span id="cb7-46"><a href="#cb7-46"></a>  X        (as&lt;arma::mat&gt;(data[<span class="st">&quot;X&quot;</span>        ])),</span>
<span id="cb7-47"><a href="#cb7-47"></a>  Z        (as&lt;arma::mat&gt;(data[<span class="st">&quot;Z&quot;</span>        ])),</span>
<span id="cb7-48"><a href="#cb7-48"></a>  y        (as&lt;arma::vec&gt;(data[<span class="st">&quot;y&quot;</span>        ])),</span>
<span id="cb7-49"><a href="#cb7-49"></a>  Sigma_inv(as&lt;arma::mat&gt;(data[<span class="st">&quot;Sigma_inv&quot;</span>])) { }</span>
<span id="cb7-50"><a href="#cb7-50"></a></span>
<span id="cb7-51"><a href="#cb7-51"></a>  <span class="co">/// dimension of the global parameters</span></span>
<span id="cb7-52"><a href="#cb7-52"></a>  psqn_uint global_dim() <span class="at">const</span> {</span>
<span id="cb7-53"><a href="#cb7-53"></a>    <span class="cf">return</span> X.n_rows;</span>
<span id="cb7-54"><a href="#cb7-54"></a>  }</span>
<span id="cb7-55"><a href="#cb7-55"></a>  <span class="co">/// dimension of the private parameters</span></span>
<span id="cb7-56"><a href="#cb7-56"></a>  psqn_uint private_dim() <span class="at">const</span> {</span>
<span id="cb7-57"><a href="#cb7-57"></a>    <span class="cf">return</span> Z.n_rows;</span>
<span id="cb7-58"><a href="#cb7-58"></a>  }</span>
<span id="cb7-59"><a href="#cb7-59"></a></span>
<span id="cb7-60"><a href="#cb7-60"></a>  <span class="co">/***</span></span>
<span id="cb7-61"><a href="#cb7-61"></a><span class="co">   computes the element function.</span></span>
<span id="cb7-62"><a href="#cb7-62"></a><span class="co">   @param point point to compute function at.</span></span>
<span id="cb7-63"><a href="#cb7-63"></a><span class="co">   */</span></span>
<span id="cb7-64"><a href="#cb7-64"></a>  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</span>
<span id="cb7-65"><a href="#cb7-65"></a>    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</span>
<span id="cb7-66"><a href="#cb7-66"></a>                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</span>
<span id="cb7-67"><a href="#cb7-67"></a></span>
<span id="cb7-68"><a href="#cb7-68"></a>    <span class="dt">double</span> out(<span class="dv">0</span>);</span>
<span id="cb7-69"><a href="#cb7-69"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</span>
<span id="cb7-70"><a href="#cb7-70"></a>      <span class="dt">double</span> <span class="at">const</span> eta =</span>
<span id="cb7-71"><a href="#cb7-71"></a>        arma::dot(beta, X.col(i)) + arma::dot(u, Z.col(i));</span>
<span id="cb7-72"><a href="#cb7-72"></a>      out -= y[i] * eta - log(<span class="dv">1</span> + exp(eta));</span>
<span id="cb7-73"><a href="#cb7-73"></a>    }</span>
<span id="cb7-74"><a href="#cb7-74"></a></span>
<span id="cb7-75"><a href="#cb7-75"></a>    out += arma::dot(u, Sigma_inv * u) * <span class="fl">.5</span>;</span>
<span id="cb7-76"><a href="#cb7-76"></a></span>
<span id="cb7-77"><a href="#cb7-77"></a>    <span class="cf">return</span> out;</span>
<span id="cb7-78"><a href="#cb7-78"></a>  }</span>
<span id="cb7-79"><a href="#cb7-79"></a></span>
<span id="cb7-80"><a href="#cb7-80"></a>  <span class="co">/***</span></span>
<span id="cb7-81"><a href="#cb7-81"></a><span class="co">   computes the element function and its gradient.</span></span>
<span id="cb7-82"><a href="#cb7-82"></a><span class="co">   @param point point to compute function at.</span></span>
<span id="cb7-83"><a href="#cb7-83"></a><span class="co">   @param gr gradient vector with respect to global and private parameters.</span></span>
<span id="cb7-84"><a href="#cb7-84"></a><span class="co">   */</span></span>
<span id="cb7-85"><a href="#cb7-85"></a>  <span class="dt">double</span> grad</span>
<span id="cb7-86"><a href="#cb7-86"></a>    (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</span>
<span id="cb7-87"><a href="#cb7-87"></a>    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</span>
<span id="cb7-88"><a href="#cb7-88"></a>                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</span>
<span id="cb7-89"><a href="#cb7-89"></a></span>
<span id="cb7-90"><a href="#cb7-90"></a>    <span class="co">// create objects to write to for the gradient</span></span>
<span id="cb7-91"><a href="#cb7-91"></a>    <span class="bu">std::</span>fill(gr, gr + beta.n_elem + u.n_elem, <span class="fl">0.</span>);</span>
<span id="cb7-92"><a href="#cb7-92"></a>    arma::vec dbeta(gr              , beta.n_elem, <span class="kw">false</span>),</span>
<span id="cb7-93"><a href="#cb7-93"></a>              du   (gr + beta.n_elem, u.n_elem   , <span class="kw">false</span>);</span>
<span id="cb7-94"><a href="#cb7-94"></a></span>
<span id="cb7-95"><a href="#cb7-95"></a>    <span class="dt">double</span> out(<span class="dv">0</span>);</span>
<span id="cb7-96"><a href="#cb7-96"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</span>
<span id="cb7-97"><a href="#cb7-97"></a>      arma::vec <span class="at">const</span> xi = X.unsafe_col(i),</span>
<span id="cb7-98"><a href="#cb7-98"></a>                      zi = Z.unsafe_col(i);</span>
<span id="cb7-99"><a href="#cb7-99"></a>      <span class="dt">double</span> <span class="at">const</span> eta = arma::dot(beta, xi) + arma::dot(u, zi),</span>
<span id="cb7-100"><a href="#cb7-100"></a>               exp_eta = exp(eta),</span>
<span id="cb7-101"><a href="#cb7-101"></a>               d_eta   = y[i] - exp_eta / (<span class="dv">1</span> + exp_eta);</span>
<span id="cb7-102"><a href="#cb7-102"></a>      out -= y[i] * eta - log(<span class="dv">1</span> + exp_eta);</span>
<span id="cb7-103"><a href="#cb7-103"></a>      dbeta -= d_eta * xi;</span>
<span id="cb7-104"><a href="#cb7-104"></a>      du    -= d_eta * zi;</span>
<span id="cb7-105"><a href="#cb7-105"></a>    }</span>
<span id="cb7-106"><a href="#cb7-106"></a></span>
<span id="cb7-107"><a href="#cb7-107"></a>    arma::vec u_scaled = Sigma_inv * u;</span>
<span id="cb7-108"><a href="#cb7-108"></a>    out += arma::dot(u, u_scaled) * <span class="fl">.5</span>;</span>
<span id="cb7-109"><a href="#cb7-109"></a>    du += u_scaled;</span>
<span id="cb7-110"><a href="#cb7-110"></a></span>
<span id="cb7-111"><a href="#cb7-111"></a>    <span class="cf">return</span> out;</span>
<span id="cb7-112"><a href="#cb7-112"></a>  }</span>
<span id="cb7-113"><a href="#cb7-113"></a></span>
<span id="cb7-114"><a href="#cb7-114"></a>  <span class="co">/***</span></span>
<span id="cb7-115"><a href="#cb7-115"></a><span class="co">   returns true if the member functions are thread-safe.</span></span>
<span id="cb7-116"><a href="#cb7-116"></a><span class="co">   */</span></span>
<span id="cb7-117"><a href="#cb7-117"></a>  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</span>
<span id="cb7-118"><a href="#cb7-118"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb7-119"><a href="#cb7-119"></a>  }</span>
<span id="cb7-120"><a href="#cb7-120"></a>};</span>
<span id="cb7-121"><a href="#cb7-121"></a></span>
<span id="cb7-122"><a href="#cb7-122"></a><span class="kw">using</span> mlogit_topim = PSQN::optimizer&lt;<span class="va">m_logit_func</span>, PSQN::R_reporter,</span>
<span id="cb7-123"><a href="#cb7-123"></a>                                     PSQN::R_interrupter&gt;;</span>
<span id="cb7-124"><a href="#cb7-124"></a></span>
<span id="cb7-125"><a href="#cb7-125"></a><span class="co">/***</span></span>
<span id="cb7-126"><a href="#cb7-126"></a><span class="co"> creates a pointer to an object which is needed in the optim_mlogit</span></span>
<span id="cb7-127"><a href="#cb7-127"></a><span class="co"> function.</span></span>
<span id="cb7-128"><a href="#cb7-128"></a><span class="co"> @param data list with data for each element function.</span></span>
<span id="cb7-129"><a href="#cb7-129"></a><span class="co"> @param max_threads maximum number of threads to use.</span></span>
<span id="cb7-130"><a href="#cb7-130"></a><span class="co"> */</span></span>
<span id="cb7-131"><a href="#cb7-131"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-132"><a href="#cb7-132"></a>SEXP get_mlogit_optimizer(List data, <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</span>
<span id="cb7-133"><a href="#cb7-133"></a>  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</span>
<span id="cb7-134"><a href="#cb7-134"></a>  <span class="bu">std::</span>vector&lt;<span class="va">m_logit_func</span>&gt; funcs;</span>
<span id="cb7-135"><a href="#cb7-135"></a>  funcs.reserve(n_elem_funcs);</span>
<span id="cb7-136"><a href="#cb7-136"></a>  <span class="cf">for</span>(<span class="kw">auto</span> dat : data)</span>
<span id="cb7-137"><a href="#cb7-137"></a>    funcs.emplace_back(List(dat));</span>
<span id="cb7-138"><a href="#cb7-138"></a></span>
<span id="cb7-139"><a href="#cb7-139"></a>  <span class="co">// create an XPtr to the object we will need</span></span>
<span id="cb7-140"><a href="#cb7-140"></a>  XPtr&lt;mlogit_topim&gt; ptr(<span class="kw">new</span> mlogit_topim(funcs, max_threads));</span>
<span id="cb7-141"><a href="#cb7-141"></a></span>
<span id="cb7-142"><a href="#cb7-142"></a>  <span class="co">// return the pointer to be used later</span></span>
<span id="cb7-143"><a href="#cb7-143"></a>  <span class="cf">return</span> ptr;</span>
<span id="cb7-144"><a href="#cb7-144"></a>}</span>
<span id="cb7-145"><a href="#cb7-145"></a></span>
<span id="cb7-146"><a href="#cb7-146"></a><span class="co">/***</span></span>
<span id="cb7-147"><a href="#cb7-147"></a><span class="co"> performs the optimization.</span></span>
<span id="cb7-148"><a href="#cb7-148"></a><span class="co"> @param val vector with starting value for the global and private</span></span>
<span id="cb7-149"><a href="#cb7-149"></a><span class="co"> parameters.</span></span>
<span id="cb7-150"><a href="#cb7-150"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-151"><a href="#cb7-151"></a><span class="co"> @param rel_eps relative convergence threshold.</span></span>
<span id="cb7-152"><a href="#cb7-152"></a><span class="co"> @param max_it maximum number iterations.</span></span>
<span id="cb7-153"><a href="#cb7-153"></a><span class="co"> @param n_threads number of threads to use.</span></span>
<span id="cb7-154"><a href="#cb7-154"></a><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></span>
<span id="cb7-155"><a href="#cb7-155"></a><span class="co"> @param use_bfgs boolean for whether to use SR1 or BFGS updates.</span></span>
<span id="cb7-156"><a href="#cb7-156"></a><span class="co"> @param trace integer where larger values gives more information during the</span></span>
<span id="cb7-157"><a href="#cb7-157"></a><span class="co"> optimization.</span></span>
<span id="cb7-158"><a href="#cb7-158"></a><span class="co"> @param cg_tol threshold for conjugate gradient method.</span></span>
<span id="cb7-159"><a href="#cb7-159"></a><span class="co"> @param strong_wolfe true if the strong Wolfe condition should be used.</span></span>
<span id="cb7-160"><a href="#cb7-160"></a><span class="co"> @param max_cg maximum number of conjugate gradient iterations in each</span></span>
<span id="cb7-161"><a href="#cb7-161"></a><span class="co"> iteration. Use zero if there should not be a limit.</span></span>
<span id="cb7-162"><a href="#cb7-162"></a><span class="co"> @param pre_method preconditioning method in conjugate gradient method.</span></span>
<span id="cb7-163"><a href="#cb7-163"></a><span class="co"> zero yields no preconditioning and one yields diagonal preconditioning.</span></span>
<span id="cb7-164"><a href="#cb7-164"></a><span class="co"> */</span></span>
<span id="cb7-165"><a href="#cb7-165"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-166"><a href="#cb7-166"></a>List optim_mlogit</span>
<span id="cb7-167"><a href="#cb7-167"></a>  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</span>
<span id="cb7-168"><a href="#cb7-168"></a>   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</span>
<span id="cb7-169"><a href="#cb7-169"></a>   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</span>
<span id="cb7-170"><a href="#cb7-170"></a>   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</span>
<span id="cb7-171"><a href="#cb7-171"></a>   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</span>
<span id="cb7-172"><a href="#cb7-172"></a>  XPtr&lt;mlogit_topim&gt; optim(ptr);</span>
<span id="cb7-173"><a href="#cb7-173"></a></span>
<span id="cb7-174"><a href="#cb7-174"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb7-175"><a href="#cb7-175"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb7-176"><a href="#cb7-176"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit: invalid parameter size&quot;</span>);</span>
<span id="cb7-177"><a href="#cb7-177"></a></span>
<span id="cb7-178"><a href="#cb7-178"></a>  NumericVector par = clone(val);</span>
<span id="cb7-179"><a href="#cb7-179"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb7-180"><a href="#cb7-180"></a>  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</span>
<span id="cb7-181"><a href="#cb7-181"></a>                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</span>
<span id="cb7-182"><a href="#cb7-182"></a>                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</span>
<span id="cb7-183"><a href="#cb7-183"></a>  NumericVector counts = NumericVector::create(</span>
<span id="cb7-184"><a href="#cb7-184"></a>    res.n_eval, res.n_grad,  res.n_cg);</span>
<span id="cb7-185"><a href="#cb7-185"></a>  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</span>
<span id="cb7-186"><a href="#cb7-186"></a></span>
<span id="cb7-187"><a href="#cb7-187"></a>  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</span>
<span id="cb7-188"><a href="#cb7-188"></a>  <span class="cf">return</span> List::create(</span>
<span id="cb7-189"><a href="#cb7-189"></a>    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</span>
<span id="cb7-190"><a href="#cb7-190"></a>    _[<span class="st">&quot;counts&quot;</span>] = counts,</span>
<span id="cb7-191"><a href="#cb7-191"></a>    _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged );</span>
<span id="cb7-192"><a href="#cb7-192"></a>}</span>
<span id="cb7-193"><a href="#cb7-193"></a></span>
<span id="cb7-194"><a href="#cb7-194"></a><span class="co">/***</span></span>
<span id="cb7-195"><a href="#cb7-195"></a><span class="co"> performs the optimization but only for the private parameters.</span></span>
<span id="cb7-196"><a href="#cb7-196"></a><span class="co"> @param val vector with starting value for the global and private</span></span>
<span id="cb7-197"><a href="#cb7-197"></a><span class="co"> parameters.</span></span>
<span id="cb7-198"><a href="#cb7-198"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-199"><a href="#cb7-199"></a><span class="co"> @param rel_eps relative convergence threshold.</span></span>
<span id="cb7-200"><a href="#cb7-200"></a><span class="co"> @param max_it maximum number iterations.</span></span>
<span id="cb7-201"><a href="#cb7-201"></a><span class="co"> @param n_threads number of threads to use.</span></span>
<span id="cb7-202"><a href="#cb7-202"></a><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></span>
<span id="cb7-203"><a href="#cb7-203"></a><span class="co"> */</span></span>
<span id="cb7-204"><a href="#cb7-204"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-205"><a href="#cb7-205"></a>NumericVector optim_mlogit_private</span>
<span id="cb7-206"><a href="#cb7-206"></a>  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</span>
<span id="cb7-207"><a href="#cb7-207"></a>   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1, <span class="dt">double</span> <span class="at">const</span> c2){</span>
<span id="cb7-208"><a href="#cb7-208"></a>  XPtr&lt;mlogit_topim&gt; optim(ptr);</span>
<span id="cb7-209"><a href="#cb7-209"></a></span>
<span id="cb7-210"><a href="#cb7-210"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb7-211"><a href="#cb7-211"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb7-212"><a href="#cb7-212"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit_private: invalid parameter size&quot;</span>);</span>
<span id="cb7-213"><a href="#cb7-213"></a></span>
<span id="cb7-214"><a href="#cb7-214"></a>  NumericVector par = clone(val);</span>
<span id="cb7-215"><a href="#cb7-215"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb7-216"><a href="#cb7-216"></a>  <span class="dt">double</span> <span class="at">const</span> res = optim-&gt;optim_priv(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2);</span>
<span id="cb7-217"><a href="#cb7-217"></a>  par.attr(<span class="st">&quot;value&quot;</span>) = res;</span>
<span id="cb7-218"><a href="#cb7-218"></a>  <span class="cf">return</span> par;</span>
<span id="cb7-219"><a href="#cb7-219"></a>}</span>
<span id="cb7-220"><a href="#cb7-220"></a></span>
<span id="cb7-221"><a href="#cb7-221"></a><span class="co">/***</span></span>
<span id="cb7-222"><a href="#cb7-222"></a><span class="co"> evaluates the partially separable function.</span></span>
<span id="cb7-223"><a href="#cb7-223"></a><span class="co"> @param val vector with global and private parameters to evaluate the</span></span>
<span id="cb7-224"><a href="#cb7-224"></a><span class="co"> function at.</span></span>
<span id="cb7-225"><a href="#cb7-225"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-226"><a href="#cb7-226"></a><span class="co"> @param n_threads number of threads to use.</span></span>
<span id="cb7-227"><a href="#cb7-227"></a><span class="co"> */</span></span>
<span id="cb7-228"><a href="#cb7-228"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-229"><a href="#cb7-229"></a><span class="dt">double</span> eval_mlogit(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb7-230"><a href="#cb7-230"></a>  XPtr&lt;mlogit_topim&gt; optim(ptr);</span>
<span id="cb7-231"><a href="#cb7-231"></a></span>
<span id="cb7-232"><a href="#cb7-232"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb7-233"><a href="#cb7-233"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb7-234"><a href="#cb7-234"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_mlogit: invalid parameter size&quot;</span>);</span>
<span id="cb7-235"><a href="#cb7-235"></a></span>
<span id="cb7-236"><a href="#cb7-236"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb7-237"><a href="#cb7-237"></a>  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</span>
<span id="cb7-238"><a href="#cb7-238"></a>}</span>
<span id="cb7-239"><a href="#cb7-239"></a></span>
<span id="cb7-240"><a href="#cb7-240"></a><span class="co">/***</span></span>
<span id="cb7-241"><a href="#cb7-241"></a><span class="co"> evaluates the gradient of a partially separable function.</span></span>
<span id="cb7-242"><a href="#cb7-242"></a><span class="co"> @param val vector with global and private parameters to evaluate the</span></span>
<span id="cb7-243"><a href="#cb7-243"></a><span class="co"> function at.</span></span>
<span id="cb7-244"><a href="#cb7-244"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-245"><a href="#cb7-245"></a><span class="co"> @param n_threads number of threads to use.</span></span>
<span id="cb7-246"><a href="#cb7-246"></a><span class="co"> */</span></span>
<span id="cb7-247"><a href="#cb7-247"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-248"><a href="#cb7-248"></a>NumericVector grad_mlogit(NumericVector val, SEXP ptr,</span>
<span id="cb7-249"><a href="#cb7-249"></a>                          <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb7-250"><a href="#cb7-250"></a>  XPtr&lt;mlogit_topim&gt; optim(ptr);</span>
<span id="cb7-251"><a href="#cb7-251"></a></span>
<span id="cb7-252"><a href="#cb7-252"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb7-253"><a href="#cb7-253"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb7-254"><a href="#cb7-254"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_mlogit: invalid parameter size&quot;</span>);</span>
<span id="cb7-255"><a href="#cb7-255"></a></span>
<span id="cb7-256"><a href="#cb7-256"></a>  NumericVector grad(val.size());</span>
<span id="cb7-257"><a href="#cb7-257"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb7-258"><a href="#cb7-258"></a>  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</span>
<span id="cb7-259"><a href="#cb7-259"></a></span>
<span id="cb7-260"><a href="#cb7-260"></a>  <span class="cf">return</span> grad;</span>
<span id="cb7-261"><a href="#cb7-261"></a>}</span>
<span id="cb7-262"><a href="#cb7-262"></a></span>
<span id="cb7-263"><a href="#cb7-263"></a><span class="co">/***</span></span>
<span id="cb7-264"><a href="#cb7-264"></a><span class="co"> returns the current Hessian approximation.</span></span>
<span id="cb7-265"><a href="#cb7-265"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-266"><a href="#cb7-266"></a><span class="co"> */</span></span>
<span id="cb7-267"><a href="#cb7-267"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-268"><a href="#cb7-268"></a>NumericMatrix get_Hess_approx_mlogit(SEXP ptr){</span>
<span id="cb7-269"><a href="#cb7-269"></a>  XPtr&lt;mlogit_topim&gt; optim(ptr);</span>
<span id="cb7-270"><a href="#cb7-270"></a></span>
<span id="cb7-271"><a href="#cb7-271"></a>  NumericMatrix out(optim-&gt;n_par, optim-&gt;n_par);</span>
<span id="cb7-272"><a href="#cb7-272"></a>  optim-&gt;get_hess(&amp;out[<span class="dv">0</span>]);</span>
<span id="cb7-273"><a href="#cb7-273"></a></span>
<span id="cb7-274"><a href="#cb7-274"></a>  <span class="cf">return</span> out;</span>
<span id="cb7-275"><a href="#cb7-275"></a>}</span>
<span id="cb7-276"><a href="#cb7-276"></a></span>
<span id="cb7-277"><a href="#cb7-277"></a><span class="co">/***</span></span>
<span id="cb7-278"><a href="#cb7-278"></a><span class="co"> returns the current Hessian approximation as a sparse matrix.</span></span>
<span id="cb7-279"><a href="#cb7-279"></a><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></span>
<span id="cb7-280"><a href="#cb7-280"></a><span class="co"> */</span></span>
<span id="cb7-281"><a href="#cb7-281"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb7-282"><a href="#cb7-282"></a>Eigen::SparseMatrix&lt;<span class="dt">double</span>&gt; get_sparse_Hess_approx_mlogit(SEXP ptr){</span>
<span id="cb7-283"><a href="#cb7-283"></a>  <span class="cf">return</span> XPtr&lt;mlogit_topim&gt;(ptr)-&gt;get_hess_sparse();</span>
<span id="cb7-284"><a href="#cb7-284"></a>}</span></code></pre></div>
<p>The <code>PSQN::R_reporter</code> class ensures that output will be printed when one passes a <code>trace</code> argument which is greater than zero. The <code>PSQN::R_interrupter</code> class ensures that the user can interrupt the computation. These two classes can be replaced with custom classes if one wants to and provides another implementation. See the source code of this package for the required members.</p>
<p>We can use the code by calling <code>Rcpp::sourceCpp</code> to compile the code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">library</span>(Rcpp)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;mlogit-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">#&gt; Registered S3 methods overwritten by &#39;RcppEigen&#39;:</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#&gt;   method               from         </span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">#&gt;   predict.fastLm       RcppArmadillo</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">#&gt;   print.fastLm         RcppArmadillo</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">#&gt;   summary.fastLm       RcppArmadillo</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">#&gt;   print.summary.fastLm RcppArmadillo</span></span></code></pre></div>
<p>Then we can create a pointer to an optimizer and check that it yields the correct value and gradient like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>optimizer &lt;-<span class="st"> </span><span class="kw">get_mlogit_optimizer</span>(sim_dat, <span class="dt">max_threads =</span> 4L)</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(</span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="kw">eval_integrand</span>(true_params), </span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)))</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">library</span>(numDeriv)</span>
<span id="cb9-8"><a href="#cb9-8"></a>gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(</span>
<span id="cb9-9"><a href="#cb9-9"></a>  <span class="cf">function</span>(par) <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb9-10"><a href="#cb9-10"></a>  true_params)</span>
<span id="cb9-11"><a href="#cb9-11"></a>gr_opt &lt;-<span class="st"> </span><span class="kw">grad_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(gr_num, gr_opt, <span class="dt">tolerance =</span> <span class="fl">1e-5</span>, </span>
<span id="cb9-14"><a href="#cb9-14"></a>                    <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>),</span>
<span id="cb9-15"><a href="#cb9-15"></a>          <span class="co"># also check the function value!</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>          <span class="kw">all.equal</span>(<span class="kw">attr</span>(gr_opt, <span class="st">&quot;value&quot;</span>), </span>
<span id="cb9-17"><a href="#cb9-17"></a>                    <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, </span>
<span id="cb9-18"><a href="#cb9-18"></a>                                <span class="dt">n_threads =</span> 2L)))</span></code></pre></div>
<p>We can now use the BFGS implementation in the <code>optim</code> function to compare with like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>optim_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="kw">optim</span>(</span>
<span id="cb10-3"><a href="#cb10-3"></a>    par, <span class="cf">function</span>(par) </span>
<span id="cb10-4"><a href="#cb10-4"></a>      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="cf">function</span>(par) </span>
<span id="cb10-6"><a href="#cb10-6"></a>      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">reltol =</span> <span class="fl">1e-8</span>))</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>bfgs_res &lt;-<span class="st"> </span><span class="kw">optim_func</span>(start_val)</span></code></pre></div>
<p>We then use the quasi-Newton method like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </span>
<span id="cb11-2"><a href="#cb11-2"></a>                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L, <span class="dt">use_bfgs =</span> <span class="ot">TRUE</span>, </span>
<span id="cb11-3"><a href="#cb11-3"></a>                      <span class="dt">opt_private =</span> <span class="ot">FALSE</span>, <span class="dt">pre_method =</span> 1L){</span>
<span id="cb11-4"><a href="#cb11-4"></a>  rel_eps &lt;-<span class="st"> </span><span class="fl">1e-8</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span class="cf">if</span>(opt_private){</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="co"># it may be useful to fix the global parameters and optimize the </span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="co"># private parameters to get starting values. This is very fast as each </span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="co"># set of parameters can be optimized separately</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    par &lt;-<span class="st"> </span><span class="kw">optim_mlogit_private</span>(</span>
<span id="cb11-10"><a href="#cb11-10"></a>      <span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="kw">sqrt</span>(rel_eps), <span class="dt">max_it =</span> <span class="dv">100</span>, </span>
<span id="cb11-11"><a href="#cb11-11"></a>      <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2)</span>
<span id="cb11-12"><a href="#cb11-12"></a>  }</span>
<span id="cb11-13"><a href="#cb11-13"></a>  <span class="kw">optim_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> rel_eps, </span>
<span id="cb11-14"><a href="#cb11-14"></a>               <span class="dt">max_it =</span> 1000L, <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </span>
<span id="cb11-15"><a href="#cb11-15"></a>               <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, <span class="dt">use_bfgs =</span> use_bfgs, </span>
<span id="cb11-16"><a href="#cb11-16"></a>               <span class="dt">pre_method =</span> pre_method)</span>
<span id="cb11-17"><a href="#cb11-17"></a>}</span>
<span id="cb11-18"><a href="#cb11-18"></a></span>
<span id="cb11-19"><a href="#cb11-19"></a>psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val)</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="co"># using SR1 updates</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>psqn_res_sr1 &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>)</span>
<span id="cb11-23"><a href="#cb11-23"></a><span class="kw">all.equal</span>(psqn_res_sr1<span class="op">$</span>value, psqn_res<span class="op">$</span>value)</span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a><span class="co"># w/ different starting values</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>psqn_res_diff_start &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">opt_private =</span> <span class="ot">TRUE</span>)</span>
<span id="cb11-28"><a href="#cb11-28"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_diff_start<span class="op">$</span>value)</span>
<span id="cb11-29"><a href="#cb11-29"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>The <code>counts</code> element contains the number of function evaluations, gradient evaluations, and the total number of conjugate gradient iterations:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>psqn_res<span class="op">$</span>counts</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">#&gt;       13       11       20</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="co"># it is the same as we got from R</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>par, R_res<span class="op">$</span>par)</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, R_res<span class="op">$</span>value)</span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co"># compare with optim</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>bfgs_res<span class="op">$</span>counts</span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="co">#&gt;       63       19</span></span></code></pre></div>
<p>We can compare the solution with the solution from <code>optim</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">all.equal</span>(bfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">#&gt; [1] &quot;Mean relative difference: 7.81e-05&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value, <span class="dt">tolerance =</span> <span class="fl">1e-8</span>)</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>bfgs_res<span class="op">$</span>value</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">#&gt; [1] -5.61e-06</span></span></code></pre></div>
<p>The <code>optim_mlogit</code> takes fewer iterations possibly because we quicker get a good approximation of the Hessian. Furthermore, we only take <code>psqn_res$counts[&quot;n_cg&quot;]</code>, 20, conjugate gradient iterations. This in contrast to the worst case scenario where we make <code>length(start_val)</code>, 3205, iterations for just one iteration of the quasi-Newton method! We can also compare with the limited memory BFGS minimizer from the <code>lbfgsb3c</code> package:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">library</span>(lbfgsb3c)</span>
<span id="cb14-2"><a href="#cb14-2"></a>lbfgsb3c_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="kw">lbfgsb3c</span>(<span class="dt">par =</span> par, <span class="cf">function</span>(par) </span>
<span id="cb14-4"><a href="#cb14-4"></a>      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="cf">function</span>(par) </span>
<span id="cb14-6"><a href="#cb14-6"></a>      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">factr =</span> <span class="fl">1e-8</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>, <span class="dt">maxit =</span> 1000L))</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>lbfgsb3c_res &lt;-<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val)</span>
<span id="cb14-10"><a href="#cb14-10"></a></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="co">#&gt; [1] &quot;Mean relative difference: 1.72e-05&quot;</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgsb3c_res<span class="op">$</span>value</span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="co">#&gt; [1] 2.22e-06</span></span></code></pre></div>
<p>We can also compare with the limited memory BFGS minimizer from the <code>lbfgs</code> package:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">library</span>(lbfgs)</span>
<span id="cb15-2"><a href="#cb15-2"></a>lbfgs_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="kw">lbfgs</span>(<span class="dt">vars =</span> par, <span class="cf">function</span>(par) </span>
<span id="cb15-4"><a href="#cb15-4"></a>      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="cf">function</span>(par) </span>
<span id="cb15-6"><a href="#cb15-6"></a>      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="dt">invisible =</span> <span class="dv">1</span>)</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a>lbfgs_res &lt;-<span class="st"> </span><span class="kw">lbfgs_func</span>(start_val)</span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="co">#&gt; [1] &quot;Mean relative difference: 1.83e-05&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgs_res<span class="op">$</span>value</span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="co">#&gt; [1] 2.21e-06</span></span></code></pre></div>
<div id="getting-the-hessian-approximation" class="section level4">
<h4>Getting the Hessian Approximation</h4>
<p>We can get the Hessian approximation by calling the <code>get_Hess_approx_mlogit</code> and <code>get_sparse_Hess_approx_mlogit</code> we declared after calling the optimizer:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>aprox_hes &lt;-<span class="st"> </span><span class="kw">get_Hess_approx_mlogit</span>(<span class="dt">ptr =</span> optimizer)</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">dim</span>(aprox_hes) <span class="co"># quite large; requires a lot of memory</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#&gt; [1] 3205 3205</span></span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co"># we can also get the sparse version</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>aprox_hes_sparse &lt;-<span class="st"> </span><span class="kw">get_sparse_Hess_approx_mlogit</span>(optimizer)</span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="kw">all.equal</span>(<span class="kw">as.matrix</span>(aprox_hes_sparse), aprox_hes, </span>
<span id="cb16-8"><a href="#cb16-8"></a>          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co"># this require much less memory </span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">object.size</span>(aprox_hes)</span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="co">#&gt; 82176416 bytes</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="kw">object.size</span>(aprox_hes_sparse)</span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="co">#&gt; 552224 bytes</span></span>
<span id="cb16-16"><a href="#cb16-16"></a></span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="co"># we can roughly check against the true values as follows</span></span>
<span id="cb16-18"><a href="#cb16-18"></a><span class="cf">if</span>(<span class="ot">FALSE</span>){</span>
<span id="cb16-19"><a href="#cb16-19"></a>  <span class="co"># only feasible for smaller problem</span></span>
<span id="cb16-20"><a href="#cb16-20"></a>  hess_true &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</span>
<span id="cb16-21"><a href="#cb16-21"></a>    <span class="cf">function</span>(par) <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb16-22"><a href="#cb16-22"></a>    psqn_res<span class="op">$</span>par)</span>
<span id="cb16-23"><a href="#cb16-23"></a>  </span>
<span id="cb16-24"><a href="#cb16-24"></a>  <span class="co"># should not hold exactly! Might not be that good of an approximation.</span></span>
<span id="cb16-25"><a href="#cb16-25"></a>  <span class="kw">all.equal</span>(aprox_hes, hess_true)</span>
<span id="cb16-26"><a href="#cb16-26"></a>  </span>
<span id="cb16-27"><a href="#cb16-27"></a>  <span class="co"># the non-zero entries should match </span></span>
<span id="cb16-28"><a href="#cb16-28"></a>  v1 &lt;-<span class="st"> </span><span class="kw">abs</span>(hess_true) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb16-29"><a href="#cb16-29"></a>  v2 &lt;-<span class="st"> </span><span class="kw">abs</span>(aprox_hes) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb16-30"><a href="#cb16-30"></a>  <span class="kw">all.equal</span>(v1, v2)</span>
<span id="cb16-31"><a href="#cb16-31"></a>}</span>
<span id="cb16-32"><a href="#cb16-32"></a></span>
<span id="cb16-33"><a href="#cb16-33"></a><span class="co"># create a plot like before. Black entries are non-zero</span></span>
<span id="cb16-34"><a href="#cb16-34"></a><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>))</span>
<span id="cb16-35"><a href="#cb16-35"></a>idx &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">min</span>(<span class="dv">1000</span>, <span class="kw">NROW</span>(aprox_hes))</span>
<span id="cb16-36"><a href="#cb16-36"></a>aprox_hes &lt;-<span class="st"> </span>aprox_hes[idx, idx] <span class="co"># reduce dimension to plot quickly</span></span>
<span id="cb16-37"><a href="#cb16-37"></a><span class="kw">image</span>(<span class="kw">abs</span>(aprox_hes[, <span class="kw">NCOL</span>(aprox_hes)<span class="op">:</span><span class="dv">1</span>]) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dt">xaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>,</span>
<span id="cb16-38"><a href="#cb16-38"></a>      <span class="dt">col =</span> <span class="kw">gray.colors</span>(2L, <span class="dv">1</span>, <span class="dv">0</span>))</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The true Hessian is very sparse.</p>
</div>
<div id="using-different-preconditioners" class="section level4">
<h4>Using Different Preconditioners</h4>
<p>We can use different preconditioners. We illustrate this below. Notice that you have to define the <code>PSQN_USE_EIGEN</code> macro variable prior to including any of the psqn headers files if you are using the C++ interface in order to use the incomplete Cholesky factorization from Eigen. You will also have to include RcppEigen or the psqn-Rcpp-wrapper.h header.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># without any preconditioner</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>psqn_res_no_pre &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">pre_method =</span> 0L)</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co"># we get the same</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_no_pre<span class="op">$</span>value)</span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="co"># we mainly use more conjugate gradient steps</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>psqn_res       <span class="op">$</span>counts</span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="co">#&gt;       13       11       20</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>psqn_res_no_pre<span class="op">$</span>counts</span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="co">#&gt;       16       14       59</span></span>
<span id="cb17-15"><a href="#cb17-15"></a></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="co"># with the incomplete Cholesky factorization</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>psqn_res_cholesky &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">pre_method =</span> 2L)</span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_cholesky<span class="op">$</span>value)</span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb17-20"><a href="#cb17-20"></a></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="co"># we use fewer conjugate gradient steps</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>psqn_res_cholesky<span class="op">$</span>counts</span>
<span id="cb17-23"><a href="#cb17-23"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb17-24"><a href="#cb17-24"></a><span class="co">#&gt;       12       10       10</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>psqn_res         <span class="op">$</span>counts</span>
<span id="cb17-26"><a href="#cb17-26"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb17-27"><a href="#cb17-27"></a><span class="co">#&gt;       13       11       20</span></span>
<span id="cb17-28"><a href="#cb17-28"></a></span>
<span id="cb17-29"><a href="#cb17-29"></a><span class="co"># we can equally use the R interface</span></span>
<span id="cb17-30"><a href="#cb17-30"></a>psqn_res_cholesky_R &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(start_val, <span class="dt">pre_method =</span> 2L)</span>
<span id="cb17-31"><a href="#cb17-31"></a></span>
<span id="cb17-32"><a href="#cb17-32"></a><span class="kw">all.equal</span>(psqn_res_cholesky_R[<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)], </span>
<span id="cb17-33"><a href="#cb17-33"></a>          psqn_res_cholesky  [<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)])</span>
<span id="cb17-34"><a href="#cb17-34"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div id="benchmarking" class="section level4">
<h4>Benchmarking</h4>
<p>Finally, here is a benchmark to compare the computation time:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="st">`</span><span class="dt">   optim BFGS (2 threads)</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">optim_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb18-3"><a href="#cb18-3"></a>  <span class="st">`</span><span class="dt">         lbfgs (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="st">`</span><span class="dt">         lbfgs(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="st">`</span><span class="dt">         lbfgs(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 4L),</span>
<span id="cb18-6"><a href="#cb18-6"></a>  <span class="st">`</span><span class="dt">      lbfgsb3c (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb18-7"><a href="#cb18-7"></a>  <span class="st">`</span><span class="dt">      lbfgsb3c(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb18-8"><a href="#cb18-8"></a>  <span class="st">`</span><span class="dt">      lbfgsb3c(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 4L),</span>
<span id="cb18-9"><a href="#cb18-9"></a>  <span class="st">`</span><span class="dt">       psqn (R; 1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb18-10"><a href="#cb18-10"></a>  <span class="st">`</span><span class="dt">       psqn(R; 2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb18-11"><a href="#cb18-11"></a>  <span class="st">`</span><span class="dt">     psqn (1 thread, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </span>
<span id="cb18-12"><a href="#cb18-12"></a>                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</span>
<span id="cb18-13"><a href="#cb18-13"></a>  <span class="st">`</span><span class="dt">     psqn(2 threads, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L, </span>
<span id="cb18-14"><a href="#cb18-14"></a>                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</span>
<span id="cb18-15"><a href="#cb18-15"></a>  <span class="st">`</span><span class="dt">psqn  (1 thread, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 1L, </span>
<span id="cb18-16"><a href="#cb18-16"></a>                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</span>
<span id="cb18-17"><a href="#cb18-17"></a>  <span class="st">`</span><span class="dt">psqn (2 threads, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 2L, </span>
<span id="cb18-18"><a href="#cb18-18"></a>                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</span>
<span id="cb18-19"><a href="#cb18-19"></a>  <span class="st">`</span><span class="dt">  psqn (1 thread; no pre)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </span>
<span id="cb18-20"><a href="#cb18-20"></a>                                              <span class="dt">pre_method =</span> 0L),</span>
<span id="cb18-21"><a href="#cb18-21"></a>  <span class="st">`</span><span class="dt">psqn (1 thread; Cholesky)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </span>
<span id="cb18-22"><a href="#cb18-22"></a>                                              <span class="dt">pre_method =</span> 2L),</span>
<span id="cb18-23"><a href="#cb18-23"></a>  <span class="st">`</span><span class="dt">          psqn (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb18-24"><a href="#cb18-24"></a>  <span class="st">`</span><span class="dt">          psqn(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb18-25"><a href="#cb18-25"></a>  <span class="st">`</span><span class="dt">          psqn(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 4L),</span>
<span id="cb18-26"><a href="#cb18-26"></a>  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="dv">5</span>)</span>
<span id="cb18-27"><a href="#cb18-27"></a><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="co">#&gt; # A tibble: 18 x 6</span></span>
<span id="cb18-29"><a href="#cb18-29"></a><span class="co">#&gt;    expression                      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb18-30"><a href="#cb18-30"></a><span class="co">#&gt;    &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb18-31"><a href="#cb18-31"></a><span class="co">#&gt;  1    optim BFGS (2 threads)     1.13s    1.13s     0.882   42.41MB    0    </span></span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="co">#&gt;  2          lbfgs (1 thread)  261.55ms 263.54ms     3.77    49.41MB    0.595</span></span>
<span id="cb18-33"><a href="#cb18-33"></a><span class="co">#&gt;  3          lbfgs(2 threads)  145.18ms 145.94ms     6.76    49.33MB    0.993</span></span>
<span id="cb18-34"><a href="#cb18-34"></a><span class="co">#&gt;  4          lbfgs(4 threads)  103.34ms 106.95ms     9.26    51.27MB    1.58 </span></span>
<span id="cb18-35"><a href="#cb18-35"></a><span class="co">#&gt;  5       lbfgsb3c (1 thread)  307.77ms 308.85ms     3.22    22.71MB    0.379</span></span>
<span id="cb18-36"><a href="#cb18-36"></a><span class="co">#&gt;  6       lbfgsb3c(2 threads)  183.46ms 185.37ms     5.29    25.25MB    0.392</span></span>
<span id="cb18-37"><a href="#cb18-37"></a><span class="co">#&gt;  7       lbfgsb3c(4 threads)   80.21ms  82.34ms    12.1     18.98MB    0.794</span></span>
<span id="cb18-38"><a href="#cb18-38"></a><span class="co">#&gt;  8        psqn (R; 1 thread)  211.03ms 220.41ms     4.56     7.91MB    7.54 </span></span>
<span id="cb18-39"><a href="#cb18-39"></a><span class="co">#&gt;  9        psqn(R; 2 threads)   211.9ms 227.06ms     4.45     7.91MB    7.15 </span></span>
<span id="cb18-40"><a href="#cb18-40"></a><span class="co">#&gt; 10      psqn (1 thread, SR1)   38.42ms  38.95ms    25.6     27.58KB    0    </span></span>
<span id="cb18-41"><a href="#cb18-41"></a><span class="co">#&gt; 11      psqn(2 threads, SR1)   19.16ms  19.44ms    51.4     27.58KB    0    </span></span>
<span id="cb18-42"><a href="#cb18-42"></a><span class="co">#&gt; 12 psqn  (1 thread, opt pri.)  24.77ms  25.09ms    39.8     60.42KB    0    </span></span>
<span id="cb18-43"><a href="#cb18-43"></a><span class="co">#&gt; 13 psqn (2 threads, opt pri.)  12.84ms  13.08ms    76.0     55.16KB    0    </span></span>
<span id="cb18-44"><a href="#cb18-44"></a><span class="co">#&gt; 14   psqn (1 thread; no pre)   23.84ms     24ms    41.5     27.58KB    0    </span></span>
<span id="cb18-45"><a href="#cb18-45"></a><span class="co">#&gt; 15 psqn (1 thread; Cholesky)   61.76ms   62.4ms    15.9     27.58KB    0    </span></span>
<span id="cb18-46"><a href="#cb18-46"></a><span class="co">#&gt; 16           psqn (1 thread)   18.35ms  18.43ms    54.0     27.58KB    0.199</span></span>
<span id="cb18-47"><a href="#cb18-47"></a><span class="co">#&gt; 17           psqn(2 threads)   10.03ms  10.06ms    98.7     27.58KB    0    </span></span>
<span id="cb18-48"><a href="#cb18-48"></a><span class="co">#&gt; 18           psqn(4 threads)     5.7ms   5.83ms   171.      27.58KB    0</span></span></code></pre></div>
<p>We see a large reduction. To be fair, we can use the C interface for the limited-memory BFGS methods to avoid re-allocating the gradient at every iteration. This will reduce their computation time. The R version of the quasi-Newton method is slower mainly as the R version to evaluate the log of the integrand and its derivative is slower than the version used by all the other methods. We can illustrate this by comparing with the computation time with the <code>eval_integrand</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="st">`</span><span class="dt">  R</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_integrand</span>(true_params), </span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="st">`</span><span class="dt">C++</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb19-4"><a href="#cb19-4"></a>  <span class="dt">min_iterations =</span> <span class="dv">100</span>)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co">#&gt; # A tibble: 2 x 6</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="co">#&gt; 1   R          5.62ms   5.99ms      158.  185.56KB     10.1</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="co">#&gt; 2 C++        580.23µs 582.83µs     1684.    2.49KB      0</span></span></code></pre></div>
<p>There is a big difference. Moreover, there is an overhead with repeatedly going back and forward between R and C++. A fair comparison would use an R implementation for all methods.</p>
</div>
</div>
<div id="polynomial-example" class="section level3">
<h3>Polynomial Example</h3>
<p>We consider the following trivial (regression) example as there is an explicit solution to compare with:</p>
<p><span class="math display">\[
\begin{align*}
\mathcal G &amp;=\{1,\dots, p\} \\
\mathcal G  \cap \mathcal P_i &amp;= \emptyset \\
\mathcal P_j \cap \mathcal P_i &amp;= \emptyset, \qquad i\neq j \\
\mathcal I_i &amp;\in \{1,\dots, p\}^{\lvert\mathcal P_i\rvert} \\
f(\vec x) &amp;= (\vec x_{\mathcal G} - \vec\mu_{\mathcal G})^\top
  (\vec x_{\mathcal G} - \vec\mu_{\mathcal G}) +
  \sum_{i = 1}^n 
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i})^\top
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i}) 
\end{align*}
\]</span> This is not because the problem is interesting per se but it is meant as another illustration. R code to simulate from this model is given below:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># simulate the data</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a>n_global &lt;-<span class="st"> </span>10L</span>
<span id="cb20-4"><a href="#cb20-4"></a>n_clusters &lt;-<span class="st"> </span>50L</span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a>mu_global &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_global)</span>
<span id="cb20-7"><a href="#cb20-7"></a>idx_start &lt;-<span class="st"> </span>n_global</span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a>cluster_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</span>
<span id="cb20-10"><a href="#cb20-10"></a>  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n_global, 1L)</span>
<span id="cb20-11"><a href="#cb20-11"></a>  g_idx &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">sample.int</span>(n_global, n_members))</span>
<span id="cb20-12"><a href="#cb20-12"></a>  mu_cluster &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_members)</span>
<span id="cb20-13"><a href="#cb20-13"></a>  Psi &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n_members <span class="op">*</span><span class="st"> </span>n_members), n_members, n_members)</span>
<span id="cb20-14"><a href="#cb20-14"></a>  </span>
<span id="cb20-15"><a href="#cb20-15"></a>  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">idx =</span> idx_start <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span>n_members, <span class="dt">g_idx =</span> g_idx,</span>
<span id="cb20-16"><a href="#cb20-16"></a>              <span class="dt">mu_cluster =</span> mu_cluster, <span class="dt">Psi =</span> Psi)</span>
<span id="cb20-17"><a href="#cb20-17"></a>  idx_start &lt;&lt;-<span class="st"> </span>idx_start <span class="op">+</span><span class="st"> </span>n_members</span>
<span id="cb20-18"><a href="#cb20-18"></a>  out</span>
<span id="cb20-19"><a href="#cb20-19"></a>}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</span>
<span id="cb20-20"><a href="#cb20-20"></a></span>
<span id="cb20-21"><a href="#cb20-21"></a><span class="co"># assign matrices needed for comparisons</span></span>
<span id="cb20-22"><a href="#cb20-22"></a><span class="kw">library</span>(Matrix)</span>
<span id="cb20-23"><a href="#cb20-23"></a>M &lt;-<span class="st"> </span><span class="kw">diag</span>(idx_start)</span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat)</span>
<span id="cb20-25"><a href="#cb20-25"></a>  M[cl<span class="op">$</span>idx, cl<span class="op">$</span>g_idx] &lt;-<span class="st"> </span><span class="op">-</span>cl<span class="op">$</span>Psi</span>
<span id="cb20-26"><a href="#cb20-26"></a>M &lt;-<span class="st"> </span><span class="kw">as</span>(M, <span class="st">&quot;dgCMatrix&quot;</span>)</span>
<span id="cb20-27"><a href="#cb20-27"></a></span>
<span id="cb20-28"><a href="#cb20-28"></a><span class="co"># Assign two R functions to evaluate the objective function. There are two </span></span>
<span id="cb20-29"><a href="#cb20-29"></a><span class="co"># versions of the function to show that we get the same with one being </span></span>
<span id="cb20-30"><a href="#cb20-30"></a><span class="co"># closer to the shown equation</span></span>
<span id="cb20-31"><a href="#cb20-31"></a>fn_one &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</span>
<span id="cb20-32"><a href="#cb20-32"></a>  delta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>n_global] <span class="op">-</span><span class="st"> </span>mu_global</span>
<span id="cb20-33"><a href="#cb20-33"></a>  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</span>
<span id="cb20-34"><a href="#cb20-34"></a>  <span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat){</span>
<span id="cb20-35"><a href="#cb20-35"></a>    delta &lt;-<span class="st"> </span><span class="kw">drop</span>(par[cl<span class="op">$</span>idx] <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>mu_cluster <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>Psi <span class="op">%*%</span><span class="st"> </span>par[cl<span class="op">$</span>g_idx])</span>
<span id="cb20-36"><a href="#cb20-36"></a>    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</span>
<span id="cb20-37"><a href="#cb20-37"></a>  }</span>
<span id="cb20-38"><a href="#cb20-38"></a>  out</span>
<span id="cb20-39"><a href="#cb20-39"></a>}</span>
<span id="cb20-40"><a href="#cb20-40"></a>fn_two &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</span>
<span id="cb20-41"><a href="#cb20-41"></a>  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</span>
<span id="cb20-42"><a href="#cb20-42"></a>  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)</span>
<span id="cb20-43"><a href="#cb20-43"></a>  <span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</span>
<span id="cb20-44"><a href="#cb20-44"></a>}</span>
<span id="cb20-45"><a href="#cb20-45"></a></span>
<span id="cb20-46"><a href="#cb20-46"></a>tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</span>
<span id="cb20-47"><a href="#cb20-47"></a><span class="kw">all.equal</span>(<span class="kw">fn_one</span>(tmp), <span class="kw">fn_two</span>(tmp)) <span class="co"># we get the same w/ the two</span></span>
<span id="cb20-48"><a href="#cb20-48"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb20-49"><a href="#cb20-49"></a>fn &lt;-<span class="st"> </span>fn_two</span>
<span id="cb20-50"><a href="#cb20-50"></a><span class="kw">rm</span>(fn_one, fn_two, tmp)</span>
<span id="cb20-51"><a href="#cb20-51"></a></span>
<span id="cb20-52"><a href="#cb20-52"></a><span class="co"># assign gradient function</span></span>
<span id="cb20-53"><a href="#cb20-53"></a>gr &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</span>
<span id="cb20-54"><a href="#cb20-54"></a>  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</span>
<span id="cb20-55"><a href="#cb20-55"></a>  <span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(M, <span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)))</span>
<span id="cb20-56"><a href="#cb20-56"></a>}</span>
<span id="cb20-57"><a href="#cb20-57"></a></span>
<span id="cb20-58"><a href="#cb20-58"></a><span class="co"># we can easily find the explicit solution</span></span>
<span id="cb20-59"><a href="#cb20-59"></a>mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</span>
<span id="cb20-60"><a href="#cb20-60"></a>exp_res &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">solve</span>(M, mu))</span>
<span id="cb20-61"><a href="#cb20-61"></a><span class="kw">fn</span>(exp_res) <span class="co"># ~ zero as it should be</span></span>
<span id="cb20-62"><a href="#cb20-62"></a><span class="co">#&gt; [1] 2.98e-29</span></span></code></pre></div>
<p>C++ code to work with this function is provided at <code>system.file(&quot;poly-ex.cpp&quot;, package = &quot;psqn&quot;)</code> with the package and given below:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="co">// see `mlogit-ex.cpp` for an example with more comments</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co">// we will use OpenMP to perform the computation in parallel</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="co">// we use RcppArmadillo to simplify the code</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9"></a></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="co">// [[Rcpp::depends(psqn)]]</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></span>
<span id="cb21-16"><a href="#cb21-16"></a></span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, psqn_uint <span class="at">const</span> n_ele){</span>
<span id="cb21-19"><a href="#cb21-19"></a>  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</span>
<span id="cb21-20"><a href="#cb21-20"></a>}</span>
<span id="cb21-21"><a href="#cb21-21"></a></span>
<span id="cb21-22"><a href="#cb21-22"></a><span class="kw">class</span> poly_func <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</span>
<span id="cb21-23"><a href="#cb21-23"></a>  <span class="co">/// global parameter indices</span></span>
<span id="cb21-24"><a href="#cb21-24"></a>  arma::uvec <span class="at">const</span> <span class="va">g_idx</span>;</span>
<span id="cb21-25"><a href="#cb21-25"></a>  <span class="co">/// centroid vector</span></span>
<span id="cb21-26"><a href="#cb21-26"></a>  arma::vec <span class="at">const</span> mu_cluster;</span>
<span id="cb21-27"><a href="#cb21-27"></a>  <span class="co">/// matrix used to transform subset of global parameters</span></span>
<span id="cb21-28"><a href="#cb21-28"></a>  arma::mat <span class="at">const</span> Psi;</span>
<span id="cb21-29"><a href="#cb21-29"></a>  <span class="co">/// number of global parameters</span></span>
<span id="cb21-30"><a href="#cb21-30"></a>  psqn_uint <span class="at">const</span> n_global;</span>
<span id="cb21-31"><a href="#cb21-31"></a>  <span class="co">/// global parameter centroid vector</span></span>
<span id="cb21-32"><a href="#cb21-32"></a>  arma::vec <span class="at">const</span> mu_global;</span>
<span id="cb21-33"><a href="#cb21-33"></a>  <span class="co">/**</span></span>
<span id="cb21-34"><a href="#cb21-34"></a><span class="co">   true if this element function should compute the terms from the global</span></span>
<span id="cb21-35"><a href="#cb21-35"></a><span class="co">   paramaters */</span></span>
<span id="cb21-36"><a href="#cb21-36"></a>  <span class="dt">bool</span> <span class="at">const</span> comp_global;</span>
<span id="cb21-37"><a href="#cb21-37"></a></span>
<span id="cb21-38"><a href="#cb21-38"></a><span class="kw">public</span>:</span>
<span id="cb21-39"><a href="#cb21-39"></a>  poly_func(List data, arma::vec <span class="at">const</span> &amp;mu_g, <span class="dt">bool</span> <span class="at">const</span> comp_global):</span>
<span id="cb21-40"><a href="#cb21-40"></a>  <span class="va">g_idx</span>     (as&lt;arma::uvec&gt;(data[<span class="st">&quot;g_idx&quot;</span>    ]) - <span class="dv">1</span><span class="bu">L</span>),</span>
<span id="cb21-41"><a href="#cb21-41"></a>  mu_cluster(as&lt;arma::vec&gt;(data[<span class="st">&quot;mu_cluster&quot;</span>])     ),</span>
<span id="cb21-42"><a href="#cb21-42"></a>  Psi       (as&lt;arma::mat&gt;(data[<span class="st">&quot;Psi&quot;</span>       ])     ),</span>
<span id="cb21-43"><a href="#cb21-43"></a>  n_global(mu_g.n_elem),</span>
<span id="cb21-44"><a href="#cb21-44"></a>  mu_global(comp_global ? mu_g : arma::vec() ),</span>
<span id="cb21-45"><a href="#cb21-45"></a>  comp_global(comp_global)</span>
<span id="cb21-46"><a href="#cb21-46"></a>  { }</span>
<span id="cb21-47"><a href="#cb21-47"></a></span>
<span id="cb21-48"><a href="#cb21-48"></a>  psqn_uint global_dim() <span class="at">const</span> {</span>
<span id="cb21-49"><a href="#cb21-49"></a>    <span class="cf">return</span> n_global;</span>
<span id="cb21-50"><a href="#cb21-50"></a>  }</span>
<span id="cb21-51"><a href="#cb21-51"></a>  psqn_uint private_dim() <span class="at">const</span> {</span>
<span id="cb21-52"><a href="#cb21-52"></a>    <span class="cf">return</span> mu_cluster.n_elem;</span>
<span id="cb21-53"><a href="#cb21-53"></a>  }</span>
<span id="cb21-54"><a href="#cb21-54"></a></span>
<span id="cb21-55"><a href="#cb21-55"></a>  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</span>
<span id="cb21-56"><a href="#cb21-56"></a>    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</span>
<span id="cb21-57"><a href="#cb21-57"></a>                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</span>
<span id="cb21-58"><a href="#cb21-58"></a>                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</span>
<span id="cb21-59"><a href="#cb21-59"></a></span>
<span id="cb21-60"><a href="#cb21-60"></a>    <span class="co">// compute the function</span></span>
<span id="cb21-61"><a href="#cb21-61"></a>    <span class="dt">double</span> out(<span class="dv">0</span>);</span>
<span id="cb21-62"><a href="#cb21-62"></a>    out += arma::dot(delta, delta);</span>
<span id="cb21-63"><a href="#cb21-63"></a></span>
<span id="cb21-64"><a href="#cb21-64"></a>    <span class="cf">if</span>(comp_global)</span>
<span id="cb21-65"><a href="#cb21-65"></a>      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</span>
<span id="cb21-66"><a href="#cb21-66"></a></span>
<span id="cb21-67"><a href="#cb21-67"></a>    <span class="cf">return</span> out;</span>
<span id="cb21-68"><a href="#cb21-68"></a>  }</span>
<span id="cb21-69"><a href="#cb21-69"></a></span>
<span id="cb21-70"><a href="#cb21-70"></a>  <span class="dt">double</span> grad</span>
<span id="cb21-71"><a href="#cb21-71"></a>  (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</span>
<span id="cb21-72"><a href="#cb21-72"></a>    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</span>
<span id="cb21-73"><a href="#cb21-73"></a>                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</span>
<span id="cb21-74"><a href="#cb21-74"></a>                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</span>
<span id="cb21-75"><a href="#cb21-75"></a></span>
<span id="cb21-76"><a href="#cb21-76"></a>    <span class="co">// create objects to write to for the gradient</span></span>
<span id="cb21-77"><a href="#cb21-77"></a>    <span class="bu">std::</span>fill(gr, gr + x_glob.n_elem, <span class="fl">0.</span>);</span>
<span id="cb21-78"><a href="#cb21-78"></a>    arma::vec d_glob(gr                , x_glob.n_elem, <span class="kw">false</span>),</span>
<span id="cb21-79"><a href="#cb21-79"></a>              d_priv(gr + x_glob.n_elem, x_priv.n_elem, <span class="kw">false</span>);</span>
<span id="cb21-80"><a href="#cb21-80"></a></span>
<span id="cb21-81"><a href="#cb21-81"></a>    <span class="co">// compute the function and the gradient</span></span>
<span id="cb21-82"><a href="#cb21-82"></a>    <span class="dt">double</span> out(<span class="dv">0</span>);</span>
<span id="cb21-83"><a href="#cb21-83"></a>    out += arma::dot(delta, delta);</span>
<span id="cb21-84"><a href="#cb21-84"></a>    d_glob(<span class="va">g_idx</span>) -= <span class="dv">2</span> * Psi.t() * delta;</span>
<span id="cb21-85"><a href="#cb21-85"></a>    d_priv         = <span class="dv">2</span> * delta;</span>
<span id="cb21-86"><a href="#cb21-86"></a></span>
<span id="cb21-87"><a href="#cb21-87"></a>    <span class="cf">if</span>(comp_global){</span>
<span id="cb21-88"><a href="#cb21-88"></a>      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</span>
<span id="cb21-89"><a href="#cb21-89"></a>      d_glob += <span class="fl">2.</span> * x_glob;</span>
<span id="cb21-90"><a href="#cb21-90"></a>      d_glob -= <span class="dv">2</span> * mu_global;</span>
<span id="cb21-91"><a href="#cb21-91"></a>    }</span>
<span id="cb21-92"><a href="#cb21-92"></a></span>
<span id="cb21-93"><a href="#cb21-93"></a>    <span class="cf">return</span> out;</span>
<span id="cb21-94"><a href="#cb21-94"></a>  }</span>
<span id="cb21-95"><a href="#cb21-95"></a></span>
<span id="cb21-96"><a href="#cb21-96"></a>  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</span>
<span id="cb21-97"><a href="#cb21-97"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb21-98"><a href="#cb21-98"></a>  }</span>
<span id="cb21-99"><a href="#cb21-99"></a>};</span>
<span id="cb21-100"><a href="#cb21-100"></a></span>
<span id="cb21-101"><a href="#cb21-101"></a><span class="kw">using</span> poly_optim = PSQN::optimizer&lt;poly_func, PSQN::R_reporter,</span>
<span id="cb21-102"><a href="#cb21-102"></a>                                   PSQN::R_interrupter&gt;;</span>
<span id="cb21-103"><a href="#cb21-103"></a></span>
<span id="cb21-104"><a href="#cb21-104"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb21-105"><a href="#cb21-105"></a>SEXP get_poly_optimizer(List data, arma::vec <span class="at">const</span> &amp;mu_global,</span>
<span id="cb21-106"><a href="#cb21-106"></a>                        <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</span>
<span id="cb21-107"><a href="#cb21-107"></a>  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</span>
<span id="cb21-108"><a href="#cb21-108"></a>  <span class="bu">std::</span>vector&lt;poly_func&gt; funcs;</span>
<span id="cb21-109"><a href="#cb21-109"></a>  funcs.reserve(n_elem_funcs);</span>
<span id="cb21-110"><a href="#cb21-110"></a>  <span class="dt">bool</span> comp_global(<span class="kw">true</span>);</span>
<span id="cb21-111"><a href="#cb21-111"></a>  <span class="cf">for</span>(<span class="kw">auto</span> dat : data){</span>
<span id="cb21-112"><a href="#cb21-112"></a>    funcs.emplace_back(List(dat), mu_global, comp_global);</span>
<span id="cb21-113"><a href="#cb21-113"></a>    comp_global = <span class="kw">false</span>;</span>
<span id="cb21-114"><a href="#cb21-114"></a>  }</span>
<span id="cb21-115"><a href="#cb21-115"></a></span>
<span id="cb21-116"><a href="#cb21-116"></a>  <span class="co">// create an XPtr to the object we will need</span></span>
<span id="cb21-117"><a href="#cb21-117"></a>  XPtr&lt;poly_optim&gt;ptr(<span class="kw">new</span> poly_optim(funcs, max_threads));</span>
<span id="cb21-118"><a href="#cb21-118"></a></span>
<span id="cb21-119"><a href="#cb21-119"></a>  <span class="co">// return the pointer to be used later</span></span>
<span id="cb21-120"><a href="#cb21-120"></a>  <span class="cf">return</span> ptr;</span>
<span id="cb21-121"><a href="#cb21-121"></a>}</span>
<span id="cb21-122"><a href="#cb21-122"></a></span>
<span id="cb21-123"><a href="#cb21-123"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb21-124"><a href="#cb21-124"></a>List optim_poly</span>
<span id="cb21-125"><a href="#cb21-125"></a>  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</span>
<span id="cb21-126"><a href="#cb21-126"></a>   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</span>
<span id="cb21-127"><a href="#cb21-127"></a>   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</span>
<span id="cb21-128"><a href="#cb21-128"></a>   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</span>
<span id="cb21-129"><a href="#cb21-129"></a>   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</span>
<span id="cb21-130"><a href="#cb21-130"></a>  XPtr&lt;poly_optim&gt; optim(ptr);</span>
<span id="cb21-131"><a href="#cb21-131"></a></span>
<span id="cb21-132"><a href="#cb21-132"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb21-133"><a href="#cb21-133"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb21-134"><a href="#cb21-134"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_poly: invalid parameter size&quot;</span>);</span>
<span id="cb21-135"><a href="#cb21-135"></a></span>
<span id="cb21-136"><a href="#cb21-136"></a>  NumericVector par = clone(val);</span>
<span id="cb21-137"><a href="#cb21-137"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb21-138"><a href="#cb21-138"></a>  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</span>
<span id="cb21-139"><a href="#cb21-139"></a>                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</span>
<span id="cb21-140"><a href="#cb21-140"></a>                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</span>
<span id="cb21-141"><a href="#cb21-141"></a>  NumericVector counts = NumericVector::create(</span>
<span id="cb21-142"><a href="#cb21-142"></a>    res.n_eval, res.n_grad,  res.n_cg);</span>
<span id="cb21-143"><a href="#cb21-143"></a>  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</span>
<span id="cb21-144"><a href="#cb21-144"></a></span>
<span id="cb21-145"><a href="#cb21-145"></a>  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</span>
<span id="cb21-146"><a href="#cb21-146"></a>  <span class="cf">return</span> List::create(</span>
<span id="cb21-147"><a href="#cb21-147"></a>    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</span>
<span id="cb21-148"><a href="#cb21-148"></a>      _[<span class="st">&quot;counts&quot;</span>] = counts,</span>
<span id="cb21-149"><a href="#cb21-149"></a>      _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged);</span>
<span id="cb21-150"><a href="#cb21-150"></a>}</span>
<span id="cb21-151"><a href="#cb21-151"></a></span>
<span id="cb21-152"><a href="#cb21-152"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb21-153"><a href="#cb21-153"></a><span class="dt">double</span> eval_poly(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb21-154"><a href="#cb21-154"></a>  XPtr&lt;poly_optim&gt; optim(ptr);</span>
<span id="cb21-155"><a href="#cb21-155"></a></span>
<span id="cb21-156"><a href="#cb21-156"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb21-157"><a href="#cb21-157"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb21-158"><a href="#cb21-158"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_poly: invalid parameter size&quot;</span>);</span>
<span id="cb21-159"><a href="#cb21-159"></a></span>
<span id="cb21-160"><a href="#cb21-160"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb21-161"><a href="#cb21-161"></a>  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</span>
<span id="cb21-162"><a href="#cb21-162"></a>}</span>
<span id="cb21-163"><a href="#cb21-163"></a></span>
<span id="cb21-164"><a href="#cb21-164"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb21-165"><a href="#cb21-165"></a>NumericVector grad_poly(NumericVector val, SEXP ptr,</span>
<span id="cb21-166"><a href="#cb21-166"></a>                        <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb21-167"><a href="#cb21-167"></a>  XPtr&lt;poly_optim&gt; optim(ptr);</span>
<span id="cb21-168"><a href="#cb21-168"></a></span>
<span id="cb21-169"><a href="#cb21-169"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb21-170"><a href="#cb21-170"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb21-171"><a href="#cb21-171"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_poly: invalid parameter size&quot;</span>);</span>
<span id="cb21-172"><a href="#cb21-172"></a></span>
<span id="cb21-173"><a href="#cb21-173"></a>  NumericVector grad(val.size());</span>
<span id="cb21-174"><a href="#cb21-174"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb21-175"><a href="#cb21-175"></a>  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</span>
<span id="cb21-176"><a href="#cb21-176"></a></span>
<span id="cb21-177"><a href="#cb21-177"></a>  <span class="cf">return</span> grad;</span>
<span id="cb21-178"><a href="#cb21-178"></a>}</span></code></pre></div>
<p>We can <code>Rcpp::sourceCpp</code> the file and use the code like below to find the solution:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">library</span>(Rcpp)</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;poly-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="co"># get a pointer to C++ object</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>optimizer &lt;-<span class="st"> </span><span class="kw">get_poly_optimizer</span>(cluster_dat, <span class="dt">mu_global =</span> mu_global, </span>
<span id="cb22-6"><a href="#cb22-6"></a>                                <span class="dt">max_threads =</span> 2L)</span>
<span id="cb22-7"><a href="#cb22-7"></a></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="co"># we get the same function value and gradient</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="kw">all.equal</span>(<span class="kw">fn</span>       (tmp), </span>
<span id="cb22-11"><a href="#cb22-11"></a>          <span class="kw">eval_poly</span>(tmp, optimizer, 1L))</span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="kw">all.equal</span>(<span class="kw">gr</span>       (tmp), </span>
<span id="cb22-14"><a href="#cb22-14"></a>          <span class="kw">grad_poly</span>(tmp, optimizer, 1L), </span>
<span id="cb22-15"><a href="#cb22-15"></a>          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb22-17"><a href="#cb22-17"></a></span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="co"># run the optimization</span></span>
<span id="cb22-19"><a href="#cb22-19"></a>psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </span>
<span id="cb22-20"><a href="#cb22-20"></a>                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L)</span>
<span id="cb22-21"><a href="#cb22-21"></a>  <span class="kw">optim_poly</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="fl">1e-8</span>, <span class="dt">max_it =</span> 1000L, </span>
<span id="cb22-22"><a href="#cb22-22"></a>             <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </span>
<span id="cb22-23"><a href="#cb22-23"></a>             <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace)</span>
<span id="cb22-24"><a href="#cb22-24"></a></span>
<span id="cb22-25"><a href="#cb22-25"></a>psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(<span class="kw">numeric</span>(idx_start))</span>
<span id="cb22-26"><a href="#cb22-26"></a><span class="kw">all.equal</span>(exp_res, psqn_res<span class="op">$</span>par)</span>
<span id="cb22-27"><a href="#cb22-27"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>A version using the R function <code>psqn</code> is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># assign function to pass to psqn</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</span>
<span id="cb23-3"><a href="#cb23-3"></a>  dat &lt;-<span class="st"> </span>cluster_dat[[i]]</span>
<span id="cb23-4"><a href="#cb23-4"></a>  g_idx &lt;-<span class="st"> </span>dat<span class="op">$</span>g_idx</span>
<span id="cb23-5"><a href="#cb23-5"></a>  mu_cluster &lt;-<span class="st"> </span>dat<span class="op">$</span>mu_cluster</span>
<span id="cb23-6"><a href="#cb23-6"></a>  Psi &lt;-<span class="st"> </span>dat<span class="op">$</span>Psi</span>
<span id="cb23-7"><a href="#cb23-7"></a>  </span>
<span id="cb23-8"><a href="#cb23-8"></a>  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb23-9"><a href="#cb23-9"></a>    <span class="co"># requested the dimension of the parameter</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">length</span>(mu_global), </span>
<span id="cb23-11"><a href="#cb23-11"></a>             <span class="dt">private_dim =</span> <span class="kw">length</span>(mu_cluster)))</span>
<span id="cb23-12"><a href="#cb23-12"></a>  </span>
<span id="cb23-13"><a href="#cb23-13"></a>  is_glob &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(mu_global)</span>
<span id="cb23-14"><a href="#cb23-14"></a>  x_glob &lt;-<span class="st"> </span>par[is_glob]</span>
<span id="cb23-15"><a href="#cb23-15"></a>  x_priv &lt;-<span class="st"> </span>par[<span class="op">-</span>is_glob]</span>
<span id="cb23-16"><a href="#cb23-16"></a>  </span>
<span id="cb23-17"><a href="#cb23-17"></a>  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(x_priv <span class="op">-</span><span class="st"> </span>Psi <span class="op">%*%</span><span class="st"> </span>x_glob[g_idx] <span class="op">-</span><span class="st"> </span>mu_cluster)</span>
<span id="cb23-18"><a href="#cb23-18"></a>  </span>
<span id="cb23-19"><a href="#cb23-19"></a>  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</span>
<span id="cb23-20"><a href="#cb23-20"></a>  <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L){</span>
<span id="cb23-21"><a href="#cb23-21"></a>    delta_glob &lt;-<span class="st"> </span>x_glob <span class="op">-</span><span class="st"> </span>mu_global</span>
<span id="cb23-22"><a href="#cb23-22"></a>    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta_glob <span class="op">%*%</span><span class="st"> </span>delta_glob)</span>
<span id="cb23-23"><a href="#cb23-23"></a>  }</span>
<span id="cb23-24"><a href="#cb23-24"></a>  </span>
<span id="cb23-25"><a href="#cb23-25"></a>  <span class="cf">if</span>(comp_grad){</span>
<span id="cb23-26"><a href="#cb23-26"></a>    grad &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(mu_cluster) <span class="op">+</span><span class="st"> </span><span class="kw">length</span>(mu_global))</span>
<span id="cb23-27"><a href="#cb23-27"></a>    grad[g_idx] &lt;-<span class="st"> </span><span class="dv">-2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(Psi, delta))</span>
<span id="cb23-28"><a href="#cb23-28"></a>    grad[<span class="op">-</span>is_glob] &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta</span>
<span id="cb23-29"><a href="#cb23-29"></a>    <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L)</span>
<span id="cb23-30"><a href="#cb23-30"></a>      grad[is_glob] &lt;-<span class="st"> </span>grad[is_glob] <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta_glob</span>
<span id="cb23-31"><a href="#cb23-31"></a>    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</span>
<span id="cb23-32"><a href="#cb23-32"></a>  }</span>
<span id="cb23-33"><a href="#cb23-33"></a>  </span>
<span id="cb23-34"><a href="#cb23-34"></a>  out</span>
<span id="cb23-35"><a href="#cb23-35"></a>}</span>
<span id="cb23-36"><a href="#cb23-36"></a></span>
<span id="cb23-37"><a href="#cb23-37"></a><span class="co"># use the function</span></span>
<span id="cb23-38"><a href="#cb23-38"></a>r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">cg_tol =</span> <span class="fl">.5</span>,</span>
<span id="cb23-39"><a href="#cb23-39"></a>                        <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L, <span class="dt">pre_method =</span> 1L)</span>
<span id="cb23-40"><a href="#cb23-40"></a>  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </span>
<span id="cb23-41"><a href="#cb23-41"></a>       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">cg_tol =</span> cg_tol,</span>
<span id="cb23-42"><a href="#cb23-42"></a>       <span class="dt">trace =</span> trace, <span class="dt">max_it =</span> 1000L, <span class="dt">pre_method =</span> pre_method)</span>
<span id="cb23-43"><a href="#cb23-43"></a></span>
<span id="cb23-44"><a href="#cb23-44"></a>R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(<span class="kw">numeric</span>(idx_start))</span>
<span id="cb23-45"><a href="#cb23-45"></a><span class="kw">all.equal</span>(exp_res, R_res<span class="op">$</span>par)</span>
<span id="cb23-46"><a href="#cb23-46"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div id="generic-example" class="section level3">
<h3>Generic Example</h3>
<p>We will provide a toy example of a problem which is partially separable but which does not have the same structure as the problems we have shown before. The problem we consider is:</p>
<p><span class="math display">\[
\begin{align*}
f(\vec x) &amp;= \sum_{i = 1}^n
  -y_i \sum_{j = 1}^{L_i} x_{k_{ij}}
  +\exp\left(\sum_{j = 1}^{L_i} x_{k_{ij}}\right)
  , \qquad \vec x\in\mathbb R^K \\
\mathcal K_i &amp;= \{k_{i1} , \dots, k_{iL_i}\} \subseteq \{1, \dots, K\}.
\end{align*}
\]</span> This is a special kind of a GLM with a Poison model with the log link. While there are other ways to estimate this model, we will mainly compare the BFGS implementation from <code>optim</code> with the psqn package. For some <span class="math inline">\(j\neq i\)</span>, we will have that <span class="math inline">\(\mathcal K_i \cap \mathcal K_j \neq \emptyset\)</span> without much structure in their intersection unlike before.</p>
<p>There is a class called <code>optimizer_generic</code> provided by the psqn package which can work with more general partially separable problems like the one above. This though yields some additional computational overhead. A C++ implementation to work with the function stated above using the <code>optimizer_generic</code> class is in the <code>generic_example.cpp</code> file which is shown below:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">// see `mlogit-ex.cpp` for an example with more comments</span></span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">// we will use OpenMP to perform the computation in parallel</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="co">// we change the unsigned integer type that is used by the package by defining</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="co">// the PSQN_SIZE_T macro variable</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="pp">#define PSQN_SIZE_T </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">int</span></span>
<span id="cb24-9"><a href="#cb24-9"></a></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="co">// we want to use the incomplete Cholesky factorization as the preconditioner</span></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="co">// and therefore with need RcppEigen</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="pp">#define PSQN_USE_EIGEN</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="co">// [[Rcpp::depends(RcppEigen)]]</span></span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="co">// [[Rcpp::depends(psqn)]]</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="pp">#include </span><span class="im">&quot;psqn-Rcpp-wrapper.h&quot;</span></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></span>
<span id="cb24-19"><a href="#cb24-19"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb24-20"><a href="#cb24-20"></a><span class="kw">using</span> PSQN::psqn_uint; <span class="co">// the unsigned integer type used in the package</span></span>
<span id="cb24-21"><a href="#cb24-21"></a></span>
<span id="cb24-22"><a href="#cb24-22"></a><span class="kw">class</span> generic_example <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function_generic {</span>
<span id="cb24-23"><a href="#cb24-23"></a>  <span class="co">/// number of argument to this element function;</span></span>
<span id="cb24-24"><a href="#cb24-24"></a>  psqn_uint <span class="at">const</span> n_args_val;</span>
<span id="cb24-25"><a href="#cb24-25"></a>  <span class="co">/// indices of the element function parameters</span></span>
<span id="cb24-26"><a href="#cb24-26"></a>  <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; indices_array;</span>
<span id="cb24-27"><a href="#cb24-27"></a>  <span class="co">/// y point</span></span>
<span id="cb24-28"><a href="#cb24-28"></a>  <span class="dt">double</span> <span class="at">const</span> y;</span>
<span id="cb24-29"><a href="#cb24-29"></a></span>
<span id="cb24-30"><a href="#cb24-30"></a><span class="kw">public</span>:</span>
<span id="cb24-31"><a href="#cb24-31"></a>  generic_example(List data):</span>
<span id="cb24-32"><a href="#cb24-32"></a>  n_args_val(as&lt;IntegerVector&gt;(data[<span class="st">&quot;indices&quot;</span>]).size()),</span>
<span id="cb24-33"><a href="#cb24-33"></a>  indices_array(([&amp;]() -&gt; <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; {</span>
<span id="cb24-34"><a href="#cb24-34"></a>    IntegerVector indices = as&lt;IntegerVector&gt;(data[<span class="st">&quot;indices&quot;</span>]);</span>
<span id="cb24-35"><a href="#cb24-35"></a>    <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; out(<span class="kw">new</span> psqn_uint[n_args_val]);</span>
<span id="cb24-36"><a href="#cb24-36"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</span>
<span id="cb24-37"><a href="#cb24-37"></a>      out[i] = indices[i];</span>
<span id="cb24-38"><a href="#cb24-38"></a>    <span class="cf">return</span> out;</span>
<span id="cb24-39"><a href="#cb24-39"></a>  })()),</span>
<span id="cb24-40"><a href="#cb24-40"></a>  y(as&lt;<span class="dt">double</span>&gt;(data[<span class="st">&quot;y&quot;</span>]))</span>
<span id="cb24-41"><a href="#cb24-41"></a>  { }</span>
<span id="cb24-42"><a href="#cb24-42"></a></span>
<span id="cb24-43"><a href="#cb24-43"></a>  <span class="co">// we need to make a copy constructor because of the unique_ptr</span></span>
<span id="cb24-44"><a href="#cb24-44"></a>  generic_example(generic_example <span class="at">const</span> &amp;other):</span>
<span id="cb24-45"><a href="#cb24-45"></a>  n_args_val(other.n_args_val),</span>
<span id="cb24-46"><a href="#cb24-46"></a>  indices_array(([&amp;]() -&gt; <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; {</span>
<span id="cb24-47"><a href="#cb24-47"></a>    <span class="bu">std::</span>unique_ptr&lt;psqn_uint[]&gt; out(<span class="kw">new</span> psqn_uint[n_args_val]);</span>
<span id="cb24-48"><a href="#cb24-48"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</span>
<span id="cb24-49"><a href="#cb24-49"></a>      out[i] = other.indices_array[i];</span>
<span id="cb24-50"><a href="#cb24-50"></a>    <span class="cf">return</span> out;</span>
<span id="cb24-51"><a href="#cb24-51"></a>  })()),</span>
<span id="cb24-52"><a href="#cb24-52"></a>  y(other.y) { }</span>
<span id="cb24-53"><a href="#cb24-53"></a></span>
<span id="cb24-54"><a href="#cb24-54"></a>  <span class="co">/**</span></span>
<span id="cb24-55"><a href="#cb24-55"></a><span class="co">   returns the number of parameters that this element function is depending on.</span></span>
<span id="cb24-56"><a href="#cb24-56"></a><span class="co">   */</span></span>
<span id="cb24-57"><a href="#cb24-57"></a>  psqn_uint n_args() <span class="at">const</span> {</span>
<span id="cb24-58"><a href="#cb24-58"></a>    <span class="cf">return</span> n_args_val;</span>
<span id="cb24-59"><a href="#cb24-59"></a>  }</span>
<span id="cb24-60"><a href="#cb24-60"></a></span>
<span id="cb24-61"><a href="#cb24-61"></a>  <span class="co">/**</span></span>
<span id="cb24-62"><a href="#cb24-62"></a><span class="co">   zero-based indices to the parameters that this element function is depending</span></span>
<span id="cb24-63"><a href="#cb24-63"></a><span class="co">   on.</span></span>
<span id="cb24-64"><a href="#cb24-64"></a><span class="co">   */</span></span>
<span id="cb24-65"><a href="#cb24-65"></a>  psqn_uint <span class="at">const</span> * indices() <span class="at">const</span> {</span>
<span id="cb24-66"><a href="#cb24-66"></a>    <span class="cf">return</span> indices_array.get();</span>
<span id="cb24-67"><a href="#cb24-67"></a>  }</span>
<span id="cb24-68"><a href="#cb24-68"></a></span>
<span id="cb24-69"><a href="#cb24-69"></a>  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> * point) <span class="at">const</span> {</span>
<span id="cb24-70"><a href="#cb24-70"></a>    <span class="dt">double</span> sum(<span class="fl">0.</span>);</span>
<span id="cb24-71"><a href="#cb24-71"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</span>
<span id="cb24-72"><a href="#cb24-72"></a>      sum += point[i];</span>
<span id="cb24-73"><a href="#cb24-73"></a>    <span class="cf">return</span> -y * sum + <span class="bu">std::</span>exp(sum);</span>
<span id="cb24-74"><a href="#cb24-74"></a>  }</span>
<span id="cb24-75"><a href="#cb24-75"></a></span>
<span id="cb24-76"><a href="#cb24-76"></a>  <span class="dt">double</span> grad</span>
<span id="cb24-77"><a href="#cb24-77"></a>  (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</span>
<span id="cb24-78"><a href="#cb24-78"></a>    <span class="dt">double</span> sum(<span class="fl">0.</span>);</span>
<span id="cb24-79"><a href="#cb24-79"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</span>
<span id="cb24-80"><a href="#cb24-80"></a>      sum += point[i];</span>
<span id="cb24-81"><a href="#cb24-81"></a>    <span class="dt">double</span> <span class="at">const</span> exp_sum = <span class="bu">std::</span>exp(sum),</span>
<span id="cb24-82"><a href="#cb24-82"></a>                    fact = -y + exp_sum;</span>
<span id="cb24-83"><a href="#cb24-83"></a>    <span class="cf">for</span>(psqn_uint i = <span class="dv">0</span>; i &lt; n_args_val; ++i)</span>
<span id="cb24-84"><a href="#cb24-84"></a>      gr[i] = fact;</span>
<span id="cb24-85"><a href="#cb24-85"></a></span>
<span id="cb24-86"><a href="#cb24-86"></a>    <span class="cf">return</span> -y * sum + <span class="bu">std::</span>exp(sum);</span>
<span id="cb24-87"><a href="#cb24-87"></a>  }</span>
<span id="cb24-88"><a href="#cb24-88"></a></span>
<span id="cb24-89"><a href="#cb24-89"></a>  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</span>
<span id="cb24-90"><a href="#cb24-90"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb24-91"><a href="#cb24-91"></a>  }</span>
<span id="cb24-92"><a href="#cb24-92"></a>};</span>
<span id="cb24-93"><a href="#cb24-93"></a></span>
<span id="cb24-94"><a href="#cb24-94"></a><span class="kw">using</span> generic_opt =</span>
<span id="cb24-95"><a href="#cb24-95"></a>  PSQN::optimizer_generic&lt;generic_example, PSQN::R_reporter,</span>
<span id="cb24-96"><a href="#cb24-96"></a>                          PSQN::R_interrupter&gt;;</span>
<span id="cb24-97"><a href="#cb24-97"></a></span>
<span id="cb24-98"><a href="#cb24-98"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-99"><a href="#cb24-99"></a>SEXP get_generic_ex_obj(List data, <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</span>
<span id="cb24-100"><a href="#cb24-100"></a>  psqn_uint <span class="at">const</span> n_elem_funcs = data.size();</span>
<span id="cb24-101"><a href="#cb24-101"></a>  <span class="bu">std::</span>vector&lt;generic_example&gt; funcs;</span>
<span id="cb24-102"><a href="#cb24-102"></a>  funcs.reserve(n_elem_funcs);</span>
<span id="cb24-103"><a href="#cb24-103"></a>  <span class="cf">for</span>(<span class="kw">auto</span> dat : data)</span>
<span id="cb24-104"><a href="#cb24-104"></a>    funcs.emplace_back(List(dat));</span>
<span id="cb24-105"><a href="#cb24-105"></a></span>
<span id="cb24-106"><a href="#cb24-106"></a>  <span class="co">// create an XPtr to the object we will need</span></span>
<span id="cb24-107"><a href="#cb24-107"></a>  XPtr&lt;generic_opt&gt;ptr(<span class="kw">new</span> generic_opt(funcs, max_threads));</span>
<span id="cb24-108"><a href="#cb24-108"></a></span>
<span id="cb24-109"><a href="#cb24-109"></a>  <span class="co">// return the pointer to be used later</span></span>
<span id="cb24-110"><a href="#cb24-110"></a>  <span class="cf">return</span> ptr;</span>
<span id="cb24-111"><a href="#cb24-111"></a>}</span>
<span id="cb24-112"><a href="#cb24-112"></a></span>
<span id="cb24-113"><a href="#cb24-113"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-114"><a href="#cb24-114"></a>List optim_generic_ex</span>
<span id="cb24-115"><a href="#cb24-115"></a>  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</span>
<span id="cb24-116"><a href="#cb24-116"></a>   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</span>
<span id="cb24-117"><a href="#cb24-117"></a>   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0</span><span class="bu">L</span>,</span>
<span id="cb24-118"><a href="#cb24-118"></a>   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</span>
<span id="cb24-119"><a href="#cb24-119"></a>   psqn_uint <span class="at">const</span> max_cg = <span class="dv">0</span><span class="bu">L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1</span><span class="bu">L</span>){</span>
<span id="cb24-120"><a href="#cb24-120"></a>  XPtr&lt;generic_opt&gt; optim(ptr);</span>
<span id="cb24-121"><a href="#cb24-121"></a></span>
<span id="cb24-122"><a href="#cb24-122"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb24-123"><a href="#cb24-123"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb24-124"><a href="#cb24-124"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_generic_ex: invalid parameter size&quot;</span>);</span>
<span id="cb24-125"><a href="#cb24-125"></a></span>
<span id="cb24-126"><a href="#cb24-126"></a>  NumericVector par = clone(val);</span>
<span id="cb24-127"><a href="#cb24-127"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb24-128"><a href="#cb24-128"></a>  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</span>
<span id="cb24-129"><a href="#cb24-129"></a>                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</span>
<span id="cb24-130"><a href="#cb24-130"></a>                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</span>
<span id="cb24-131"><a href="#cb24-131"></a>  NumericVector counts = NumericVector::create(</span>
<span id="cb24-132"><a href="#cb24-132"></a>    res.n_eval, res.n_grad,  res.n_cg);</span>
<span id="cb24-133"><a href="#cb24-133"></a>  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</span>
<span id="cb24-134"><a href="#cb24-134"></a></span>
<span id="cb24-135"><a href="#cb24-135"></a>  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</span>
<span id="cb24-136"><a href="#cb24-136"></a>  <span class="cf">return</span> List::create(</span>
<span id="cb24-137"><a href="#cb24-137"></a>    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</span>
<span id="cb24-138"><a href="#cb24-138"></a>      _[<span class="st">&quot;counts&quot;</span>] = counts,</span>
<span id="cb24-139"><a href="#cb24-139"></a>      _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged);</span>
<span id="cb24-140"><a href="#cb24-140"></a>}</span>
<span id="cb24-141"><a href="#cb24-141"></a></span>
<span id="cb24-142"><a href="#cb24-142"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-143"><a href="#cb24-143"></a><span class="dt">double</span> eval_generic_ex(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb24-144"><a href="#cb24-144"></a>  XPtr&lt;generic_opt&gt; optim(ptr);</span>
<span id="cb24-145"><a href="#cb24-145"></a></span>
<span id="cb24-146"><a href="#cb24-146"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb24-147"><a href="#cb24-147"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb24-148"><a href="#cb24-148"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_generic_ex: invalid parameter size&quot;</span>);</span>
<span id="cb24-149"><a href="#cb24-149"></a></span>
<span id="cb24-150"><a href="#cb24-150"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb24-151"><a href="#cb24-151"></a>  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</span>
<span id="cb24-152"><a href="#cb24-152"></a>}</span>
<span id="cb24-153"><a href="#cb24-153"></a></span>
<span id="cb24-154"><a href="#cb24-154"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-155"><a href="#cb24-155"></a>NumericVector grad_generic_ex(NumericVector val, SEXP ptr,</span>
<span id="cb24-156"><a href="#cb24-156"></a>                              <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</span>
<span id="cb24-157"><a href="#cb24-157"></a>  XPtr&lt;generic_opt&gt; optim(ptr);</span>
<span id="cb24-158"><a href="#cb24-158"></a></span>
<span id="cb24-159"><a href="#cb24-159"></a>  <span class="co">// check that we pass a parameter value of the right length</span></span>
<span id="cb24-160"><a href="#cb24-160"></a>  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;psqn_uint&gt;(val.size()))</span>
<span id="cb24-161"><a href="#cb24-161"></a>    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_generic_ex: invalid parameter size&quot;</span>);</span>
<span id="cb24-162"><a href="#cb24-162"></a></span>
<span id="cb24-163"><a href="#cb24-163"></a>  NumericVector grad(val.size());</span>
<span id="cb24-164"><a href="#cb24-164"></a>  optim-&gt;set_n_threads(n_threads);</span>
<span id="cb24-165"><a href="#cb24-165"></a>  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</span>
<span id="cb24-166"><a href="#cb24-166"></a></span>
<span id="cb24-167"><a href="#cb24-167"></a>  <span class="cf">return</span> grad;</span>
<span id="cb24-168"><a href="#cb24-168"></a>}</span>
<span id="cb24-169"><a href="#cb24-169"></a></span>
<span id="cb24-170"><a href="#cb24-170"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-171"><a href="#cb24-171"></a>NumericMatrix get_Hess_approx_generic(SEXP ptr){</span>
<span id="cb24-172"><a href="#cb24-172"></a>  XPtr&lt;generic_opt&gt; optim(ptr);</span>
<span id="cb24-173"><a href="#cb24-173"></a></span>
<span id="cb24-174"><a href="#cb24-174"></a>  NumericMatrix out(optim-&gt;n_par, optim-&gt;n_par);</span>
<span id="cb24-175"><a href="#cb24-175"></a>  optim-&gt;get_hess(&amp;out[<span class="dv">0</span>]);</span>
<span id="cb24-176"><a href="#cb24-176"></a></span>
<span id="cb24-177"><a href="#cb24-177"></a>  <span class="cf">return</span> out;</span>
<span id="cb24-178"><a href="#cb24-178"></a>}</span>
<span id="cb24-179"><a href="#cb24-179"></a></span>
<span id="cb24-180"><a href="#cb24-180"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb24-181"><a href="#cb24-181"></a>Eigen::SparseMatrix&lt;<span class="dt">double</span>&gt; get_sparse_Hess_approx_generic(SEXP ptr){</span>
<span id="cb24-182"><a href="#cb24-182"></a>  <span class="cf">return</span> XPtr&lt;generic_opt&gt;(ptr)-&gt;get_hess_sparse();</span>
<span id="cb24-183"><a href="#cb24-183"></a>}</span></code></pre></div>
<p>The required member functions are very similar to those needed for the <code>optimizer</code> class. We now simulate some data to work with this type of model as an example:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># parameters for the simulation</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb25-3"><a href="#cb25-3"></a>K &lt;-<span class="st"> </span>2000L</span>
<span id="cb25-4"><a href="#cb25-4"></a>n &lt;-<span class="st"> </span>5L <span class="op">*</span><span class="st"> </span>K</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co"># simulate the data</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>truth_limit &lt;-<span class="st"> </span><span class="kw">runif</span>(K, <span class="dv">-1</span>, <span class="dv">1</span>)</span>
<span id="cb25-8"><a href="#cb25-8"></a>dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(</span>
<span id="cb25-9"><a href="#cb25-9"></a>  n, {</span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="co"># sample the indices</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    n_samp &lt;-<span class="st"> </span><span class="kw">sample.int</span>(5L, 1L) <span class="op">+</span><span class="st"> </span>1L</span>
<span id="cb25-12"><a href="#cb25-12"></a>    indices &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">sample.int</span>(K, n_samp))</span>
<span id="cb25-13"><a href="#cb25-13"></a></span>
<span id="cb25-14"><a href="#cb25-14"></a>    <span class="co"># sample the outcome, y, and return    </span></span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="kw">list</span>(<span class="dt">y =</span> <span class="kw">rpois</span>(<span class="dv">1</span>, <span class="kw">exp</span>(<span class="kw">sum</span>(truth_limit[indices]))), </span>
<span id="cb25-16"><a href="#cb25-16"></a>         <span class="dt">indices =</span> indices)</span>
<span id="cb25-17"><a href="#cb25-17"></a>  }, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</span>
<span id="cb25-18"><a href="#cb25-18"></a></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co"># we need each variable to be present at least once</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="kw">stopifnot</span>(<span class="kw">length</span>(<span class="kw">unique</span>(<span class="kw">unlist</span>(</span>
<span id="cb25-21"><a href="#cb25-21"></a>  <span class="kw">lapply</span>(dat, <span class="st">`</span><span class="dt">[</span><span class="st">`</span>, <span class="st">&quot;indices&quot;</span>)</span>
<span id="cb25-22"><a href="#cb25-22"></a>))) <span class="op">==</span><span class="st"> </span>K) <span class="co"># otherwise we need to change the code</span></span></code></pre></div>
<p>We can minimize this problem using the following R code:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="co"># define a version in R to compute the function and its gradient</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>R_func &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb26-3"><a href="#cb26-3"></a>  out &lt;-<span class="st"> </span><span class="kw">vapply</span>(dat, <span class="cf">function</span>(z){</span>
<span id="cb26-4"><a href="#cb26-4"></a>    eta &lt;-<span class="st"> </span><span class="kw">sum</span>(x[z<span class="op">$</span>indices])</span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="op">-</span>z<span class="op">$</span>y <span class="op">*</span><span class="st"> </span>eta <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta)</span>
<span id="cb26-6"><a href="#cb26-6"></a>  }, <span class="fl">0.</span>)</span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="kw">sum</span>(out)</span>
<span id="cb26-8"><a href="#cb26-8"></a>}</span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a>R_func_gr &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb26-11"><a href="#cb26-11"></a>  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</span>
<span id="cb26-12"><a href="#cb26-12"></a>  <span class="cf">for</span>(z <span class="cf">in</span> dat){</span>
<span id="cb26-13"><a href="#cb26-13"></a>    idx_i &lt;-<span class="st"> </span>z<span class="op">$</span>indices </span>
<span id="cb26-14"><a href="#cb26-14"></a>    eta &lt;-<span class="st"> </span><span class="kw">sum</span>(x[idx_i])</span>
<span id="cb26-15"><a href="#cb26-15"></a>    out[idx_i] &lt;-<span class="st"> </span>out[idx_i] <span class="op">-</span>z<span class="op">$</span>y <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta) </span>
<span id="cb26-16"><a href="#cb26-16"></a>  }</span>
<span id="cb26-17"><a href="#cb26-17"></a>  out</span>
<span id="cb26-18"><a href="#cb26-18"></a>}</span>
<span id="cb26-19"><a href="#cb26-19"></a></span>
<span id="cb26-20"><a href="#cb26-20"></a><span class="co"># find the optimum</span></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb26-22"><a href="#cb26-22"></a>start &lt;-<span class="st"> </span>truth_limit <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(K, <span class="dt">sd =</span> <span class="fl">.1</span>)</span>
<span id="cb26-23"><a href="#cb26-23"></a><span class="co"># all.equal(numDeriv::grad(R_func, start), R_func_gr(start))</span></span>
<span id="cb26-24"><a href="#cb26-24"></a>opt &lt;-<span class="st"> </span><span class="kw">optim</span>(start, R_func, R_func_gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, </span>
<span id="cb26-25"><a href="#cb26-25"></a>             <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">maxit =</span> 1000L))</span>
<span id="cb26-26"><a href="#cb26-26"></a>opt<span class="op">$</span>value <span class="co"># optimal solution</span></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="co">#&gt; [1] -8621</span></span></code></pre></div>
<p>The model can also be estimated using <code>glm</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># create the design matrix</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>X &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">vapply</span>(dat, <span class="cf">function</span>(x){</span>
<span id="cb27-3"><a href="#cb27-3"></a>  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(K)</span>
<span id="cb27-4"><a href="#cb27-4"></a>  out[x<span class="op">$</span>indices] &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>  out</span>
<span id="cb27-6"><a href="#cb27-6"></a>}, <span class="kw">numeric</span>(K)))</span>
<span id="cb27-7"><a href="#cb27-7"></a>y &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">sapply</span>(dat, <span class="st">`</span><span class="dt">[[</span><span class="st">`</span>, <span class="st">&quot;y&quot;</span>))</span>
<span id="cb27-8"><a href="#cb27-8"></a></span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="co"># this is very slow...</span></span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="kw">system.time</span>(glm_fit &lt;-<span class="st"> </span><span class="kw">glm.fit</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> y, <span class="dt">family =</span> <span class="kw">poisson</span>(), </span>
<span id="cb27-11"><a href="#cb27-11"></a>                               <span class="dt">start =</span> start))</span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="co">#&gt; 149.892   0.176 150.037</span></span>
<span id="cb27-14"><a href="#cb27-14"></a></span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="co"># we get (roughly) the same</span></span>
<span id="cb27-16"><a href="#cb27-16"></a><span class="kw">all.equal</span>(glm_fit<span class="op">$</span>coefficients, opt<span class="op">$</span>par)</span>
<span id="cb27-17"><a href="#cb27-17"></a><span class="co">#&gt; [1] &quot;Mean relative difference: 9.95e-05&quot;</span></span>
<span id="cb27-18"><a href="#cb27-18"></a><span class="kw">R_func</span>(glm_fit<span class="op">$</span>coefficients)</span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="co">#&gt; [1] -8621</span></span>
<span id="cb27-20"><a href="#cb27-20"></a>glm_fit &lt;-<span class="st"> </span>glm_fit[<span class="kw">c</span>(<span class="st">&quot;coefficients&quot;</span>, <span class="st">&quot;deviance&quot;</span>)]</span>
<span id="cb27-21"><a href="#cb27-21"></a></span>
<span id="cb27-22"><a href="#cb27-22"></a><span class="co"># the objects are quite big so we remove them </span></span>
<span id="cb27-23"><a href="#cb27-23"></a><span class="kw">rm</span>(X, y)</span></code></pre></div>
<p>The above could possibly be done much faster if sparse matrices where used in <code>glm.fit</code>. The problem can also be solved with the C++ implementation using the following code:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a><span class="co"># source the C++ version used in this package</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">library</span>(Rcpp)</span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;generic_example.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</span>
<span id="cb28-4"><a href="#cb28-4"></a></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="co"># create the list to pass to C++</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>cpp_arg &lt;-<span class="st"> </span><span class="kw">lapply</span>(dat, <span class="cf">function</span>(x){</span>
<span id="cb28-7"><a href="#cb28-7"></a>  x<span class="op">$</span>indices &lt;-<span class="st"> </span>x<span class="op">$</span>indices <span class="op">-</span><span class="st"> </span>1L <span class="co"># C++ needs zero-based indices</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>  x</span>
<span id="cb28-9"><a href="#cb28-9"></a>})</span>
<span id="cb28-10"><a href="#cb28-10"></a>ptr &lt;-<span class="st"> </span><span class="kw">get_generic_ex_obj</span>(cpp_arg, <span class="dt">max_threads =</span> 4L)</span>
<span id="cb28-11"><a href="#cb28-11"></a></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="co"># check that we get the same</span></span>
<span id="cb28-13"><a href="#cb28-13"></a>noise &lt;-<span class="st"> </span><span class="kw">rnorm</span>(K)</span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="kw">all.equal</span>(<span class="kw">eval_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb28-15"><a href="#cb28-15"></a>          <span class="kw">R_func</span>         (noise))</span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="kw">all.equal</span>(gv &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L),</span>
<span id="cb28-18"><a href="#cb28-18"></a>          <span class="kw">R_func_gr</span>            (noise), </span>
<span id="cb28-19"><a href="#cb28-19"></a>          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="kw">all.equal</span>(<span class="kw">attr</span>(gv, <span class="st">&quot;value&quot;</span>), <span class="kw">R_func</span>(noise))</span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-23"><a href="#cb28-23"></a></span>
<span id="cb28-24"><a href="#cb28-24"></a><span class="co"># also gives the same with two threads</span></span>
<span id="cb28-25"><a href="#cb28-25"></a><span class="kw">all.equal</span>(<span class="kw">eval_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb28-26"><a href="#cb28-26"></a>          <span class="kw">R_func</span>         (noise))</span>
<span id="cb28-27"><a href="#cb28-27"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-28"><a href="#cb28-28"></a><span class="kw">all.equal</span>(gv &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L),</span>
<span id="cb28-29"><a href="#cb28-29"></a>          <span class="kw">R_func_gr</span>            (noise), </span>
<span id="cb28-30"><a href="#cb28-30"></a>          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</span>
<span id="cb28-31"><a href="#cb28-31"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-32"><a href="#cb28-32"></a><span class="kw">all.equal</span>(<span class="kw">attr</span>(gv, <span class="st">&quot;value&quot;</span>), <span class="kw">R_func</span>(noise))</span>
<span id="cb28-33"><a href="#cb28-33"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-34"><a href="#cb28-34"></a></span>
<span id="cb28-35"><a href="#cb28-35"></a><span class="co"># optimize and compare the result with one thread</span></span>
<span id="cb28-36"><a href="#cb28-36"></a>psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 1L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.1</span>, <span class="dt">trace =</span> 0L, </span>
<span id="cb28-37"><a href="#cb28-37"></a>                      <span class="dt">pre_method =</span> 1L, <span class="dt">cg_tol =</span> <span class="fl">.5</span>)</span>
<span id="cb28-38"><a href="#cb28-38"></a>  <span class="kw">optim_generic_ex</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> ptr, <span class="dt">rel_eps =</span> <span class="fl">1e-9</span>, <span class="dt">max_it =</span> 1000L, </span>
<span id="cb28-39"><a href="#cb28-39"></a>                   <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, </span>
<span id="cb28-40"><a href="#cb28-40"></a>                   <span class="dt">cg_tol =</span> cg_tol, <span class="dt">pre_method =</span> pre_method)</span>
<span id="cb28-41"><a href="#cb28-41"></a></span>
<span id="cb28-42"><a href="#cb28-42"></a>opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start)</span>
<span id="cb28-43"><a href="#cb28-43"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, opt<span class="op">$</span>par, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</span>
<span id="cb28-44"><a href="#cb28-44"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-45"><a href="#cb28-45"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt<span class="op">$</span>value)</span>
<span id="cb28-46"><a href="#cb28-46"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-47"><a href="#cb28-47"></a>opt_psqn<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>opt<span class="op">$</span>value <span class="co"># (negative values implies a better solution)</span></span>
<span id="cb28-48"><a href="#cb28-48"></a><span class="co">#&gt; [1] -0.000102</span></span>
<span id="cb28-49"><a href="#cb28-49"></a></span>
<span id="cb28-50"><a href="#cb28-50"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, glm_fit<span class="op">$</span>coefficients, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</span>
<span id="cb28-51"><a href="#cb28-51"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-52"><a href="#cb28-52"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, <span class="kw">R_func</span>(glm_fit<span class="op">$</span>coefficients))</span>
<span id="cb28-53"><a href="#cb28-53"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-54"><a href="#cb28-54"></a></span>
<span id="cb28-55"><a href="#cb28-55"></a><span class="co"># compare counts</span></span>
<span id="cb28-56"><a href="#cb28-56"></a>opt_psqn<span class="op">$</span>counts</span>
<span id="cb28-57"><a href="#cb28-57"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb28-58"><a href="#cb28-58"></a><span class="co">#&gt;       93       58       67</span></span>
<span id="cb28-59"><a href="#cb28-59"></a>opt     <span class="op">$</span>counts</span>
<span id="cb28-60"><a href="#cb28-60"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb28-61"><a href="#cb28-61"></a><span class="co">#&gt;      425      103</span></span>
<span id="cb28-62"><a href="#cb28-62"></a></span>
<span id="cb28-63"><a href="#cb28-63"></a><span class="co"># we can do the same with two threads</span></span>
<span id="cb28-64"><a href="#cb28-64"></a>opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb28-65"><a href="#cb28-65"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>par, opt<span class="op">$</span>par, <span class="dt">tolerance =</span> <span class="fl">1e-3</span>)</span>
<span id="cb28-66"><a href="#cb28-66"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-67"><a href="#cb28-67"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt<span class="op">$</span>value)</span>
<span id="cb28-68"><a href="#cb28-68"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb28-69"><a href="#cb28-69"></a>opt_psqn<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>opt<span class="op">$</span>value <span class="co"># (negative values implies a better solution)</span></span>
<span id="cb28-70"><a href="#cb28-70"></a><span class="co">#&gt; [1] -0.000102</span></span>
<span id="cb28-71"><a href="#cb28-71"></a></span>
<span id="cb28-72"><a href="#cb28-72"></a><span class="co"># compare counts</span></span>
<span id="cb28-73"><a href="#cb28-73"></a>opt_psqn<span class="op">$</span>counts</span>
<span id="cb28-74"><a href="#cb28-74"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb28-75"><a href="#cb28-75"></a><span class="co">#&gt;       93       58       67</span></span>
<span id="cb28-76"><a href="#cb28-76"></a>opt     <span class="op">$</span>counts</span>
<span id="cb28-77"><a href="#cb28-77"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb28-78"><a href="#cb28-78"></a><span class="co">#&gt;      425      103</span></span></code></pre></div>
<p>The C++ version is much faster:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="st">`</span><span class="dt">R version</span><span class="st">`</span> =<span class="st"> </span><span class="kw">optim</span>(start, R_func, R_func_gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="st">`</span><span class="dt">R w/ C++</span><span class="st">`</span> =<span class="st"> </span><span class="kw">optim</span>(</span>
<span id="cb29-4"><a href="#cb29-4"></a>    start, </span>
<span id="cb29-5"><a href="#cb29-5"></a>    <span class="cf">function</span>(x) <span class="kw">eval_generic_ex</span>(x, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb29-6"><a href="#cb29-6"></a>    <span class="cf">function</span>(x) <span class="kw">grad_generic_ex</span>(x, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb29-7"><a href="#cb29-7"></a>    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </span>
<span id="cb29-8"><a href="#cb29-8"></a>  <span class="dt">psqn =</span> <span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb29-9"><a href="#cb29-9"></a>  <span class="st">`</span><span class="dt">psqn 2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb29-10"><a href="#cb29-10"></a>  <span class="dt">min_iterations =</span> 2L, <span class="dt">check =</span> <span class="ot">FALSE</span>)</span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="co">#&gt; # A tibble: 4 x 6</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="co">#&gt;   expression          min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="co">#&gt;   &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="co">#&gt; 1 R version         7.87s    7.91s     0.126    55.5MB     6.44</span></span>
<span id="cb29-16"><a href="#cb29-16"></a><span class="co">#&gt; 2 R w/ C++          2.11s    2.21s     0.452      26MB     0   </span></span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="co">#&gt; 3 psqn            86.28ms  98.93ms    10.2      18.2KB     0   </span></span>
<span id="cb29-18"><a href="#cb29-18"></a><span class="co">#&gt; 4 psqn 2 threads  46.12ms  48.41ms    20.3      18.2KB     0</span></span></code></pre></div>
<div id="generic-example-r-interface" class="section level4">
<h4>Generic Example: R Interface</h4>
<p>A R interface to the <code>optimizer_generic</code> class is provided through the <code>psqn_generic</code> function. We show an example below of how the R interface can be used to solve the same problem we had before:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="co"># assign the function to pass to psqn_generic</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</span>
<span id="cb30-3"><a href="#cb30-3"></a>  z &lt;-<span class="st"> </span>dat[[i]]</span>
<span id="cb30-4"><a href="#cb30-4"></a>  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">==</span><span class="st"> </span>0L)</span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="co"># we need to return the indices of the parameters that this element function</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="co"># depends on. These need to be one-based like in R</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="kw">return</span>(z<span class="op">$</span>indices)</span>
<span id="cb30-8"><a href="#cb30-8"></a>  </span>
<span id="cb30-9"><a href="#cb30-9"></a>  <span class="co"># we need to compute the element function and possibly its gradient</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>  eta &lt;-<span class="st"> </span><span class="kw">sum</span>(par)</span>
<span id="cb30-11"><a href="#cb30-11"></a>  exp_eta &lt;-<span class="st"> </span><span class="kw">exp</span>(eta)</span>
<span id="cb30-12"><a href="#cb30-12"></a>  out &lt;-<span class="st"> </span><span class="op">-</span>z<span class="op">$</span>y <span class="op">*</span><span class="st"> </span>eta <span class="op">+</span><span class="st"> </span>exp_eta</span>
<span id="cb30-13"><a href="#cb30-13"></a>  <span class="cf">if</span>(comp_grad)</span>
<span id="cb30-14"><a href="#cb30-14"></a>    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="op">-</span>z<span class="op">$</span>y <span class="op">+</span><span class="st"> </span>exp_eta, <span class="kw">length</span>(z<span class="op">$</span>indices))</span>
<span id="cb30-15"><a href="#cb30-15"></a>  out</span>
<span id="cb30-16"><a href="#cb30-16"></a>}</span>
<span id="cb30-17"><a href="#cb30-17"></a></span>
<span id="cb30-18"><a href="#cb30-18"></a><span class="co"># estimate the model with the R interface</span></span>
<span id="cb30-19"><a href="#cb30-19"></a>psqn_func_R &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, <span class="dt">c2 =</span> <span class="fl">.1</span>, <span class="dt">trace =</span> 0L, <span class="dt">pre_method =</span> 1L)</span>
<span id="cb30-20"><a href="#cb30-20"></a>  <span class="kw">psqn_generic</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> <span class="kw">length</span>(dat), </span>
<span id="cb30-21"><a href="#cb30-21"></a>               <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, <span class="dt">rel_eps =</span> <span class="fl">1e-9</span>, <span class="dt">max_it =</span> 1000L, </span>
<span id="cb30-22"><a href="#cb30-22"></a>               <span class="dt">pre_method =</span> pre_method)</span>
<span id="cb30-23"><a href="#cb30-23"></a></span>
<span id="cb30-24"><a href="#cb30-24"></a>opt_psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func_R</span>(start)</span>
<span id="cb30-25"><a href="#cb30-25"></a></span>
<span id="cb30-26"><a href="#cb30-26"></a><span class="co"># we get the same </span></span>
<span id="cb30-27"><a href="#cb30-27"></a>opt_psqn &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">n_threads =</span> 1L)</span>
<span id="cb30-28"><a href="#cb30-28"></a><span class="kw">all.equal</span>(opt_psqn_res<span class="op">$</span>par  , opt_psqn<span class="op">$</span>par  )</span>
<span id="cb30-29"><a href="#cb30-29"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb30-30"><a href="#cb30-30"></a><span class="kw">all.equal</span>(opt_psqn_res<span class="op">$</span>value, opt_psqn<span class="op">$</span>value)</span>
<span id="cb30-31"><a href="#cb30-31"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>The R version is much slower though in this case. The reason is that the element functions are extremely cheap computationally to evaluate and therefore the extra overhead from the R interface is an issue.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># show the computation time</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>bench<span class="op">::</span><span class="kw">mark</span>(<span class="kw">psqn_func_R</span>(start), <span class="dt">min_iterations =</span> 2L)</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="co">#&gt; # A tibble: 1 x 6</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="co">#&gt;   expression              min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="co">#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="co">#&gt; 1 psqn_func_R(start)    10.9s    11.1s    0.0900    29.3KB     4.14</span></span></code></pre></div>
</div>
<div id="getting-the-hessian-approximation-1" class="section level4">
<h4>Getting the Hessian Approximation</h4>
<p>We can get the Hessian approximation by calling the <code>get_Hess_approx_generic</code> and <code>get_sparse_Hess_approx_generic</code> we declared after calling the optimizer:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a>aprox_hes &lt;-<span class="st"> </span><span class="kw">get_Hess_approx_generic</span>(ptr)</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">dim</span>(aprox_hes) <span class="co"># quite large; requires a lot of memory</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="co">#&gt; [1] 2000 2000</span></span>
<span id="cb32-4"><a href="#cb32-4"></a></span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="co"># we can also get the sparse version</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>aprox_hes_sparse &lt;-<span class="st"> </span><span class="kw">get_sparse_Hess_approx_generic</span>(ptr)</span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="kw">all.equal</span>(<span class="kw">as.matrix</span>(aprox_hes_sparse), aprox_hes, </span>
<span id="cb32-8"><a href="#cb32-8"></a>          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb32-10"><a href="#cb32-10"></a></span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="co"># this require much less memory </span></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="kw">object.size</span>(aprox_hes)</span>
<span id="cb32-13"><a href="#cb32-13"></a><span class="co">#&gt; 32000216 bytes</span></span>
<span id="cb32-14"><a href="#cb32-14"></a><span class="kw">object.size</span>(aprox_hes_sparse)</span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="co">#&gt; 1717344 bytes</span></span>
<span id="cb32-16"><a href="#cb32-16"></a></span>
<span id="cb32-17"><a href="#cb32-17"></a><span class="co"># we can roughly check against the true values as follows</span></span>
<span id="cb32-18"><a href="#cb32-18"></a><span class="cf">if</span>(<span class="ot">FALSE</span>){</span>
<span id="cb32-19"><a href="#cb32-19"></a>  <span class="co"># only feasible for smaller problem</span></span>
<span id="cb32-20"><a href="#cb32-20"></a>  <span class="kw">library</span>(numDeriv)</span>
<span id="cb32-21"><a href="#cb32-21"></a>  hess_true &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="cf">function</span>(par) <span class="kw">grad_generic_ex</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb32-23"><a href="#cb32-23"></a>    opt_psqn<span class="op">$</span>par)</span>
<span id="cb32-24"><a href="#cb32-24"></a>  </span>
<span id="cb32-25"><a href="#cb32-25"></a>  <span class="co"># should not hold exactly! Might not be that good of an approximation.</span></span>
<span id="cb32-26"><a href="#cb32-26"></a>  <span class="kw">all.equal</span>(aprox_hes, hess_true)</span>
<span id="cb32-27"><a href="#cb32-27"></a>  </span>
<span id="cb32-28"><a href="#cb32-28"></a>  <span class="co"># the non-zero entries should match </span></span>
<span id="cb32-29"><a href="#cb32-29"></a>  v1 &lt;-<span class="st"> </span><span class="kw">abs</span>(hess_true) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb32-30"><a href="#cb32-30"></a>  v2 &lt;-<span class="st"> </span><span class="kw">abs</span>(aprox_hes) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb32-31"><a href="#cb32-31"></a>  <span class="kw">all.equal</span>(v1, v2)</span>
<span id="cb32-32"><a href="#cb32-32"></a>}</span>
<span id="cb32-33"><a href="#cb32-33"></a></span>
<span id="cb32-34"><a href="#cb32-34"></a><span class="co"># create a plot like before. Black entries are non-zero</span></span>
<span id="cb32-35"><a href="#cb32-35"></a><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>))</span>
<span id="cb32-36"><a href="#cb32-36"></a>idx &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">min</span>(<span class="dv">1000</span>, <span class="kw">NROW</span>(aprox_hes))</span>
<span id="cb32-37"><a href="#cb32-37"></a>aprox_hes &lt;-<span class="st"> </span>aprox_hes[idx, idx] <span class="co"># reduce dimension to plot quickly</span></span>
<span id="cb32-38"><a href="#cb32-38"></a><span class="kw">image</span>(<span class="kw">abs</span>(aprox_hes[, <span class="kw">NCOL</span>(aprox_hes)<span class="op">:</span><span class="dv">1</span>]) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dt">xaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>,</span>
<span id="cb32-39"><a href="#cb32-39"></a>      <span class="dt">col =</span> <span class="kw">gray.colors</span>(2L, <span class="dv">1</span>, <span class="dv">0</span>))</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
</div>
<div id="using-different-preconditioners-1" class="section level4">
<h4>Using Different Preconditioners</h4>
<p>We can use different preconditioner. We illustrate this below. Notice that you have to define the <code>PSQN_USE_EIGEN</code> macro variable prior to including any of the psqn headers files if you are using the C++ interface in order to use the incomplete Cholesky factorization from Eigen. You will also have to include RcppEigen or the psqn-Rcpp-wrapper.h header.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># without any preconditioner</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>opt_psqn_no_pre &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">pre_method =</span> 0L)</span>
<span id="cb33-3"><a href="#cb33-3"></a></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="co"># we get the same</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt_psqn_no_pre<span class="op">$</span>value)</span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="co"># we mainly use more conjugate gradient steps</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>opt_psqn       <span class="op">$</span>counts</span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="co">#&gt;       93       58       67</span></span>
<span id="cb33-12"><a href="#cb33-12"></a>opt_psqn_no_pre<span class="op">$</span>counts</span>
<span id="cb33-13"><a href="#cb33-13"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb33-14"><a href="#cb33-14"></a><span class="co">#&gt;       85       56      145</span></span>
<span id="cb33-15"><a href="#cb33-15"></a></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="co"># with the incomplete Cholesky factorization</span></span>
<span id="cb33-17"><a href="#cb33-17"></a>opt_psqn_cholesky &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start, <span class="dt">pre_method =</span> 2L)</span>
<span id="cb33-18"><a href="#cb33-18"></a><span class="kw">all.equal</span>(opt_psqn<span class="op">$</span>value, opt_psqn_cholesky<span class="op">$</span>value)</span>
<span id="cb33-19"><a href="#cb33-19"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb33-20"><a href="#cb33-20"></a></span>
<span id="cb33-21"><a href="#cb33-21"></a><span class="co"># we use fewer conjugate gradient steps</span></span>
<span id="cb33-22"><a href="#cb33-22"></a>opt_psqn_cholesky<span class="op">$</span>counts</span>
<span id="cb33-23"><a href="#cb33-23"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb33-24"><a href="#cb33-24"></a><span class="co">#&gt;       87       50       32</span></span>
<span id="cb33-25"><a href="#cb33-25"></a>opt_psqn         <span class="op">$</span>counts</span>
<span id="cb33-26"><a href="#cb33-26"></a><span class="co">#&gt; function gradient     n_cg </span></span>
<span id="cb33-27"><a href="#cb33-27"></a><span class="co">#&gt;       93       58       67</span></span>
<span id="cb33-28"><a href="#cb33-28"></a></span>
<span id="cb33-29"><a href="#cb33-29"></a><span class="co"># we can equally use the R interface</span></span>
<span id="cb33-30"><a href="#cb33-30"></a>opt_psqn_cholesky_R &lt;-<span class="st"> </span><span class="kw">psqn_func_R</span>(start, <span class="dt">pre_method =</span> 2L)</span>
<span id="cb33-31"><a href="#cb33-31"></a><span class="kw">all.equal</span>(opt_psqn_cholesky_R[<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)], </span>
<span id="cb33-32"><a href="#cb33-32"></a>          opt_psqn_cholesky  [<span class="kw">c</span>(<span class="st">&quot;par&quot;</span>, <span class="st">&quot;value&quot;</span>, <span class="st">&quot;counts&quot;</span>)])</span>
<span id="cb33-33"><a href="#cb33-33"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
</div>
<div id="using-kahan-summation-algorithm" class="section level3">
<h3>Using Kahan Summation Algorithm</h3>
<p>By default, <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a> is used with the <code>optimizer_generic</code> class. This can be avoided by defining <code>PSQN_NO_USE_KAHAN</code> prior to including any headers from the psqn package. One may want to do so if numerical stability does not matter for a given problem. Notice though that the extra computation time may only be substantial if the <code>func</code> and <code>grad</code> member functions are evaluated very fast.</p>
<p>To illustrate this, we will show that the previous method yields almost the same regardless of the number of threads. Then we will show that the difference is larger when we define <code>PSQN_NO_USE_KAHAN</code> but the computation time is reduced.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># we get almost the same regardless of the number of threads. We show this by </span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="co"># looking at the mean relative error of the gradient</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>g1 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L)</span>
<span id="cb34-4"><a href="#cb34-4"></a>g2 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb34-5"><a href="#cb34-5"></a>g3 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L)</span>
<span id="cb34-6"><a href="#cb34-6"></a></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">mean</span>(<span class="kw">abs</span>((g1 <span class="op">-</span><span class="st"> </span>g2) <span class="op">/</span><span class="st"> </span>g1)) </span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="co">#&gt; [1] 1.3e-16</span></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="kw">mean</span>(<span class="kw">abs</span>((g1 <span class="op">-</span><span class="st"> </span>g3) <span class="op">/</span><span class="st"> </span>g1))</span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="co">#&gt; [1] 1.23e-16</span></span>
<span id="cb34-11"><a href="#cb34-11"></a></span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="co"># the computation time is as follows</span></span>
<span id="cb34-13"><a href="#cb34-13"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb34-14"><a href="#cb34-14"></a>  <span class="st">`</span><span class="dt">1 thread</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb34-15"><a href="#cb34-15"></a>  <span class="st">`</span><span class="dt">2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb34-16"><a href="#cb34-16"></a>  <span class="st">`</span><span class="dt">3 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L))</span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="co">#&gt; # A tibble: 3 x 6</span></span>
<span id="cb34-18"><a href="#cb34-18"></a><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb34-19"><a href="#cb34-19"></a><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb34-20"><a href="#cb34-20"></a><span class="co">#&gt; 1 1 thread      477µs    488µs     2006.    18.2KB        0</span></span>
<span id="cb34-21"><a href="#cb34-21"></a><span class="co">#&gt; 2 2 threads     235µs    243µs     4057.    18.2KB        0</span></span>
<span id="cb34-22"><a href="#cb34-22"></a><span class="co">#&gt; 3 3 threads     167µs    173µs     5701.    18.2KB        0</span></span>
<span id="cb34-23"><a href="#cb34-23"></a></span>
<span id="cb34-24"><a href="#cb34-24"></a><span class="co"># next, we compile the file but having defined PSQN_NO_USE_KAHAN in the </span></span>
<span id="cb34-25"><a href="#cb34-25"></a><span class="co"># beginning</span></span>
<span id="cb34-26"><a href="#cb34-26"></a>tmp_file &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">tempfile</span>(), <span class="st">&quot;.cpp&quot;</span>)</span>
<span id="cb34-27"><a href="#cb34-27"></a>tmp_file_con &lt;-<span class="st"> </span><span class="kw">file</span>(tmp_file)</span>
<span id="cb34-28"><a href="#cb34-28"></a><span class="kw">writeLines</span>(</span>
<span id="cb34-29"><a href="#cb34-29"></a>  <span class="co"># add the macro definition to the beginning of the file</span></span>
<span id="cb34-30"><a href="#cb34-30"></a>  <span class="kw">c</span>(<span class="st">&quot;#define PSQN_NO_USE_KAHAN&quot;</span>, </span>
<span id="cb34-31"><a href="#cb34-31"></a>    <span class="kw">readLines</span>(<span class="kw">system.file</span>(<span class="st">&quot;generic_example.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))), </span>
<span id="cb34-32"><a href="#cb34-32"></a>  tmp_file_con)</span>
<span id="cb34-33"><a href="#cb34-33"></a><span class="kw">close</span>(tmp_file_con)</span>
<span id="cb34-34"><a href="#cb34-34"></a><span class="kw">sourceCpp</span>(tmp_file) <span class="co"># source the file again</span></span>
<span id="cb34-35"><a href="#cb34-35"></a></span>
<span id="cb34-36"><a href="#cb34-36"></a><span class="co"># re-compute the gradient and the mean relative error of the gradient</span></span>
<span id="cb34-37"><a href="#cb34-37"></a>ptr &lt;-<span class="st"> </span><span class="kw">get_generic_ex_obj</span>(cpp_arg, <span class="dt">max_threads =</span> 4L)</span>
<span id="cb34-38"><a href="#cb34-38"></a>new_g1 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L)</span>
<span id="cb34-39"><a href="#cb34-39"></a>new_g2 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L)</span>
<span id="cb34-40"><a href="#cb34-40"></a>new_g3 &lt;-<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L)</span>
<span id="cb34-41"><a href="#cb34-41"></a></span>
<span id="cb34-42"><a href="#cb34-42"></a><span class="kw">mean</span>(<span class="kw">abs</span>((g1     <span class="op">-</span><span class="st"> </span>new_g1) <span class="op">/</span><span class="st"> </span>g1    ))</span>
<span id="cb34-43"><a href="#cb34-43"></a><span class="co">#&gt; [1] 3.9e-16</span></span>
<span id="cb34-44"><a href="#cb34-44"></a><span class="kw">mean</span>(<span class="kw">abs</span>((new_g1 <span class="op">-</span><span class="st"> </span>new_g2) <span class="op">/</span><span class="st"> </span>new_g1)) </span>
<span id="cb34-45"><a href="#cb34-45"></a><span class="co">#&gt; [1] 2.5e-16</span></span>
<span id="cb34-46"><a href="#cb34-46"></a><span class="kw">mean</span>(<span class="kw">abs</span>((new_g1 <span class="op">-</span><span class="st"> </span>new_g3) <span class="op">/</span><span class="st"> </span>new_g1))</span>
<span id="cb34-47"><a href="#cb34-47"></a><span class="co">#&gt; [1] 2.76e-16</span></span>
<span id="cb34-48"><a href="#cb34-48"></a></span>
<span id="cb34-49"><a href="#cb34-49"></a><span class="co"># check the new computation time</span></span>
<span id="cb34-50"><a href="#cb34-50"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb34-51"><a href="#cb34-51"></a>  <span class="st">`</span><span class="dt">1 thread</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 1L), </span>
<span id="cb34-52"><a href="#cb34-52"></a>  <span class="st">`</span><span class="dt">2 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 2L), </span>
<span id="cb34-53"><a href="#cb34-53"></a>  <span class="st">`</span><span class="dt">3 threads</span><span class="st">`</span> =<span class="st"> </span><span class="kw">grad_generic_ex</span>(noise, <span class="dt">ptr =</span> ptr, <span class="dt">n_threads =</span> 3L))</span>
<span id="cb34-54"><a href="#cb34-54"></a><span class="co">#&gt; # A tibble: 3 x 6</span></span>
<span id="cb34-55"><a href="#cb34-55"></a><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb34-56"><a href="#cb34-56"></a><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb34-57"><a href="#cb34-57"></a><span class="co">#&gt; 1 1 thread      442µs    452µs     2150.    18.2KB        0</span></span>
<span id="cb34-58"><a href="#cb34-58"></a><span class="co">#&gt; 2 2 threads     217µs    225µs     4368.    18.2KB        0</span></span>
<span id="cb34-59"><a href="#cb34-59"></a><span class="co">#&gt; 3 3 threads     153µs    160µs     6161.    18.2KB        0</span></span></code></pre></div>
<p>The error is only slightly larger in the latter case in this example and the computation time is reduced because the <code>func</code> and <code>grad</code> member functions are cheap to evaluate computationally.</p>
</div>
</div>
<div id="details" class="section level2">
<h2>Details</h2>
<div id="using-the-code-in-a-package" class="section level3">
<h3>Using the Code in a Package</h3>
<p>The main part of this packages is a header-only library. Thus, the code can be used within a R package by adding <code>psqn</code> to <code>LinkingTo</code> in the DESCRIPTION file. This is an advantage as one can avoid repeated compilation of the code.</p>
<p>Moreover, since the main part of the code is a header-only library, this package can easily be used within languages which can easily call C++ code.</p>
</div>
<div id="bfgs-method" class="section level3">
<h3>BFGS Method</h3>
<p>There is also a BFGS implementation in the package. This is both available in R through the <code>psqn_bfgs</code> function and in C++ in the psqn-bfgs.h header file. An example is provided below using the example from <code>optim</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># declare function and gradient from the example from help(optim)</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>fn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb35-3"><a href="#cb35-3"></a>  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</span>
<span id="cb35-4"><a href="#cb35-4"></a>  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</span>
<span id="cb35-5"><a href="#cb35-5"></a>  <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>}</span>
<span id="cb35-7"><a href="#cb35-7"></a>gr &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb35-8"><a href="#cb35-8"></a>  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</span>
<span id="cb35-9"><a href="#cb35-9"></a>  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</span>
<span id="cb35-10"><a href="#cb35-10"></a>  <span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</span>
<span id="cb35-11"><a href="#cb35-11"></a>     <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</span>
<span id="cb35-12"><a href="#cb35-12"></a>}</span>
<span id="cb35-13"><a href="#cb35-13"></a></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="co"># we need a different function for the method in this package</span></span>
<span id="cb35-15"><a href="#cb35-15"></a>gr_psqn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb35-16"><a href="#cb35-16"></a>  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</span>
<span id="cb35-17"><a href="#cb35-17"></a>  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</span>
<span id="cb35-18"><a href="#cb35-18"></a>  out &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</span>
<span id="cb35-19"><a href="#cb35-19"></a>            <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</span>
<span id="cb35-20"><a href="#cb35-20"></a>  <span class="kw">attr</span>(out, <span class="st">&quot;value&quot;</span>) &lt;-<span class="st"> </span><span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></span>
<span id="cb35-21"><a href="#cb35-21"></a>  out</span>
<span id="cb35-22"><a href="#cb35-22"></a>}</span>
<span id="cb35-23"><a href="#cb35-23"></a></span>
<span id="cb35-24"><a href="#cb35-24"></a><span class="co"># we get the same</span></span>
<span id="cb35-25"><a href="#cb35-25"></a><span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)<span class="op">$</span>par</span>
<span id="cb35-26"><a href="#cb35-26"></a><span class="co">#&gt; [1] 1 1</span></span>
<span id="cb35-27"><a href="#cb35-27"></a><span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn)            <span class="op">$</span>par</span>
<span id="cb35-28"><a href="#cb35-28"></a><span class="co">#&gt; [1] 1 1</span></span>
<span id="cb35-29"><a href="#cb35-29"></a></span>
<span id="cb35-30"><a href="#cb35-30"></a><span class="co"># they run in about the same time</span></span>
<span id="cb35-31"><a href="#cb35-31"></a>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb35-32"><a href="#cb35-32"></a>  <span class="dt">optim     =</span> <span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </span>
<span id="cb35-33"><a href="#cb35-33"></a>  <span class="dt">psqn_bfgs =</span> <span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn), </span>
<span id="cb35-34"><a href="#cb35-34"></a>  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="fl">.5</span>)</span>
<span id="cb35-35"><a href="#cb35-35"></a><span class="co">#&gt; # A tibble: 2 x 6</span></span>
<span id="cb35-36"><a href="#cb35-36"></a><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span id="cb35-37"><a href="#cb35-37"></a><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></span>
<span id="cb35-38"><a href="#cb35-38"></a><span class="co">#&gt; 1 optim       112.5µs    119µs     7924.      384B     14.9</span></span>
<span id="cb35-39"><a href="#cb35-39"></a><span class="co">#&gt; 2 psqn_bfgs    87.2µs   90.4µs    10680.    2.49KB     15.2</span></span></code></pre></div>
</div>
<div id="bfgs-and-partially-separable-quasi-newton" class="section level3">
<h3>BFGS and Partially Separable Quasi-Newton</h3>
<p>Below we show the ratio of flops required in the matrix-vector product in a BFGS method relative to the flops required in the matrix-vector product for the conjugate gradient method for the quasi-Newton method:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a>vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">n =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">8</span><span class="op">:</span><span class="dv">13</span>), <span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>))</span>
<span id="cb36-2"><a href="#cb36-2"></a>vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</span>
<span id="cb36-3"><a href="#cb36-3"></a>  flops_qsn &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q) <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>1L)</span>
<span id="cb36-4"><a href="#cb36-4"></a>  flops_bfgs &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>(q <span class="op">*</span><span class="st"> </span>n <span class="op">+</span><span class="st"> </span>p)<span class="op">^</span><span class="dv">2</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>  ratio &lt;-<span class="st"> </span>flops_bfgs <span class="op">/</span><span class="st"> </span>flops_qsn</span>
<span id="cb36-6"><a href="#cb36-6"></a>})</span>
<span id="cb36-7"><a href="#cb36-7"></a>nq &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q))</span>
<span id="cb36-8"><a href="#cb36-8"></a>tvals &lt;-<span class="st"> </span><span class="kw">c</span>(vals<span class="op">$</span>n[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], </span>
<span id="cb36-9"><a href="#cb36-9"></a>           vals<span class="op">$</span>p[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], <span class="kw">floor</span>(vals[, <span class="st">&quot;ratio&quot;</span>]))</span>
<span id="cb36-10"><a href="#cb36-10"></a></span>
<span id="cb36-11"><a href="#cb36-11"></a>vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</span>
<span id="cb36-12"><a href="#cb36-12"></a>  tvals, <span class="dt">ncol =</span> nq <span class="op">+</span><span class="st"> </span>2L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;n&quot;</span>, <span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</span>
<span id="cb36-14"><a href="#cb36-14"></a>knitr<span class="op">::</span><span class="kw">kable</span>(vals)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">n</th>
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">256</td>
<td align="right">4</td>
<td align="right">57</td>
<td align="right">105</td>
<td align="right">156</td>
<td align="right">196</td>
<td align="right">223</td>
<td align="right">238</td>
<td align="right">247</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">4</td>
<td align="right">114</td>
<td align="right">210</td>
<td align="right">312</td>
<td align="right">393</td>
<td align="right">447</td>
<td align="right">477</td>
<td align="right">494</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">4</td>
<td align="right">228</td>
<td align="right">420</td>
<td align="right">624</td>
<td align="right">787</td>
<td align="right">894</td>
<td align="right">955</td>
<td align="right">988</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">4</td>
<td align="right">455</td>
<td align="right">840</td>
<td align="right">1248</td>
<td align="right">1574</td>
<td align="right">1787</td>
<td align="right">1911</td>
<td align="right">1977</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">4</td>
<td align="right">910</td>
<td align="right">1680</td>
<td align="right">2496</td>
<td align="right">3149</td>
<td align="right">3575</td>
<td align="right">3822</td>
<td align="right">3955</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">4</td>
<td align="right">1820</td>
<td align="right">3361</td>
<td align="right">4993</td>
<td align="right">6297</td>
<td align="right">7151</td>
<td align="right">7645</td>
<td align="right">7911</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">8</td>
<td align="right">26</td>
<td align="right">60</td>
<td align="right">109</td>
<td align="right">160</td>
<td align="right">199</td>
<td align="right">225</td>
<td align="right">239</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">8</td>
<td align="right">52</td>
<td align="right">120</td>
<td align="right">218</td>
<td align="right">320</td>
<td align="right">399</td>
<td align="right">450</td>
<td align="right">479</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">8</td>
<td align="right">105</td>
<td align="right">241</td>
<td align="right">437</td>
<td align="right">639</td>
<td align="right">798</td>
<td align="right">900</td>
<td align="right">959</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">8</td>
<td align="right">210</td>
<td align="right">482</td>
<td align="right">874</td>
<td align="right">1279</td>
<td align="right">1596</td>
<td align="right">1801</td>
<td align="right">1918</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">8</td>
<td align="right">420</td>
<td align="right">964</td>
<td align="right">1748</td>
<td align="right">2557</td>
<td align="right">3192</td>
<td align="right">3601</td>
<td align="right">3837</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">8</td>
<td align="right">840</td>
<td align="right">1928</td>
<td align="right">3495</td>
<td align="right">5115</td>
<td align="right">6384</td>
<td align="right">7203</td>
<td align="right">7674</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">16</td>
<td align="right">10</td>
<td align="right">27</td>
<td align="right">62</td>
<td align="right">111</td>
<td align="right">162</td>
<td align="right">201</td>
<td align="right">226</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">16</td>
<td align="right">19</td>
<td align="right">55</td>
<td align="right">124</td>
<td align="right">223</td>
<td align="right">323</td>
<td align="right">401</td>
<td align="right">451</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">16</td>
<td align="right">39</td>
<td align="right">109</td>
<td align="right">248</td>
<td align="right">446</td>
<td align="right">647</td>
<td align="right">803</td>
<td align="right">903</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">16</td>
<td align="right">78</td>
<td align="right">218</td>
<td align="right">496</td>
<td align="right">892</td>
<td align="right">1294</td>
<td align="right">1607</td>
<td align="right">1807</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">16</td>
<td align="right">156</td>
<td align="right">437</td>
<td align="right">993</td>
<td align="right">1783</td>
<td align="right">2589</td>
<td align="right">3214</td>
<td align="right">3615</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">16</td>
<td align="right">312</td>
<td align="right">874</td>
<td align="right">1986</td>
<td align="right">3567</td>
<td align="right">5178</td>
<td align="right">6428</td>
<td align="right">7230</td>
</tr>
</tbody>
</table>
<p>The</p>
<p><span class="math display">\[\frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}\]</span></p>
<p>ratio from the section called <a href="#conjugate-gradient-method">Conjugate Gradient Method</a> is shown below:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</span>
<span id="cb37-2"><a href="#cb37-2"></a>vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</span>
<span id="cb37-3"><a href="#cb37-3"></a>  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(p<span class="op">^</span><span class="dv">2</span>  <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb37-4"><a href="#cb37-4"></a>})</span>
<span id="cb37-5"><a href="#cb37-5"></a>tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a>vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</span>
<span id="cb37-8"><a href="#cb37-8"></a>  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</span>
<span id="cb37-9"><a href="#cb37-9"></a>    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</span>
<span id="cb37-10"><a href="#cb37-10"></a>knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.7901</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0002</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.040</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
</tr>
</tbody>
</table>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> term which gives us:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a>vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</span>
<span id="cb38-2"><a href="#cb38-2"></a>vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</span>
<span id="cb38-3"><a href="#cb38-3"></a>  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb38-4"><a href="#cb38-4"></a>})</span>
<span id="cb38-5"><a href="#cb38-5"></a>tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</span>
<span id="cb38-6"><a href="#cb38-6"></a></span>
<span id="cb38-7"><a href="#cb38-7"></a>vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</span>
<span id="cb38-8"><a href="#cb38-8"></a>  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</span>
<span id="cb38-9"><a href="#cb38-9"></a>    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</span>
<span id="cb38-10"><a href="#cb38-10"></a>knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.8000</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0078</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
</tr>
</tbody>
</table>
<p>This is implemented.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-nocedal06">
<p>Nocedal, Jorge, and Stephen Wright. 2006. <em>Numerical Optimization</em>. 2nd ed. Springer Science &amp; Business Media. <a href="https://doi.org/10.1007/978-0-387-40065-5">https://doi.org/10.1007/978-0-387-40065-5</a>.</p>
</div>
<div id="ref-Ormerod11">
<p>Ormerod, J. T. 2011. “Skew-Normal Variational Approximations for Bayesian Inference.” <em>Unpublished Article</em>.</p>
</div>
<div id="ref-Ormerod12">
<p>Ormerod, J. T., and M. P. Wand. 2012. “Gaussian Variational Approximate Inference for Generalized Linear Mixed Models.” <em>Journal of Computational and Graphical Statistics</em> 21 (1): 2–17. <a href="https://doi.org/10.1198/jcgs.2011.09118">https://doi.org/10.1198/jcgs.2011.09118</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
